var tipuesearch = {"pages":[{"title":" Fortran-lang/fpm ","text":"Fortran-lang/fpm Developer Info fortran-lang/fpm contributors","tags":"home","loc":"index.html"},{"title":"fpm_filesystem.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_filesystem Source Code fpm_filesystem.f90 Source Code module fpm_filesystem use fpm_environment , only : get_os_type , & OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_WINDOWS , & OS_CYGWIN , OS_SOLARIS , OS_FREEBSD use fpm_strings , only : f_string , string_t , split implicit none private public :: basename , canon_path , dirname , is_dir , join_path , number_of_rows , read_lines , list_files ,& mkdir , exists , get_temp_filename , windows_path integer , parameter :: LINE_BUFFER_LEN = 1000 contains function basename ( path , suffix ) result ( base ) ! Extract filename from path with/without suffix ! character ( * ), intent ( In ) :: path logical , intent ( in ), optional :: suffix character (:), allocatable :: base character (:), allocatable :: file_parts (:) logical :: with_suffix if (. not . present ( suffix )) then with_suffix = . true . else with_suffix = suffix end if if ( with_suffix ) then call split ( path , file_parts , delimiters = '\\/' ) base = trim ( file_parts ( size ( file_parts ))) else call split ( path , file_parts , delimiters = '\\/.' ) base = trim ( file_parts ( size ( file_parts ) - 1 )) end if end function basename function canon_path ( path ) result ( canon ) ! Canonicalize path for comparison !  Handles path string redundancies !  Does not test existence of path ! ! To be replaced by realpath/_fullname in stdlib_os ! character ( * ), intent ( in ) :: path character (:), allocatable :: canon integer :: i , j integer :: iback character ( len ( path )) :: nixpath character ( len ( path )) :: temp nixpath = unix_path ( path ) j = 1 do i = 1 , len ( nixpath ) ! Skip back to last directory for '/../' if ( i > 4 ) then if ( nixpath ( i - 3 : i ) == '/../' ) then iback = scan ( nixpath ( 1 : i - 4 ), '/' , back = . true .) if ( iback > 0 ) then j = iback + 1 cycle end if end if end if if ( i > 1 . and . j > 1 ) then ! Ignore current directory reference if ( nixpath ( i - 1 : i ) == './' ) then j = j - 1 cycle end if ! Ignore repeated separators if ( nixpath ( i - 1 : i ) == '//' ) then cycle end if ! Do NOT include trailing slash if ( i == len ( nixpath ) . and . nixpath ( i : i ) == '/' ) then cycle end if end if temp ( j : j ) = nixpath ( i : i ) j = j + 1 end do canon = temp ( 1 : j - 1 ) end function canon_path function dirname ( path ) result ( dir ) ! Extract dirname from path ! character ( * ), intent ( in ) :: path character (:), allocatable :: dir character (:), allocatable :: file_parts (:) dir = path ( 1 : scan ( path , '/\\',back=.true.)) end function dirname logical function is_dir(dir) character(*), intent(in) :: dir integer :: stat select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(\"test -d \" // dir , exitstat=stat) case (OS_WINDOWS) call execute_command_line(' cmd / c \"if not exist ' // windows_path(dir) // '\\ exit /B 1\" ', exitstat=stat) end select is_dir = (stat == 0) end function is_dir function join_path(a1,a2,a3,a4,a5) result(path) ! Construct path by joining strings with os file separator ! character(len=*), intent(in)           :: a1, a2 character(len=*), intent(in), optional :: a3, a4, a5 character(len=:), allocatable          :: path character(len=1)                       :: filesep select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) filesep = ' / ' case (OS_WINDOWS) filesep = ' \\ ' end select path = a1 // filesep // a2 if (present(a3)) then path = path // filesep // a3 else return end if if (present(a4)) then path = path // filesep // a4 else return end if if (present(a5)) then path = path // filesep // a5 else return end if end function join_path integer function number_of_rows(s) result(nrows) ! determine number or rows integer,intent(in)::s integer :: ios character(len=100) :: r rewind(s) nrows = 0 do read(s, ' ( A ) ', iostat=ios) r if (ios /= 0) exit nrows = nrows + 1 end do rewind(s) end function number_of_rows function read_lines(fh) result(lines) integer, intent(in) :: fh type(string_t), allocatable :: lines(:) integer :: i character(LINE_BUFFER_LEN) :: line_buffer allocate(lines(number_of_rows(fh))) do i = 1, size(lines) read(fh, ' ( A ) ') line_buffer lines(i)%s = trim(line_buffer) end do end function read_lines subroutine mkdir(dir) character(len=*), intent(in) :: dir integer                      :: stat if (is_dir(dir)) return select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(' mkdir - p ' // dir, exitstat=stat) write (*, ' ( \" + \" , 2 a ) ') ' mkdir - p ' // dir case (OS_WINDOWS) call execute_command_line(\"mkdir \" // windows_path(dir), exitstat=stat) write (*, ' ( \" + \" , 2 a ) ') ' mkdir ' // windows_path(dir) end select if (stat /= 0) then print *, ' execute_command_line () failed ' error stop end if end subroutine mkdir recursive subroutine list_files(dir, files, recurse) ! Get file & directory names in directory `dir`. ! !  - File/directory names return are relative to cwd, ie. preprended with `dir` !  - Includes files starting with `.` except current directory and parent directory ! character(len=*), intent(in) :: dir type(string_t), allocatable, intent(out) :: files(:) logical, intent(in), optional :: recurse integer :: stat, fh, i character(:), allocatable :: temp_file type(string_t), allocatable :: dir_files(:) type(string_t), allocatable :: sub_dir_files(:) if (.not. is_dir(dir)) then allocate (files(0)) return end if allocate (temp_file, source=get_temp_filename()) select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(' ls - A ' // dir // ' > ' // temp_file, & exitstat=stat) case (OS_WINDOWS) call execute_command_line(' dir / b ' // windows_path(dir) // ' > ' // temp_file, & exitstat=stat) end select if (stat /= 0) then print *, ' execute_command_line () failed ' error stop end if open (newunit=fh, file=temp_file, status=' old ') files = read_lines(fh) close(fh,status=\"delete\") do i=1,size(files) files(i)%s = join_path(dir,files(i)%s) end do if (present(recurse)) then if (recurse) then allocate(sub_dir_files(0)) do i=1,size(files) if (is_dir(files(i)%s)) then call list_files(files(i)%s, dir_files, recurse=.true.) sub_dir_files = [sub_dir_files, dir_files] end if end do files = [files, sub_dir_files] end if end if end subroutine list_files logical function exists(filename) result(r) character(len=*), intent(in) :: filename inquire(file=filename, exist=r) end function function get_temp_filename() result(tempfile) ! Get a unused temporary filename !  Calls posix ' tempnam ' - not recommended, but !   we have no security concerns for this application !   and use here is temporary. ! Works with MinGW ! use iso_c_binding, only: c_ptr, C_NULL_PTR, c_f_pointer character(:), allocatable :: tempfile type(c_ptr) :: c_tempfile_ptr character(len=1), pointer :: c_tempfile(:) interface function c_tempnam(dir,pfx) result(tmp) bind(c,name=\"tempnam\") import type(c_ptr), intent(in), value :: dir type(c_ptr), intent(in), value :: pfx type(c_ptr) :: tmp end function c_tempnam subroutine c_free(ptr) BIND(C,name=\"free\") import type(c_ptr), value :: ptr end subroutine c_free end interface c_tempfile_ptr = c_tempnam(C_NULL_PTR, C_NULL_PTR) call c_f_pointer(c_tempfile_ptr,c_tempfile,[LINE_BUFFER_LEN]) tempfile = f_string(c_tempfile) call c_free(c_tempfile_ptr) end function get_temp_filename function windows_path(path) result(winpath) ! Replace file system separators for windows ! character(*), intent(in) :: path character(:), allocatable :: winpath integer :: idx winpath = path idx = index(winpath,' / ') do while(idx > 0) winpath(idx:idx) = ' \\ ' idx = index(winpath,' / ') end do end function windows_path function unix_path(path) result(nixpath) ! Replace file system separators for unix ! character(*), intent(in) :: path character(:), allocatable :: nixpath integer :: idx nixpath = path idx = index(nixpath,' \\ ') do while(idx > 0) nixpath(idx:idx) = ' / ' idx = index(nixpath,' \\' ) end do end function unix_path end module fpm_filesystem","tags":"","loc":"sourcefile/fpm_filesystem.f90.html"},{"title":"fpm_strings.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_strings Source Code fpm_strings.f90 Source Code module fpm_strings implicit none private public :: f_string , lower , split , str_ends_with , string_t public :: string_array_contains , operator (. in .) type string_t character ( len = :), allocatable :: s end type interface operator (. in .) module procedure string_array_contains end interface contains logical function str_ends_with ( s , e ) result ( r ) character ( * ), intent ( in ) :: s , e integer :: n1 , n2 n1 = len ( s ) - len ( e ) + 1 n2 = len ( s ) if ( n1 < 1 ) then r = . false . else r = ( s ( n1 : n2 ) == e ) end if end function str_ends_with function f_string ( c_string ) use iso_c_binding character ( len = 1 ), intent ( in ) :: c_string (:) character (:), allocatable :: f_string integer :: i , n i = 0 do while ( c_string ( i + 1 ) /= C_NULL_CHAR ) i = i + 1 end do n = i allocate ( character ( n ) :: f_string ) do i = 1 , n f_string ( i : i ) = c_string ( i ) end do end function f_string elemental pure function lower ( str , begin , end ) result ( string ) ! Changes a string to lowercase over specified range ! Author: John S. Urban ! License: Public Domain character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower logical function string_array_contains ( search_string , array ) ! Check if array of string_t contains a particular string ! character ( * ), intent ( in ) :: search_string type ( string_t ), intent ( in ) :: array (:) integer :: i string_array_contains = any ([( array ( i )% s == search_string , & i = 1 , size ( array ))]) end function string_array_contains subroutine split ( input_line , array , delimiters , order , nulls ) ! parse string on delimiter characters and store tokens into an allocatable array\" ! Author: John S. Urban ! License: Public Domain !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found select case ( ilen ) case (: 0 ) ! command was totally blank case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE end select select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split end module fpm_strings","tags":"","loc":"sourcefile/fpm_strings.f90.html"},{"title":"fpm_sources.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_sources Source Code fpm_sources.f90 Source Code module fpm_sources use fpm_error , only : error_t , file_parse_error , fatal_error use fpm_model , only : srcfile_t , fpm_model_t , & FPM_UNIT_UNKNOWN , FPM_UNIT_PROGRAM , FPM_UNIT_MODULE , & FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , & FPM_UNIT_CSOURCE , FPM_UNIT_CHEADER , FPM_SCOPE_UNKNOWN , & FPM_SCOPE_LIB , FPM_SCOPE_DEP , FPM_SCOPE_APP , FPM_SCOPE_TEST use fpm_filesystem , only : basename , canon_path , dirname , join_path , read_lines , list_files use fpm_strings , only : lower , split , str_ends_with , string_t , operator (. in .) use fpm_manifest_executable , only : executable_config_t implicit none private public :: add_sources_from_dir , add_executable_sources public :: parse_f_source , parse_c_source character ( 15 ), parameter :: INTRINSIC_MODULE_NAMES ( * ) = & [ 'iso_c_binding  ' , & 'iso_fortran_env' , & 'ieee_arithmetic' , & 'ieee_exceptions' , & 'ieee_features  ' ] contains function parse_source ( source_file_path , error ) result ( source ) character ( * ), intent ( in ) :: source_file_path type ( error_t ), allocatable , intent ( out ) :: error type ( srcfile_t ) :: source if ( str_ends_with ( lower ( source_file_path ), \".f90\" )) then source = parse_f_source ( source_file_path , error ) if ( source % unit_type == FPM_UNIT_PROGRAM ) then source % exe_name = basename ( source_file_path , suffix = . false .) end if else if ( str_ends_with ( lower ( source_file_path ), \".c\" ) . or . & str_ends_with ( lower ( source_file_path ), \".h\" )) then source = parse_c_source ( source_file_path , error ) end if if ( allocated ( error )) then return end if end function parse_source subroutine add_sources_from_dir ( sources , directory , scope , with_executables , recurse , error ) ! Enumerate sources in a directory ! type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) character ( * ), intent ( in ) :: directory integer , intent ( in ) :: scope logical , intent ( in ), optional :: with_executables logical , intent ( in ), optional :: recurse type ( error_t ), allocatable , intent ( out ) :: error integer :: i logical , allocatable :: is_source (:), exclude_source (:) type ( string_t ), allocatable :: file_names (:) type ( string_t ), allocatable :: src_file_names (:) type ( string_t ), allocatable :: existing_src_files (:) type ( srcfile_t ), allocatable :: dir_sources (:) ! Scan directory for sources call list_files ( directory , file_names , recurse = merge ( recurse ,. true ., present ( recurse ))) if ( allocated ( sources )) then allocate ( existing_src_files ( size ( sources ))) do i = 1 , size ( sources ) existing_src_files ( i )% s = canon_path ( sources ( i )% file_name ) end do else allocate ( existing_src_files ( 0 )) end if is_source = [(. not .( canon_path ( file_names ( i )% s ) . in . existing_src_files ) . and . & ( str_ends_with ( lower ( file_names ( i )% s ), \".f90\" ) . or . & str_ends_with ( lower ( file_names ( i )% s ), \".c\" ) . or . & str_ends_with ( lower ( file_names ( i )% s ), \".h\" ) ), i = 1 , size ( file_names ))] src_file_names = pack ( file_names , is_source ) allocate ( dir_sources ( size ( src_file_names ))) allocate ( exclude_source ( size ( src_file_names ))) do i = 1 , size ( src_file_names ) dir_sources ( i ) = parse_source ( src_file_names ( i )% s , error ) if ( allocated ( error )) return dir_sources ( i )% unit_scope = scope ! Exclude executables unless specified otherwise exclude_source ( i ) = ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM ) if ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM . and . & & present ( with_executables )) then if ( with_executables ) then exclude_source ( i ) = . false . end if end if end do if (. not . allocated ( sources )) then sources = pack ( dir_sources ,. not . exclude_source ) else sources = [ sources , pack ( dir_sources ,. not . exclude_source )] end if end subroutine add_sources_from_dir subroutine add_executable_sources ( sources , executables , scope , auto_discover , error ) ! Include sources from any directories specified !  in [[executable]] entries and apply any customisations ! type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) class ( executable_config_t ), intent ( in ) :: executables (:) integer , intent ( in ) :: scope logical , intent ( in ) :: auto_discover type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j type ( string_t ), allocatable :: exe_dirs (:) type ( srcfile_t ) :: exe_source call get_executable_source_dirs ( exe_dirs , executables ) do i = 1 , size ( exe_dirs ) call add_sources_from_dir ( sources , exe_dirs ( i )% s , scope , & with_executables = auto_discover , recurse = . false ., error = error ) if ( allocated ( error )) then return end if end do exe_loop : do i = 1 , size ( executables ) ! Check if executable already discovered automatically !  and apply any overrides do j = 1 , size ( sources ) if ( basename ( sources ( j )% file_name , suffix = . true .) == executables ( i )% main . and .& canon_path ( dirname ( sources ( j )% file_name )) == & canon_path ( executables ( i )% source_dir ) ) then sources ( j )% exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if cycle exe_loop end if end do ! Add if not already discovered (auto_discovery off) exe_source = parse_source ( join_path ( executables ( i )% source_dir , executables ( i )% main ), error ) exe_source % exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if exe_source % unit_scope = scope if ( allocated ( error )) return if (. not . allocated ( sources )) then sources = [ exe_source ] else sources = [ sources , exe_source ] end if end do exe_loop end subroutine add_executable_sources subroutine get_executable_source_dirs ( exe_dirs , executables ) ! Build a list of unique source directories !  from executables specified in manifest type ( string_t ), allocatable , intent ( inout ) :: exe_dirs (:) class ( executable_config_t ), intent ( in ) :: executables (:) type ( string_t ) :: dirs_temp ( size ( executables )) integer :: i , n n = 0 do i = 1 , size ( executables ) if (. not .( executables ( i )% source_dir . in . dirs_temp )) then n = n + 1 dirs_temp ( n )% s = executables ( i )% source_dir end if end do if (. not . allocated ( exe_dirs )) then exe_dirs = dirs_temp ( 1 : n ) else exe_dirs = [ exe_dirs , dirs_temp ( 1 : n )] end if end subroutine get_executable_source_dirs function parse_f_source ( f_filename , error ) result ( f_source ) ! Rudimentary scan of Fortran source file and !  extract program unit name and use/include dependencies ! character ( * ), intent ( in ) :: f_filename type ( srcfile_t ) :: f_source type ( error_t ), allocatable , intent ( out ) :: error integer :: stat integer :: fh , n_use , n_include , n_mod , i , j , ic , pass type ( string_t ), allocatable :: file_lines (:) character (:), allocatable :: temp_string , mod_name f_source % file_name = f_filename open ( newunit = fh , file = f_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) do pass = 1 , 2 n_use = 0 n_include = 0 n_mod = 0 file_loop : do i = 1 , size ( file_lines ) ! Skip lines that are continued: not statements if ( i > 1 ) then ic = index ( file_lines ( i - 1 )% s , '!' ) if ( ic < 1 ) then ic = len ( file_lines ( i - 1 )% s ) end if temp_string = trim ( file_lines ( i - 1 )% s ( 1 : ic )) if ( len ( temp_string ) > 0 . and . index ( temp_string , '&' ) == len ( temp_string )) then cycle end if end if ! Process 'USE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'use ' ) == 1 . or . & index ( adjustl ( lower ( file_lines ( i )% s )), 'use::' ) == 1 ) then if ( index ( file_lines ( i )% s , '::' ) > 0 ) then temp_string = split_n ( file_lines ( i )% s , delims = ':' , n = 2 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '::' )) return end if mod_name = split_n ( temp_string , delims = ' ,' , n = 1 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) else mod_name = split_n ( file_lines ( i )% s , n = 2 , delims = ' ,' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) end if if (. not . validate_name ( mod_name )) then cycle end if if ( any ([( index ( mod_name , trim ( INTRINSIC_MODULE_NAMES ( j ))) > 0 , & j = 1 , size ( INTRINSIC_MODULE_NAMES ))])) then cycle end if n_use = n_use + 1 if ( pass == 2 ) then f_source % modules_used ( n_use )% s = mod_name end if end if ! Process 'INCLUDE' statements ic = index ( adjustl ( lower ( file_lines ( i )% s )), 'include' ) if ( ic == 1 ) then ic = index ( lower ( file_lines ( i )% s ), 'include' ) if ( index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), '\"' ) == 1 . or . & index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), \"'\" ) == 1 ) then n_include = n_include + 1 if ( pass == 2 ) then f_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = \"'\" // '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find include file name' , i , & file_lines ( i )% s ) return end if end if end if end if ! Extract name of module if is module if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'module ' ) == 1 ) then mod_name = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find module name' , i , & file_lines ( i )% s ) return end if if ( mod_name == 'procedure' . or . & mod_name == 'subroutine' . or . & mod_name == 'function' ) then ! Ignore these cases cycle end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for module' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 if ( pass == 2 ) then f_source % modules_provided ( n_mod ) = string_t ( mod_name ) end if f_source % unit_type = FPM_UNIT_MODULE end if ! Extract name of submodule if is submodule if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'submodule' ) == 1 ) then mod_name = split_n ( file_lines ( i )% s , n = 3 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule name' , i , & file_lines ( i )% s ) return end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 temp_string = split_n ( file_lines ( i )% s , n = 2 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule ancestry' , i , & file_lines ( i )% s ) return end if f_source % unit_type = FPM_UNIT_SUBMODULE n_use = n_use + 1 if ( pass == 2 ) then if ( index ( temp_string , ':' ) > 0 ) then temp_string = temp_string ( index ( temp_string , ':' ) + 1 :) end if if (. not . validate_name ( temp_string )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule parent' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , temp_string )) return end if f_source % modules_used ( n_use )% s = lower ( temp_string ) f_source % modules_provided ( n_mod )% s = lower ( mod_name ) end if end if ! Detect if contains a program !  (no modules allowed after program def) if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'program' ) == 1 ) then f_source % unit_type = FPM_UNIT_PROGRAM end if end do file_loop ! Default to subprogram unit type if ( f_source % unit_type == FPM_UNIT_UNKNOWN ) then f_source % unit_type = FPM_UNIT_SUBPROGRAM end if if ( pass == 1 ) then allocate ( f_source % modules_used ( n_use )) allocate ( f_source % include_dependencies ( n_include )) allocate ( f_source % modules_provided ( n_mod )) end if end do contains function validate_name ( name ) result ( valid ) character ( * ), intent ( in ) :: name logical :: valid integer :: i if ( len_trim ( name ) < 1 ) then valid = . false . return end if if ( lower ( name ( 1 : 1 )) < 'a' . or . & lower ( name ( 1 : 1 )) > 'z' ) then valid = . false . return end if do i = 1 , len ( name ) if (. not .( & ( name ( i : i ) >= '0' . and . name ( i : i ) <= '9' ). or . & ( lower ( name ( i : i )) >= 'a' . and . lower ( name ( i : i )) <= 'z' ). or . & name ( i : i ) == '_' ) ) then valid = . false . return end if end do valid = . true . return end function validate_name end function parse_f_source function parse_c_source ( c_filename , error ) result ( c_source ) ! Rudimentary scan of c source file and !  extract include dependencies ! character ( * ), intent ( in ) :: c_filename type ( srcfile_t ) :: c_source type ( error_t ), allocatable , intent ( out ) :: error integer :: fh , n_include , i , pass , stat type ( string_t ), allocatable :: file_lines (:) c_source % file_name = c_filename if ( str_ends_with ( lower ( c_filename ), \".c\" )) then c_source % unit_type = FPM_UNIT_CSOURCE elseif ( str_ends_with ( lower ( c_filename ), \".h\" )) then c_source % unit_type = FPM_UNIT_CHEADER end if allocate ( c_source % modules_used ( 0 )) allocate ( c_source % modules_provided ( 0 )) open ( newunit = fh , file = c_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) do pass = 1 , 2 n_include = 0 file_loop : do i = 1 , size ( file_lines ) ! Process 'INCLUDE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), '#include' ) == 1 . and . & index ( file_lines ( i )% s , '\"' ) > 0 ) then n_include = n_include + 1 if ( pass == 2 ) then c_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , c_filename , & 'unable to get c include file' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '\"' )) return end if end if end if end do file_loop if ( pass == 1 ) then allocate ( c_source % include_dependencies ( n_include )) end if end do end function parse_c_source function split_n ( string , delims , n , stat ) result ( substring ) ! Split a string on one or more delimeters !  and return the nth substring if it exists ! ! n=0  will return the last item ! n=-1 will return the penultimate item etc. ! ! stat = 1 on return if the index !  is not found ! character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: delims integer , intent ( in ) :: n integer , intent ( out ) :: stat character (:), allocatable :: substring integer :: i character (:), allocatable :: string_parts (:) call split ( string , string_parts , delims ) if ( n < 1 ) then i = size ( string_parts ) + n if ( i < 1 ) then stat = 1 return end if else i = n end if if ( i > size ( string_parts )) then stat = 1 return end if substring = trim ( adjustl ( string_parts ( i ))) stat = 0 end function split_n end module fpm_sources","tags":"","loc":"sourcefile/fpm_sources.f90.html"},{"title":"fpm_command_line.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_command_line Source Code fpm_command_line.f90 Source Code module fpm_command_line use fpm_environment , only : get_os_type , & OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_WINDOWS , & OS_CYGWIN , OS_SOLARIS , OS_FREEBSD use M_CLI2 , only : set_args , lget , unnamed , remaining , specified use fpm_strings , only : lower use fpm_filesystem , only : basename , canon_path use , intrinsic :: iso_fortran_env , only : stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none private public :: fpm_cmd_settings , & fpm_build_settings , & fpm_install_settings , & fpm_new_settings , & fpm_run_settings , & fpm_test_settings , & get_command_line_settings type , abstract :: fpm_cmd_settings end type integer , parameter :: ibug = 4096 type , extends ( fpm_cmd_settings ) :: fpm_new_settings character ( len = :), allocatable :: name logical :: with_executable = . false . logical :: with_test = . false . logical :: with_lib = . true . logical :: backfill = . true . end type type , extends ( fpm_cmd_settings ) :: fpm_build_settings logical :: release = . false . logical :: list = . false . end type type , extends ( fpm_build_settings ) :: fpm_run_settings character ( len = ibug ), allocatable :: name (:) character ( len = :), allocatable :: args end type type , extends ( fpm_run_settings ) :: fpm_test_settings end type type , extends ( fpm_cmd_settings ) :: fpm_install_settings end type character ( len = :), allocatable :: name character ( len = :), allocatable :: os_type character ( len = ibug ), allocatable :: names (:) character ( len = :), allocatable :: version_text (:) character ( len = :), allocatable :: help_new (:), help_fpm (:), help_run (:), & & help_test (:), help_build (:), help_usage (:), & & help_text (:), help_install (:), help_help (:), & & help_list (:), help_list_dash (:), help_list_nodash (:) contains subroutine get_command_line_settings ( cmd_settings ) class ( fpm_cmd_settings ), allocatable , intent ( out ) :: cmd_settings character ( len = 4096 ) :: cmdarg integer :: i integer :: widest call set_help () ! text for --version switch, select case ( get_os_type ()) case ( OS_LINUX ); os_type = \"OS Type:     Linux\" case ( OS_MACOS ); os_type = \"OS Type:     macOS\" case ( OS_WINDOWS ); os_type = \"OS Type:     Windows\" case ( OS_CYGWIN ); os_type = \"OS Type:     Cygwin\" case ( OS_SOLARIS ); os_type = \"OS Type:     Solaris\" case ( OS_FREEBSD ); os_type = \"OS Type:     FreeBSD\" case ( OS_UNKNOWN ); os_type = \"OS Type:     Unknown\" case default ; os_type = \"OS Type:     UNKNOWN\" end select version_text = [ character ( len = 80 ) :: & & 'Version:     0.1.0, Pre-alpha' , & & 'Program:     fpm(1)' , & & 'Description: A Fortran package manager and build system' , & & 'Home Page:   https://github.com/fortran-lang/fpm' , & & 'License:     MIT' , & & os_type ] ! find the subcommand name by looking for first word on command ! not starting with dash cmdarg = '' do i = 1 , command_argument_count () call get_command_argument ( i , cmdarg ) if ( adjustl ( cmdarg ( 1 : 1 )) . ne . '-' ) exit enddo ! now set subcommand-specific help text and process commandline ! arguments. Then call subcommand routine select case ( trim ( cmdarg )) case ( 'run' ) call set_args ( '--list F --release F --' , help_run , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_run_settings :: cmd_settings ) cmd_settings = fpm_run_settings ( name = names , list = lget ( 'list' ), & & release = lget ( 'release' ), args = remaining ) case ( 'build' ) call set_args ( '--release F --list F --' , help_build , version_text ) allocate ( fpm_build_settings :: cmd_settings ) cmd_settings = fpm_build_settings ( release = lget ( 'release' ), & & list = lget ( 'list' ) ) case ( 'new' ) call set_args ( ' --src F --lib F --app F --test F --backfill F' , & & help_new , version_text ) select case ( size ( unnamed )) case ( 1 ) write ( stderr , '(*(g0,/))' ) 'ERROR: directory name required' write ( stderr , '(*(7x,g0,/))' ) & & 'USAGE: fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 1 case ( 2 ) name = trim ( unnamed ( 2 )) case default write ( stderr , '(g0)' ) 'ERROR: only one directory name allowed' write ( stderr , '(7x,g0)' ) & & 'USAGE: fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 2 end select !*! canon_path is not converting \".\", etc. name = canon_path ( name ) if ( . not . is_fortran_name ( basename ( name )) ) then write ( stderr , '(g0)' ) [ character ( len = 72 ) :: & & 'ERROR: the new directory basename must be an allowed ' , & & '       Fortran name. It must be composed of 1 to 63 ASCII' , & & '       characters and start with a letter and be composed' , & & '       entirely of alphanumeric characters [a-zA-Z0-9]' , & & '       and underscores.' ] stop 4 endif allocate ( fpm_new_settings :: cmd_settings ) if ( any ( specified ([ 'src ' , 'lib ' , 'app ' , 'test' ]) ) ) then cmd_settings = fpm_new_settings ( name = name , & & with_executable = lget ( 'app' ), & & with_test = lget ( 'test' ), & & with_lib = any ([ lget ( 'lib' ), lget ( 'src' )]), & & backfill = lget ( 'backfill' ) ) else cmd_settings = fpm_new_settings ( name = name , & & with_executable = . true ., & & with_test = . true ., & & with_lib = . true ., & & backfill = lget ( 'backfill' ) ) endif case ( 'help' ) call set_args ( ' ' , help_help , version_text ) if ( size ( unnamed ). lt . 2 ) then unnamed = [ 'help' , 'fpm ' ] endif widest = 256 allocate ( character ( len = widest ) :: help_text ( 0 )) do i = 2 , size ( unnamed ) select case ( unnamed ( i )) case ( 'build  ' ) help_text = [ character ( len = widest ) :: help_text , help_build ] case ( 'run    ' ) help_text = [ character ( len = widest ) :: help_text , help_run ] case ( 'help   ' ) help_text = [ character ( len = widest ) :: help_text , help_help ] case ( 'test   ' ) help_text = [ character ( len = widest ) :: help_text , help_test ] case ( 'new    ' ) help_text = [ character ( len = widest ) :: help_text , help_new ] case ( 'fpm    ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] case ( 'list   ' ) help_text = [ character ( len = widest ) :: help_text , help_list ] case ( 'version' ) help_text = [ character ( len = widest ) :: help_text , version_text ] case ( 'manual ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] help_text = [ character ( len = widest ) :: help_text , help_new ] help_text = [ character ( len = widest ) :: help_text , help_build ] help_text = [ character ( len = widest ) :: help_text , help_run ] help_text = [ character ( len = widest ) :: help_text , help_test ] help_text = [ character ( len = widest ) :: help_text , help_help ] help_text = [ character ( len = widest ) :: help_text , help_list ] help_text = [ character ( len = widest ) :: help_text , version_text ] case default help_text = [ character ( len = widest ) :: help_text , & & 'ERROR: unknown help topic \"' // trim ( unnamed ( i )) // '\"' ] end select enddo call printhelp ( help_text ) case ( 'install' ) call set_args ( '--release F ' , help_install , version_text ) allocate ( fpm_install_settings :: cmd_settings ) case ( 'list' ) call set_args ( ' --list F' , help_list , version_text ) call printhelp ( help_list_nodash ) if ( lget ( 'list' )) then call printhelp ( help_list_dash ) endif case ( 'test' ) call set_args ( '--list F --release F --' , help_test , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_test_settings :: cmd_settings ) cmd_settings = fpm_test_settings ( name = names , list = lget ( 'list' ), & & release = lget ( 'release' ), args = remaining ) case default call set_args ( ' --list F' , help_fpm , version_text ) ! Note: will not get here if --version or --usage or --help ! is present on commandline help_text = help_usage if ( lget ( 'list' )) then help_text = help_list_dash elseif ( len_trim ( cmdarg ). eq . 0 ) then write ( stdout , '(*(a))' ) 'Fortran Package Manager:' write ( stdout , '(*(a))' ) ' ' call printhelp ( help_list_nodash ) else write ( stderr , '(*(a))' ) 'ERROR: unknown subcommand [' , & & trim ( cmdarg ), ']' call printhelp ( help_list_dash ) endif call printhelp ( help_text ) end select contains subroutine printhelp ( lines ) character ( len = :), intent ( in ), allocatable :: lines (:) write ( stdout , '(g0)' )( trim ( lines ( i )), i = 1 , size ( lines ) ) end subroutine printhelp end subroutine get_command_line_settings function is_fortran_name ( line ) result ( lout ) ! determine if a string is a valid Fortran name ignoring trailing spaces ! (but not leading spaces) character ( len =* ), parameter :: int = '0123456789' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: allowed = upper // lower // int // '_' character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: name logical :: lout name = trim ( line ) if ( len ( name ). ne . 0 ) then lout = . true . & & . and . verify ( name ( 1 : 1 ), lower // upper ) == 0 & & . and . verify ( name , allowed ) == 0 & & . and . len ( name ) <= 63 else lout = . false . endif end function is_fortran_name subroutine set_help () help_list_nodash = [ character ( len = 80 ) :: & 'USAGE: fpm [ SUBCOMMAND [SUBCOMMAND_OPTIONS] ]|[--list|--help|--version]' , & '       where SUBCOMMAND is commonly new|build|run|test                  ' , & '                                                                        ' , & ' subcommand may be one of                                               ' , & '                                                                        ' , & '  build     Compile the package placing results in the \"build\" directory' , & '  help      Display help                                                ' , & '  list      Display this list of subcommand descriptions                ' , & '  new       Create a new Fortran package directory with sample files    ' , & '  run       Run the local package application programs                  ' , & '  test      Run the test programs                                       ' , & '                                                                        ' , & ' Enter \"fpm --list\" for a brief list of subcommand options. Enter       ' , & ' \"fpm --help\" or \"fpm SUBCOMMAND --help\" for detailed descriptions.     ' , & ' ' ] help_list_dash = [ character ( len = 80 ) :: & '                                                                       ' , & ' build [--release] [--list]                                             ' , & ' help [NAME(s)]                                                         ' , & ' new NAME [--lib|--src] [--app] [--test] [--backfill]                   ' , & ' list [--list]                                                          ' , & ' run [NAME(s)] [--release] [--list] [-- ARGS]                           ' , & ' test [NAME(s)] [--release] [--list] [-- ARGS]                          ' , & ' ' ] help_usage = [ character ( len = 80 ) :: & '' ] help_fpm = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & '   fpm(1) - A Fortran package manager and build system                 ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & '   fpm SUBCOMMAND [SUBCOMMAND_OPTIONS]                                 ' , & '                                                                       ' , & '   fpm --help|--version|--list                                         ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & '   fpm(1) is a package manager that helps you create Fortran projects  ' , & '   from source.                                                        ' , & '                                                                       ' , & '   Most significantly fpm(1) lets you draw upon other fpm(1) packages  ' , & '   in distributed git(1) repositories as if the packages were a basic  ' , & '   part of your default programming environment, as well as letting    ' , & '   you share your projects with others in a similar manner.            ' , & '                                                                       ' , & '   See the fpm(1) repository at https://fortran-lang.org/packages/fpm  ' , & '   for a listing of registered projects.                               ' , & '                                                                       ' , & '   All output goes into the directory \"build/\" which can generally be  ' , & '   removed and rebuilt if required. Note that if external packages are ' , & '   being used you need network connectivity to rebuild from scratch.   ' , & '                                                                       ' , & 'SUBCOMMANDS                                                            ' , & '  Valid fpm(1) subcommands are:                                        ' , & '                                                                       ' , & '     build [--release] [--list]                                        ' , & '                     Compile the packages into the \"build/\" directory. ' , & '     new NAME [--lib|--src] [--app] [--test] [--backfill]              ' , & '                     Create a new Fortran package directory            ' , & '                     with sample files                                 ' , & '     run [NAME(s)] [--release] [--list] [-- ARGS]                      ' , & '                     Run the local package binaries. defaults to all   ' , & '                     binaries for that release.                        ' , & '     test [NAME(s)] [--release] [--list] [-- ARGS]                     ' , & '                     Run the tests                                     ' , & '     help [NAME(s)]  Alternate method for displaying subcommand help   ' , & '     list [--list]   Display brief descriptions of all subcommands.    ' , & '                                                                       ' , & 'SUBCOMMAND OPTIONS                                                     ' , & '  --release  Builds or runs in release mode (versus debug mode). fpm(1)' , & '             Defaults to using common compiler debug flags and building' , & '             in \"build/*_debug/\". When this flag is present build      ' , & '             output goes into \"build/*_release/\" and common compiler   ' , & '             optimization flags are used.                              ' , & '  --list     List candidates instead of building or running them. On   ' , & '             the fpm(1) command this shows a brief list of subcommands.' , & '  -- ARGS    Arguments to pass to executables.                         ' , & '  --help     Show help text and exit. Valid for all subcommands.       ' , & '  --version  Show version information and exit. Valid for all          ' , & '             subcommands.                                              ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & '   sample commands:                                                    ' , & '                                                                       ' , & '    fpm new mypackage --app --test                                     ' , & '    fpm build                                                          ' , & '    fpm test                                                           ' , & '    fpm run                                                            ' , & '    fpm new --help                                                     ' , & '    fpm run myprogram --release -- -x 10 -y 20 --title \"my title\"      ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & '   The fpm(1) home page at https://github.com/fortran-lang/fpm         ' , & '' ] help_list = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' list(1) - list summary of fpm(1) subcommands                          ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm list [-list]                                                      ' , & '                                                                       ' , & ' fpm list --help|--version                                             ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Display a short description for each fpm(1) subcommand.               ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --list     display a list of command options as well. This is the     ' , & '            same output as generated by \"fpm --list\".                  ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' display a short list of fpm(1) subcommands                            ' , & '                                                                       ' , & '  fpm list                                                             ' , & '  fpm --list                                                           ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm           ' , & '' ] help_run = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' run(1) - the fpm(1) subcommand to run project applications            ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm run [NAME(s)] [--release] [-- ARGS]                               ' , & '                                                                       ' , & ' fpm run --help|--version                                              ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Run applications you have built in your fpm(1) project.               ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' NAME(s)    optional list of specific names to execute.                ' , & '            The default is to run all the applications in app/         ' , & '            or the programs listed in the \"fpm.toml\" file.             ' , & ' --release  selects the optimized build instead of the debug           ' , & '            build.                                                     ' , & ' --list     list candidates instead of building or running them        ' , & ' -- ARGS    optional arguments to pass to the program(s).              ' , & '            The same arguments are passed to all names                 ' , & '            specified.                                                 ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' run fpm(1) project applications                                       ' , & '                                                                       ' , & '  # run default programs in /app or as specified in \"fpm.toml\"         ' , & '  fpm run                                                              ' , & '                                                                       ' , & '  # run a specific program and pass arguments to the command           ' , & '  fpm run mytest -- -x 10 -y 20 --title \"my title line\"                ' , & '                                                                       ' , & '  # run production version of two applications                         ' , & '  fpm run prg1 prg2 --release                                          ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm           ' , & '' ] help_build = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' build(1) - the fpm(1) subcommand to build a project                   ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm build [--release]|[-list]                                         ' , & '                                                                       ' , & ' fpm build --help|--version                                            ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' The \"fpm build\" command                                               ' , & '    o Fetches any dependencies                                         ' , & '    o Scans your sources                                               ' , & '    o Builds them in the proper order                                  ' , & '                                                                       ' , & ' The Fortran source files are assumed by default to be in              ' , & '    o src/     for modules and procedure source                        ' , & '    o app/     main program(s) for applications                        ' , & '    o test/    main program(s) and support files for project tests     ' , & ' Changed or new files found are rebuilt. The results are placed in     ' , & ' the build/ directory.                                                 ' , & '                                                                       ' , & ' Non-default pathnames and remote dependencies are used if             ' , & ' specified in the \"fpm.toml\" file.                                     ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --release  build in build/*_release instead of build/*_debug with     ' , & '            high optimization instead of full debug options.           ' , & ' --list     list candidates instead of building or running them        ' , & ' --help     print this help and exit                                   ' , & ' --version  print program version information and exit                 ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' Sample commands:                                                      ' , & '                                                                       ' , & '  fpm build           # build with debug options                       ' , & '  fpm build --release # build with high optimization                   ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm           ' , & '' ] help_help = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & '   help(1) - the fpm(1) subcommand to display help                     ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & '   fpm help [fpm] [new] [build] [run] [test] [help] [version] [manual] ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & '   The \"fpm help\" command is an alternative to the --help parameter    ' , & '   on the fpm(1) command and its subcommands.                          ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & '   NAME(s)    A list of topic names to display. All the subcommands    ' , & '              have their own page (new, build, run, test, ...).        ' , & '                                                                       ' , & '              The special name \"manual\" displays all the fpm(1)        ' , & '              built-in documentation.                                  ' , & '                                                                       ' , & '              The default is to display help for the fpm(1) command    ' , & '              itself.                                                  ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & '   Sample usage:                                                       ' , & '                                                                       ' , & '     fpm help           # general fpm(1) command help                  ' , & '     fpm help version   # show program version                         ' , & '     fpm help new       # display help for \"new\" subcommand            ' , & '     fpm help manual    # All fpm(1) built-in documentation            ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & '   The fpm(1) home page at https://github.com/fortran-lang/fpm         ' , & '' ] help_new = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' new(1) - the fpm(1) subcommand to initialize a new project            ' , & 'SYNOPSIS                                                               ' , & ' fpm new NAME [--lib|--src] [--app] [--test] [--backfill]              ' , & '                                                                       ' , & ' fpm new --help|--version                                              ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' \"fpm new\" creates and populates a new programming project directory.  ' , & ' It                                                                    ' , & '   o creates a directory with the specified name                       ' , & '   o runs the command \"git init\" in that directory                     ' , & '   o populates the directory with the default project directories      ' , & '   o adds sample Fortran source files                                  ' , & '   o adds a \".gitignore\" file for ignoring the build/ directory        ' , & '     (where fpm-generated output will be placed)                       ' , & '                                                                       ' , & ' The basic default file structure is                                   ' , & '                                                                       ' , & '     NAME/                                                             ' , & '       fpm.toml                                                        ' , & '       .gitignore                                                      ' , & '       src/                                                            ' , & '           NAME.f90                                                    ' , & '       app/                                                            ' , & '           main.f90                                                    ' , & '       test/                                                           ' , & '           main.f90                                                    ' , & '                                                                       ' , & ' Remember to update the information in the sample \"fpm.toml\"           ' , & ' file with your name and e-mail address.                               ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' NAME   the name of the project directory to create. The name          ' , & '        must be a valid Fortran name composed of 1 to 63               ' , & '        ASCII alphanumeric characters and underscores,                 ' , & '        starting with a letter.                                        ' , & '                                                                       ' , & ' The default is to create all of the src/, app/, and test/             ' , & ' directories. If any of the following options are specified            ' , & ' then only selected subdirectories are generated:                      ' , & '                                                                       ' , & ' --lib,--src  create directory src/ and a placeholder module           ' , & '              named \"NAME.f90\" for use with subcommand \"build\".        ' , & ' --app        create directory app/ and a placeholder main             ' , & '              program for use with subcommand \"run\".                   ' , & ' --test       create directory test/ and a placeholder program         ' , & '              for use with the subcommand \"test\". Note that sans       ' , & '              \"--lib\" it really does not have anything to test.        ' , & '                                                                       ' , & ' So the default is equivalent to \"fpm NAME --lib --app --test\".        ' , & '                                                                       ' , & ' --backfill   By default the directory must not exist. If this         ' , & '              option is present the directory may pre-exist and        ' , & '              only subdirectories and files that do not                ' , & '              already exist will be created. For example, if you       ' , & '              previously entered \"fpm new myname --lib\" entering       ' , & '              \"fpm new myname --backfill\" will create the missing      ' , & '              app/ and test/ directories and programs.                 ' , & '                                                                       ' , & ' --help       print this help and exit                                 ' , & ' --version    print program version information and exit               ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' Sample use                                                            ' , & '                                                                       ' , & '   fpm new myproject  # create new project directory and seed it       ' , & '   cd myproject       # Enter the new directory                        ' , & '   # and run commands such as                                          ' , & '   fpm build                                                           ' , & '   fpm run            # run example application program                ' , & '   fpm test           # run example test program                       ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm           ' , & '                                                                       ' , & ' Registered packages are at https://fortran-lang.org/packages          ' , & '' ] help_test = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' test(1) - the fpm(1) subcommand to run project tests                  ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm test [NAME(s)] [--release] [--list] [-- ARGS]                     ' , & '                                                                       ' , & ' fpm test --help|--version                                             ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Run applications you have built to test your project.                 ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' NAME(s)    optional list of specific test names to execute.           ' , & '            The default is to run all the tests in test/               ' , & '            or the tests listed in the \"fpm.toml\" file.                ' , & ' --release  selects the optimized build instead of the debug           ' , & '            build.                                                     ' , & ' --list     list candidates instead of building or running them        ' , & ' -- ARGS    optional arguments to pass to the test program(s).         ' , & '            The same arguments are passed to all test names            ' , & '            specified.                                                 ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & 'run tests                                                              ' , & '                                                                       ' , & ' # run default tests in /test or as specified in \"fpm.toml\"            ' , & ' fpm test                                                              ' , & '                                                                       ' , & ' # run a specific test and pass arguments to the command               ' , & ' fpm test mytest -- -x 10 -y 20 --title \"my title line\"                ' , & '                                                                       ' , & ' fpm test tst1 tst2 --release # production version of two tests        ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm           ' , & '' ] help_install = [ character ( len = 80 ) :: & ' fpm(1) subcommand \"install\"                                           ' , & '                                                                       ' , & ' USAGE: fpm install NAME                                               ' , & '' ] end subroutine set_help end module fpm_command_line","tags":"","loc":"sourcefile/fpm_command_line.f90.html"},{"title":"fpm_backend.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_backend Source Code fpm_backend.f90 Source Code module fpm_backend ! Implements the native fpm build backend use fpm_environment , only : run , get_os_type , OS_WINDOWS use fpm_filesystem , only : basename , dirname , join_path , exists , mkdir use fpm_model , only : fpm_model_t , srcfile_t , build_target_t , FPM_UNIT_MODULE , & FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , & FPM_UNIT_CSOURCE , FPM_UNIT_PROGRAM , & FPM_SCOPE_TEST , FPM_TARGET_OBJECT , FPM_TARGET_ARCHIVE , FPM_TARGET_EXECUTABLE use fpm_strings , only : split implicit none private public :: build_package contains subroutine build_package ( model ) type ( fpm_model_t ), intent ( inout ) :: model integer :: i , ilib character (:), allocatable :: base , linking , subdir , link_flags if (. not . exists ( model % output_directory )) then call mkdir ( model % output_directory ) end if if (. not . exists ( join_path ( model % output_directory , model % package_name ))) then call mkdir ( join_path ( model % output_directory , model % package_name )) end if if ( model % targets ( 1 )% ptr % target_type == FPM_TARGET_ARCHIVE ) then linking = \" \" // model % targets ( 1 )% ptr % output_file else linking = \" \" end if linking = linking // \" \" // model % link_flags do i = 1 , size ( model % targets ) call build_target ( model , model % targets ( i )% ptr , linking ) end do end subroutine build_package recursive subroutine build_target ( model , target , linking ) ! Compile Fortran source, called recursively on it dependents ! type ( fpm_model_t ), intent ( in ) :: model type ( build_target_t ), intent ( inout ) :: target character (:), allocatable , intent ( in ) :: linking integer :: i , j , ilib type ( build_target_t ), pointer :: exe_obj character (:), allocatable :: objs , link_flags if ( target % built ) then return end if if ( target % touched ) then write ( * , * ) '(!) Circular dependency found with: ' , target % output_file stop else target % touched = . true . end if objs = \" \" do i = 1 , size ( target % dependencies ) if ( associated ( target % dependencies ( i )% ptr )) then call build_target ( model , target % dependencies ( i )% ptr , linking ) end if if ( target % target_type == FPM_TARGET_ARCHIVE ) then ! Construct object list for archive objs = objs // \" \" // target % dependencies ( i )% ptr % output_file else if ( target % target_type == FPM_TARGET_EXECUTABLE . and . & target % dependencies ( i )% ptr % target_type == FPM_TARGET_OBJECT ) then exe_obj => target % dependencies ( i )% ptr ! Construct object list for executable objs = \" \" // exe_obj % output_file ! Include non-library object dependencies do j = 1 , size ( exe_obj % dependencies ) if ( allocated ( exe_obj % dependencies ( j )% ptr % source )) then if ( exe_obj % dependencies ( j )% ptr % source % unit_scope == exe_obj % source % unit_scope ) then objs = objs // \" \" // exe_obj % dependencies ( j )% ptr % output_file end if end if end do end if end do if (. not . exists ( dirname ( target % output_file ))) then call mkdir ( dirname ( target % output_file )) end if select case ( target % target_type ) case ( FPM_TARGET_OBJECT ) call run ( \"gfortran -c \" // target % source % file_name // model % fortran_compile_flags & // \" -o \" // target % output_file ) case ( FPM_TARGET_EXECUTABLE ) link_flags = linking if ( allocated ( target % link_libraries )) then do ilib = 1 , size ( target % link_libraries ) link_flags = link_flags // \" -l\" // target % link_libraries ( ilib )% s end do end if call run ( \"gfortran \" // objs // model % fortran_compile_flags & // link_flags // \" -o \" // target % output_file ) case ( FPM_TARGET_ARCHIVE ) call run ( \"ar -rs \" // target % output_file // objs ) end select target % built = . true . end subroutine build_target end module fpm_backend","tags":"","loc":"sourcefile/fpm_backend.f90.html"},{"title":"fpm_environment.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_environment Source Code fpm_environment.f90 Source Code module fpm_environment implicit none private public :: get_os_type public :: run integer , parameter , public :: OS_UNKNOWN = 0 integer , parameter , public :: OS_LINUX = 1 integer , parameter , public :: OS_MACOS = 2 integer , parameter , public :: OS_WINDOWS = 3 integer , parameter , public :: OS_CYGWIN = 4 integer , parameter , public :: OS_SOLARIS = 5 integer , parameter , public :: OS_FREEBSD = 6 contains integer function get_os_type () result ( r ) !! Determine the OS type !! !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN, !! OS_SOLARIS, OS_FREEBSD. !! !! At first, the environment variable `OS` is checked, which is usually !! found on Windows. Then, `OSTYPE` is read in and compared with common !! names. If this fails too, check the existence of files that can be !! found on specific system types only. !! !! Returns OS_UNKNOWN if the operating system cannot be determined. character ( len = 32 ) :: val integer :: length , rc logical :: file_exists r = OS_UNKNOWN ! Check environment variable `OS`. call get_environment_variable ( 'OS' , val , length , rc ) if ( rc == 0 . and . length > 0 . and . index ( val , 'Windows_NT' ) > 0 ) then r = OS_WINDOWS return end if ! Check environment variable `OSTYPE`. call get_environment_variable ( 'OSTYPE' , val , length , rc ) if ( rc == 0 . and . length > 0 ) then ! Linux if ( index ( val , 'linux' ) > 0 ) then r = OS_LINUX return end if ! macOS if ( index ( val , 'darwin' ) > 0 ) then r = OS_MACOS return end if ! Windows, MSYS, MinGW, Git Bash if ( index ( val , 'win' ) > 0 . or . index ( val , 'msys' ) > 0 ) then r = OS_WINDOWS return end if ! Cygwin if ( index ( val , 'cygwin' ) > 0 ) then r = OS_CYGWIN return end if ! Solaris, OpenIndiana, ... if ( index ( val , 'SunOS' ) > 0 . or . index ( val , 'solaris' ) > 0 ) then r = OS_SOLARIS return end if ! FreeBSD if ( index ( val , 'FreeBSD' ) > 0 . or . index ( val , 'freebsd' ) > 0 ) then r = OS_FREEBSD return end if end if ! Linux inquire ( file = '/etc/os-release' , exist = file_exists ) if ( file_exists ) then r = OS_LINUX return end if ! macOS inquire ( file = '/usr/bin/sw_vers' , exist = file_exists ) if ( file_exists ) then r = OS_MACOS return end if ! FreeBSD inquire ( file = '/bin/freebsd-version' , exist = file_exists ) if ( file_exists ) then r = OS_FREEBSD return end if end function get_os_type subroutine run ( cmd ) character ( len =* ), intent ( in ) :: cmd integer :: stat print * , '+ ' , cmd call execute_command_line ( cmd , exitstat = stat ) if ( stat /= 0 ) then print * , 'Command failed' error stop end if end subroutine run end module fpm_environment","tags":"","loc":"sourcefile/fpm_environment.f90.html"},{"title":"fpm_model.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_model Source Code fpm_model.f90 Source Code module fpm_model ! Definition and validation of the backend model use fpm_strings , only : string_t implicit none private public :: fpm_model_t , srcfile_t , build_target_t , build_target_ptr public :: FPM_UNIT_UNKNOWN , FPM_UNIT_PROGRAM , FPM_UNIT_MODULE , & FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE , & FPM_UNIT_CHEADER , FPM_SCOPE_UNKNOWN , FPM_SCOPE_LIB , & FPM_SCOPE_DEP , FPM_SCOPE_APP , FPM_SCOPE_TEST , & FPM_TARGET_UNKNOWN , FPM_TARGET_EXECUTABLE , FPM_TARGET_ARCHIVE , & FPM_TARGET_OBJECT integer , parameter :: FPM_UNIT_UNKNOWN = - 1 integer , parameter :: FPM_UNIT_PROGRAM = 1 integer , parameter :: FPM_UNIT_MODULE = 2 integer , parameter :: FPM_UNIT_SUBMODULE = 3 integer , parameter :: FPM_UNIT_SUBPROGRAM = 4 integer , parameter :: FPM_UNIT_CSOURCE = 5 integer , parameter :: FPM_UNIT_CHEADER = 6 integer , parameter :: FPM_SCOPE_UNKNOWN = - 1 integer , parameter :: FPM_SCOPE_LIB = 1 integer , parameter :: FPM_SCOPE_DEP = 2 integer , parameter :: FPM_SCOPE_APP = 3 integer , parameter :: FPM_SCOPE_TEST = 4 integer , parameter :: FPM_TARGET_UNKNOWN = - 1 integer , parameter :: FPM_TARGET_EXECUTABLE = 1 integer , parameter :: FPM_TARGET_ARCHIVE = 2 integer , parameter :: FPM_TARGET_OBJECT = 3 type srcfile_t ! Type for encapsulating a source file !  and it's metadata character (:), allocatable :: file_name ! File path relative to cwd character (:), allocatable :: exe_name ! Name of executable for FPM_UNIT_PROGRAM integer :: unit_scope = FPM_SCOPE_UNKNOWN ! app/test/lib/dependency logical :: is_test = . false . ! Is executable a test? type ( string_t ), allocatable :: modules_provided (:) ! Modules provided by this source file (lowerstring) integer :: unit_type = FPM_UNIT_UNKNOWN ! Type of program unit type ( string_t ), allocatable :: modules_used (:) ! Modules USEd by this source file (lowerstring) type ( string_t ), allocatable :: include_dependencies (:) ! Files INCLUDEd by this source file type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against end type srcfile_t type build_target_ptr ! For constructing arrays of build_target_t pointers type ( build_target_t ), pointer :: ptr => null () end type build_target_ptr type build_target_t character (:), allocatable :: output_file ! File path of build target object relative to cwd type ( srcfile_t ), allocatable :: source ! Primary source for this build target type ( build_target_ptr ), allocatable :: dependencies (:) ! Resolved build dependencies integer :: target_type = FPM_TARGET_UNKNOWN type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against logical :: built = . false . logical :: touched = . false . end type build_target_t type :: fpm_model_t character (:), allocatable :: package_name ! Name of package type ( srcfile_t ), allocatable :: sources (:) ! Array of sources type ( build_target_ptr ), allocatable :: targets (:) ! Array of targets with module-dependencies resolved character (:), allocatable :: fortran_compiler ! Command line name to invoke fortran compiler character (:), allocatable :: fortran_compile_flags ! Command line flags passed to fortran for compilation character (:), allocatable :: link_flags ! Command line flags pass for linking character (:), allocatable :: output_directory ! Base directory for build type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against end type fpm_model_t end module fpm_model","tags":"","loc":"sourcefile/fpm_model.f90.html"},{"title":"fpm_targets.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_targets Source Code fpm_targets.f90 Source Code module fpm_targets use fpm_error , only : error_t , fatal_error use fpm_model use fpm_environment , only : get_os_type , OS_WINDOWS use fpm_filesystem , only : dirname , join_path , canon_path use fpm_strings , only : string_t , operator (. in .) implicit none contains subroutine targets_from_sources ( model , sources ) type ( fpm_model_t ), intent ( inout ), target :: model type ( srcfile_t ), intent ( in ) :: sources (:) integer :: i type ( build_target_t ), pointer :: dep logical :: with_lib with_lib = any ([( sources ( i )% unit_scope == FPM_SCOPE_LIB , i = 1 , size ( sources ))]) if ( with_lib ) call add_target ( model % targets , type = FPM_TARGET_ARCHIVE ,& output_file = join_path ( model % output_directory ,& model % package_name , 'lib' // model % package_name // '.a' )) do i = 1 , size ( sources ) select case ( sources ( i )% unit_type ) case ( FPM_UNIT_MODULE , FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE ) call add_target ( model % targets , source = sources ( i ), & type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i ))) if ( with_lib . and . sources ( i )% unit_scope == FPM_SCOPE_LIB ) then ! Archive depends on object call add_dependency ( model % targets ( 1 )% ptr , model % targets ( size ( model % targets ))% ptr ) end if case ( FPM_UNIT_PROGRAM ) call add_target ( model % targets , type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i )), & source = sources ( i ) & ) if ( sources ( i )% unit_scope == FPM_SCOPE_APP ) then call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , 'app' , sources ( i )% exe_name )) else call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , 'test' , sources ( i )% exe_name )) end if ! Executable depends on object call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( size ( model % targets ) - 1 )% ptr ) if ( with_lib ) then ! Executable depends on library call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( 1 )% ptr ) end if end select end do contains function get_object_name ( source ) result ( object_file ) ! Generate object target path from source name and model params ! ! type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: object_file integer :: i character ( 1 ), parameter :: filesep = '/' character (:), allocatable :: dir object_file = canon_path ( source % file_name ) ! Ignore first directory level object_file = object_file ( index ( object_file , filesep ) + 1 :) ! Convert any remaining directory separators to underscores i = index ( object_file , filesep ) do while ( i > 0 ) object_file ( i : i ) = '_' i = index ( object_file , filesep ) end do select case ( source % unit_scope ) case ( FPM_SCOPE_APP ) object_file = join_path ( model % output_directory , 'app' , object_file ) // '.o' case ( FPM_SCOPE_TEST ) object_file = join_path ( model % output_directory , 'test' , object_file ) // '.o' case default object_file = join_path ( model % output_directory , model % package_name , object_file ) // '.o' end select end function get_object_name end subroutine targets_from_sources !> Add new target to target list subroutine add_target ( targets , type , output_file , source , link_libraries ) type ( build_target_ptr ), allocatable , intent ( inout ) :: targets (:) integer , intent ( in ) :: type character ( * ), intent ( in ) :: output_file type ( srcfile_t ), intent ( in ), optional :: source type ( string_t ), intent ( in ), optional :: link_libraries (:) integer :: i type ( build_target_ptr ), allocatable :: temp (:) type ( build_target_t ), pointer :: new_target if (. not . allocated ( targets )) allocate ( targets ( 0 )) ! Check for duplicate outputs do i = 1 , size ( targets ) if ( targets ( i )% ptr % output_file == output_file ) then write ( * , * ) 'Error while building target list: duplicate output object \"' ,& output_file , '\"' if ( present ( source )) write ( * , * ) ' Source file: \"' , source % file_name , '\"' stop 1 end if end do allocate ( new_target ) new_target % target_type = type new_target % output_file = output_file if ( present ( source )) new_target % source = source if ( present ( link_libraries )) new_target % link_libraries = link_libraries allocate ( new_target % dependencies ( 0 )) targets = [ targets , build_target_ptr ( new_target )] end subroutine add_target !> Add pointer to dependeny in target%dependencies subroutine add_dependency ( target , dependency ) type ( build_target_t ), intent ( inout ) :: target type ( build_target_t ) , intent ( in ), target :: dependency target % dependencies = [ target % dependencies , build_target_ptr ( dependency )] end subroutine add_dependency subroutine resolve_module_dependencies ( targets , error ) ! After enumerating all source files: resolve file dependencies !  by searching on module names ! type ( build_target_ptr ), intent ( inout ), target :: targets (:) type ( error_t ), allocatable , intent ( out ) :: error type ( build_target_ptr ) :: dep integer :: i , j do i = 1 , size ( targets ) if (. not . allocated ( targets ( i )% ptr % source )) cycle do j = 1 , size ( targets ( i )% ptr % source % modules_used ) if ( targets ( i )% ptr % source % modules_used ( j )% s . in . targets ( i )% ptr % source % modules_provided ) then ! Dependency satisfied in same file, skip cycle end if if ( targets ( i )% ptr % source % unit_scope == FPM_SCOPE_APP . OR . & targets ( i )% ptr % source % unit_scope == FPM_SCOPE_TEST ) then dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s , & include_dir = dirname ( targets ( i )% ptr % source % file_name )) else dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s ) end if if (. not . associated ( dep % ptr )) then call fatal_error ( error , & 'Unable to find source for module dependency: \"' // & targets ( i )% ptr % source % modules_used ( j )% s // & '\" used by \"' // targets ( i )% ptr % source % file_name // '\"' ) return end if call add_dependency ( targets ( i )% ptr , dep % ptr ) end do end do end subroutine resolve_module_dependencies function find_module_dependency ( targets , module_name , include_dir ) result ( target_ptr ) ! Find a module dependency in the library or a dependency library ! ! 'include_dir' specifies an allowable non-library search directory !   (Used for executable dependencies) ! type ( build_target_ptr ), intent ( in ), target :: targets (:) character ( * ), intent ( in ) :: module_name character ( * ), intent ( in ), optional :: include_dir type ( build_target_t ), pointer :: target_ptr integer :: k , l target_ptr => NULL () do k = 1 , size ( targets ) if (. not . allocated ( targets ( k )% ptr % source )) cycle do l = 1 , size ( targets ( k )% ptr % source % modules_provided ) if ( module_name == targets ( k )% ptr % source % modules_provided ( l )% s ) then select case ( targets ( k )% ptr % source % unit_scope ) case ( FPM_SCOPE_LIB , FPM_SCOPE_DEP ) target_ptr => targets ( k )% ptr exit case default if ( present ( include_dir )) then if ( dirname ( targets ( k )% ptr % source % file_name ) == include_dir ) then target_ptr => targets ( k )% ptr exit end if end if end select end if end do end do end function find_module_dependency end module fpm_targets","tags":"","loc":"sourcefile/fpm_targets.f90.html"},{"title":"fpm.f90 – Fortran-lang/fpm","text":"Contents Modules fpm Source Code fpm.f90 Source Code module fpm use fpm_strings , only : string_t , str_ends_with , operator (. in .) use fpm_backend , only : build_package use fpm_command_line , only : fpm_build_settings , fpm_new_settings , & fpm_run_settings , fpm_install_settings , fpm_test_settings use fpm_environment , only : run use fpm_filesystem , only : is_dir , join_path , number_of_rows , list_files , exists , basename use fpm_model , only : fpm_model_t , srcfile_t , build_target_t , & FPM_SCOPE_UNKNOWN , FPM_SCOPE_LIB , & FPM_SCOPE_DEP , FPM_SCOPE_APP , FPM_SCOPE_TEST , & FPM_TARGET_EXECUTABLE use fpm_sources , only : add_executable_sources , add_sources_from_dir use fpm_targets , only : targets_from_sources , resolve_module_dependencies use fpm_manifest , only : get_package_data , package_config_t use fpm_error , only : error_t , fatal_error use fpm_manifest_test , only : test_config_t use , intrinsic :: iso_fortran_env , only : stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use fpm_manifest_dependency , only : dependency_config_t implicit none private public :: cmd_build , cmd_install , cmd_run contains recursive subroutine add_libsources_from_package ( sources , link_libraries , package_list , package , & package_root , dev_depends , error ) ! Discover library sources in a package, recursively including dependencies ! type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) type ( string_t ), allocatable , intent ( inout ) :: link_libraries (:) type ( string_t ), allocatable , intent ( inout ) :: package_list (:) type ( package_config_t ), intent ( in ) :: package character ( * ), intent ( in ) :: package_root logical , intent ( in ) :: dev_depends type ( error_t ), allocatable , intent ( out ) :: error ! Add package library sources if ( allocated ( package % library )) then call add_sources_from_dir ( sources , join_path ( package_root , package % library % source_dir ), & FPM_SCOPE_LIB , error = error ) if ( allocated ( error )) then return end if end if ! Add library sources from dependencies if ( allocated ( package % dependency )) then call add_dependencies ( package % dependency ) if ( allocated ( error )) then return end if end if ! Add library sources from dev-dependencies if ( dev_depends . and . allocated ( package % dev_dependency )) then call add_dependencies ( package % dev_dependency ) if ( allocated ( error )) then return end if end if contains subroutine add_dependencies ( dependency_list ) type ( dependency_config_t ), intent ( in ) :: dependency_list (:) integer :: i type ( string_t ) :: dep_name type ( package_config_t ) :: dependency character (:), allocatable :: dependency_path do i = 1 , size ( dependency_list ) if ( dependency_list ( i )% name . in . package_list ) then cycle end if if ( allocated ( dependency_list ( i )% git )) then dependency_path = join_path ( 'build' , 'dependencies' , dependency_list ( i )% name ) if (. not . exists ( join_path ( dependency_path , 'fpm.toml' ))) then call dependency_list ( i )% git % checkout ( dependency_path , error ) if ( allocated ( error )) return end if else if ( allocated ( dependency_list ( i )% path )) then dependency_path = join_path ( package_root , dependency_list ( i )% path ) end if call get_package_data ( dependency , & join_path ( dependency_path , \"fpm.toml\" ), error ) if ( allocated ( error )) then error % message = 'Error while parsing manifest for dependency package at:' // & new_line ( 'a' ) // join_path ( dependency_path , \"fpm.toml\" ) // & new_line ( 'a' ) // error % message return end if if (. not . allocated ( dependency % library ) . and . & exists ( join_path ( dependency_path , \"src\" ))) then allocate ( dependency % library ) dependency % library % source_dir = \"src\" end if call add_libsources_from_package ( sources , link_libraries , package_list , dependency , & package_root = dependency_path , & dev_depends = . false ., error = error ) if ( allocated ( error )) then error % message = 'Error while processing sources for dependency package \"' // & new_line ( 'a' ) // dependency % name // '\"' // & new_line ( 'a' ) // error % message return end if dep_name % s = dependency_list ( i )% name package_list = [ package_list , dep_name ] if ( allocated ( dependency % build % link )) then link_libraries = [ link_libraries , dependency % build % link ] end if end do end subroutine add_dependencies end subroutine add_libsources_from_package subroutine build_model ( model , settings , package , error ) ! Constructs a valid fpm model from command line settings and toml manifest ! type ( fpm_model_t ), intent ( out ) :: model type ( fpm_build_settings ), intent ( in ) :: settings type ( package_config_t ), intent ( in ) :: package type ( error_t ), allocatable , intent ( out ) :: error integer :: i type ( string_t ), allocatable :: package_list (:) model % package_name = package % name if ( allocated ( package % build % link )) then model % link_libraries = package % build % link else allocate ( model % link_libraries ( 0 )) end if allocate ( package_list ( 1 )) package_list ( 1 )% s = package % name ! #TODO: Choose flags and output directory based on cli settings & manifest inputs model % fortran_compiler = 'gfortran' if ( settings % release ) then model % output_directory = 'build/gfortran_release' model % fortran_compile_flags = ' & & -O3 & & -Wimplicit-interface & & -fPIC & & -fmax-errors=1 & & -ffast-math & & -funroll-loops ' // & & '-J' // join_path ( model % output_directory , model % package_name ) else model % output_directory = 'build/gfortran_debug' model % fortran_compile_flags = ' -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g ' // & '-fbounds-check -fcheck-array-temporaries -fbacktrace ' // & '-J' // join_path ( model % output_directory , model % package_name ) endif model % link_flags = '' ! Add sources from executable directories if ( is_dir ( 'app' ) . and . package % build % auto_executables ) then call add_sources_from_dir ( model % sources , 'app' , FPM_SCOPE_APP , & with_executables = . true ., error = error ) if ( allocated ( error )) then return end if end if if ( is_dir ( 'test' ) . and . package % build % auto_tests ) then call add_sources_from_dir ( model % sources , 'test' , FPM_SCOPE_TEST , & with_executables = . true ., error = error ) if ( allocated ( error )) then return endif end if if ( allocated ( package % executable )) then call add_executable_sources ( model % sources , package % executable , FPM_SCOPE_APP , & auto_discover = package % build % auto_executables , & error = error ) if ( allocated ( error )) then return end if end if if ( allocated ( package % test )) then call add_executable_sources ( model % sources , package % test , FPM_SCOPE_TEST , & auto_discover = package % build % auto_tests , & error = error ) if ( allocated ( error )) then return endif endif ! Add library sources, including local dependencies call add_libsources_from_package ( model % sources , model % link_libraries , package_list , package , & package_root = '.' , dev_depends = . true ., error = error ) if ( allocated ( error )) then return end if call targets_from_sources ( model , model % sources ) do i = 1 , size ( model % link_libraries ) model % link_flags = model % link_flags // \" -l\" // model % link_libraries ( i )% s end do call resolve_module_dependencies ( model % targets , error ) end subroutine build_model subroutine cmd_build ( settings ) type ( fpm_build_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( error_t ), allocatable :: error integer :: i call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if if ( settings % list ) then do i = 1 , size ( model % targets ) write ( stderr , * ) model % targets ( i )% ptr % output_file enddo else call build_package ( model ) endif end subroutine subroutine cmd_install ( settings ) type ( fpm_install_settings ), intent ( in ) :: settings print * , \"fpm error: 'fpm install' not implemented.\" error stop 8 end subroutine cmd_install subroutine cmd_run ( settings , test ) class ( fpm_run_settings ), intent ( in ) :: settings logical , intent ( in ) :: test integer , parameter :: LINE_WIDTH = 80 integer :: i , j , col_width , nCol logical :: found ( size ( settings % name )) type ( error_t ), allocatable :: error type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( string_t ) :: exe_cmd type ( string_t ), allocatable :: executables (:) type ( build_target_t ), pointer :: exe_target type ( srcfile_t ), pointer :: exe_source call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings % fpm_build_settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if ! Enumerate executable targets to run col_width = - 1 found (:) = . false . allocate ( executables ( 0 )) do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == & merge ( FPM_SCOPE_TEST , FPM_SCOPE_APP , test )) then col_width = max ( col_width , len ( basename ( exe_target % output_file )) + 2 ) if ( size ( settings % name ) == 0 ) then exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] else do j = 1 , size ( settings % name ) if ( trim ( settings % name ( j )) == exe_source % exe_name ) then found ( j ) = . true . exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] end if end do end if end if end if end do ! Check if any apps/tests were found if ( col_width < 0 ) then if ( test ) then write ( stderr , * ) 'No tests to run' else write ( stderr , * ) 'No executables to run' end if stop end if ! Check all names are valid if ( any (. not . found )) then write ( stderr , '(A)' , advance = \"no\" ) 'fpm::run<ERROR> specified names ' do j = 1 , size ( settings % name ) if (. not . found ( j )) write ( stderr , '(A)' , advance = \"no\" ) '\"' // trim ( settings % name ( j )) // '\" ' end do write ( stderr , '(A)' ) 'not found.' write ( stderr , * ) j = 1 nCol = LINE_WIDTH / col_width write ( stderr , * ) 'Available names:' do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == & merge ( FPM_SCOPE_TEST , FPM_SCOPE_APP , test )) then write ( stderr , '(A)' , advance = ( merge ( \"yes\" , \"no \" , modulo ( j , nCol ) == 0 ))) & & [ character ( len = col_width ) :: basename ( exe_target % output_file )] j = j + 1 end if end if end do write ( stderr , * ) stop 1 end if ! NB. To be replaced after incremental rebuild is implemented if (. not . settings % list . and . & any ([(. not . exists ( executables ( i )% s ), i = 1 , size ( executables ))])) then call build_package ( model ) end if do i = 1 , size ( executables ) if ( settings % list ) then write ( stderr , * ) executables ( i )% s else if ( exists ( executables ( i )% s )) then call run ( executables ( i )% s // \" \" // settings % args ) else write ( stderr , * ) 'fpm::run<ERROR>' , executables ( i )% s , ' not found' stop 1 end if end if end do end subroutine cmd_run end module fpm","tags":"","loc":"sourcefile/fpm.f90.html"},{"title":"versioning.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_versioning Source Code versioning.f90 Source Code !> Implementation of versioning data for comparing packages module fpm_versioning use fpm_error , only : error_t , syntax_error implicit none private public :: version_t , new_version type :: version_t private !> Version numbers found integer , allocatable :: num (:) contains generic :: operator ( == ) => equals procedure , private :: equals generic :: operator ( /= ) => not_equals procedure , private :: not_equals generic :: operator ( > ) => greater procedure , private :: greater generic :: operator ( < ) => less procedure , private :: less generic :: operator ( >= ) => greater_equals procedure , private :: greater_equals generic :: operator ( <= ) => less_equals procedure , private :: less_equals !> Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic :: operator (. match .) => match procedure , private :: match !> Create a printable string from a version data type procedure :: to_string end type version_t !> Arbitrary internal limit of the version parser integer , parameter :: max_limit = 3 interface new_version module procedure :: new_version_from_string module procedure :: new_version_from_int end interface new_version contains !> Create a new version from a string subroutine new_version_from_int ( self , num ) !> Instance of the versioning data type ( version_t ), intent ( out ) :: self !> Subversion numbers to define version data integer , intent ( in ) :: num (:) self % num = num end subroutine new_version_from_int !> Create a new version from a string subroutine new_version_from_string ( self , string , error ) !> Instance of the versioning data type ( version_t ), intent ( out ) :: self !> String describing the version information character ( len =* ), intent ( in ) :: string !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character :: tok integer :: ii , istart , iend , stat , nn integer :: num ( max_limit ) logical :: is_number nn = 0 iend = 0 istart = 0 is_number = . false . do while ( iend < len ( string )) call next ( string , istart , iend , is_number , error ) if ( allocated ( error )) exit if ( is_number ) then if ( nn >= max_limit ) then call token_error ( error , string , istart , iend , & & \"Too many subversions found\" ) exit end if nn = nn + 1 read ( string ( istart : iend ), * , iostat = stat ) num ( nn ) if ( stat /= 0 ) then call token_error ( error , string , istart , iend , & & \"Failed to parse version number\" ) exit end if end if end do if ( allocated ( error )) return if (. not . is_number ) then call token_error ( error , string , istart , iend , & & \"Expected version number, but no characters are left\" ) return end if call new_version ( self , num (: nn )) end subroutine new_version_from_string !> Tokenize a version string subroutine next ( string , istart , iend , is_number , error ) !> String describing the version information character ( len =* ), intent ( in ) :: string !> Start of last token, start of next token on exit integer , intent ( inout ) :: istart !> End of last token on entry, end of next token on exit integer , intent ( inout ) :: iend !> Token produced is a number logical , intent ( inout ) :: is_number !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii , nn logical :: was_number character :: tok , last was_number = is_number nn = len ( string ) if ( iend >= nn ) then istart = nn iend = nn return end if ii = min ( iend + 1 , nn ) tok = string ( ii : ii ) is_number = tok /= '.' if ( is_number . eqv . was_number ) then call token_error ( error , string , istart , ii , & & \"Unexpected token found\" ) return end if if (. not . is_number ) then is_number = . false . istart = ii iend = ii return end if istart = ii do ii = min ( iend + 1 , nn ), nn tok = string ( ii : ii ) select case ( tok ) case default call token_error ( error , string , istart , ii , & & \"Invalid character in version number\" ) exit case ( '.' ) exit case ( '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ) iend = ii cycle end select end do end subroutine next !> Create an error on an invalid token, provide some visual context as well subroutine token_error ( error , string , istart , iend , message ) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error !> String describing the version information character ( len =* ), intent ( in ) :: string !> Start of last token, start of next token on exit integer , intent ( in ) :: istart !> End of last token on entry, end of next token on exit integer , intent ( in ) :: iend !> Error message character ( len =* ), intent ( in ) :: message character ( len =* ), parameter :: nl = new_line ( 'a' ) allocate ( error ) error % message = message // nl // \"  | \" // string // nl // & & \"  |\" // repeat ( '-' , istart ) // repeat ( '&#94;' , iend - istart + 1 ) end subroutine token_error subroutine to_string ( self , string ) !> Version number class ( version_t ), intent ( in ) :: self !> Character representation of the version character ( len = :), allocatable , intent ( out ) :: string integer , parameter :: buffersize = 64 character ( len = buffersize ) :: buffer integer :: ii do ii = 1 , size ( self % num ) if ( allocated ( string )) then write ( buffer , '(\".\", i0)' ) self % num ( ii ) string = string // trim ( buffer ) else write ( buffer , '(i0)' ) self % num ( ii ) string = trim ( buffer ) end if end do if (. not . allocated ( string )) then string = '0' end if end subroutine to_string !> Check to version numbers for equality elemental function equals ( lhs , rhs ) result ( is_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version match logical :: is_equal is_equal = . not .( lhs > rhs ) if ( is_equal ) then is_equal = . not .( rhs > lhs ) end if end function equals !> Check two versions for inequality elemental function not_equals ( lhs , rhs ) result ( not_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version mismatch logical :: not_equal not_equal = lhs > rhs if (. not . not_equal ) then not_equal = rhs > lhs end if end function not_equals !> Relative comparison of two versions elemental function greater ( lhs , rhs ) result ( is_greater ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is greater logical :: is_greater integer :: ii do ii = 1 , min ( size ( lhs % num ), size ( rhs % num )) is_greater = lhs % num ( ii ) > rhs % num ( ii ) if ( is_greater ) exit end do if ( is_greater ) return is_greater = size ( lhs % num ) > size ( rhs % num ) if ( is_greater ) then do ii = size ( rhs % num ) + 1 , size ( lhs % num ) is_greater = lhs % num ( ii ) > 0 if ( is_greater ) exit end do end if end function greater !> Relative comparison of two versions elemental function less ( lhs , rhs ) result ( is_less ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is less logical :: is_less is_less = rhs > lhs end function less !> Relative comparison of two versions elemental function greater_equals ( lhs , rhs ) result ( is_greater_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is greater or equal logical :: is_greater_equal is_greater_equal = . not . ( rhs > lhs ) end function greater_equals !> Relative comparison of two versions elemental function less_equals ( lhs , rhs ) result ( is_less_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is less or equal logical :: is_less_equal is_less_equal = . not . ( lhs > rhs ) end function less_equals !> Try to match first version against second version elemental function match ( lhs , rhs ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version match following semantic versioning rules logical :: match type ( version_t ) :: tmp match = . not .( rhs > lhs ) if ( match ) then tmp % num = rhs % num tmp % num ( size ( tmp % num )) = tmp % num ( size ( tmp % num )) + 1 match = tmp > lhs end if end function match end module fpm_versioning","tags":"","loc":"sourcefile/versioning.f90.html"},{"title":"error.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_error Source Code error.f90 Source Code !> Implementation of basic error handling. module fpm_error implicit none private public :: error_t public :: fatal_error , syntax_error , file_not_found_error public :: file_parse_error !> Data type defining an error type :: error_t !> Error message character ( len = :), allocatable :: message end type error_t !> Alias syntax errors to fatal errors for now interface syntax_error module procedure :: fatal_error end interface syntax_error contains !> Generic fatal runtime error subroutine fatal_error ( error , message ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Error message character ( len =* ), intent ( in ) :: message allocate ( error ) error % message = message end subroutine fatal_error !> Error created when a file is missing or not found subroutine file_not_found_error ( error , file_name ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of the missing file character ( len =* ), intent ( in ) :: file_name allocate ( error ) error % message = \"'\" // file_name // \"' could not be found, check if the file exists\" end subroutine file_not_found_error !> Error created when file parsing fails subroutine file_parse_error ( error , file_name , message , line_num , & line_string , line_col ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of file character ( len =* ), intent ( in ) :: file_name !> Parse error message character ( len =* ), intent ( in ) :: message !> Line number of parse error integer , intent ( in ), optional :: line_num !> Line context string character ( len =* ), intent ( in ), optional :: line_string !> Line context column integer , intent ( in ), optional :: line_col character ( 50 ) :: temp_string allocate ( error ) error % message = 'Parse error: ' // message // new_line ( 'a' ) error % message = error % message // file_name if ( present ( line_num )) then write ( temp_string , '(I0)' ) line_num error % message = error % message // ':' // trim ( temp_string ) end if if ( present ( line_col )) then if ( line_col > 0 ) then write ( temp_string , '(I0)' ) line_col error % message = error % message // ':' // trim ( temp_string ) end if end if if ( present ( line_string )) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // line_string if ( present ( line_col )) then if ( line_col > 0 ) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // repeat ( ' ' , line_col - 1 ) // '&#94;' end if end if end if end subroutine file_parse_error end module fpm_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"git.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_git Source Code git.f90 Source Code !> Implementation for interacting with git repositories. module fpm_git use fpm_error , only : error_t , fatal_error implicit none public :: git_target_t public :: git_target_default , git_target_branch , git_target_tag , & & git_target_revision !> Possible git target type :: enum_descriptor !> Default target integer :: default = 200 !> Branch in git repository integer :: branch = 201 !> Tag in git repository integer :: tag = 202 !> Commit hash integer :: revision = 203 end type enum_descriptor !> Actual enumerator for descriptors type ( enum_descriptor ), parameter :: git_descriptor = enum_descriptor () !> Description of an git target type :: git_target_t private !> Kind of the git target integer :: descriptor = git_descriptor % default !> Target URL of the git repository character ( len = :), allocatable :: url !> Additional descriptor of the git object character ( len = :), allocatable :: object contains !> Fetch and checkout in local directory procedure :: checkout !> Show information on instance procedure :: info end type git_target_t contains !> Default target function git_target_default ( url ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % default self % url = url end function git_target_default !> Target a branch in the git repository function git_target_branch ( url , branch ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Name of the branch of interest character ( len =* ), intent ( in ) :: branch !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % branch self % url = url self % object = branch end function git_target_branch !> Target a specific git revision function git_target_revision ( url , sha1 ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Commit hash of interest character ( len =* ), intent ( in ) :: sha1 !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % revision self % url = url self % object = sha1 end function git_target_revision !> Target a git tag function git_target_tag ( url , tag ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Tag name of interest character ( len =* ), intent ( in ) :: tag !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % tag self % url = url self % object = tag end function git_target_tag subroutine checkout ( self , local_path , error ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Error type ( error_t ), allocatable , intent ( out ) :: error !> git object ref character (:), allocatable :: object !> Stat for execute_command_line integer :: stat if ( allocated ( self % object )) then object = self % object else object = 'HEAD' end if call execute_command_line ( \"git init \" // local_path , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while initiating git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" fetch \" // self % url // & \" \" // object , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while fetching git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" checkout -qf FETCH_HEAD\" , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while checking out git repository for remote dependency' ) return end if end subroutine checkout !> Show information on git target subroutine info ( self , unit , verbosity ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Git target\" if ( allocated ( self % url )) then write ( unit , fmt ) \"- URL\" , self % url end if if ( allocated ( self % object )) then select case ( self % descriptor ) case default write ( unit , fmt ) \"- object\" , self % object case ( git_descriptor % tag ) write ( unit , fmt ) \"- tag\" , self % object case ( git_descriptor % branch ) write ( unit , fmt ) \"- branch\" , self % object case ( git_descriptor % revision ) write ( unit , fmt ) \"- sha1\" , self % object end select end if end subroutine info end module fpm_git","tags":"","loc":"sourcefile/git.f90.html"},{"title":"toml.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_toml Source Code toml.f90 Source Code !> Interface to TOML processing library. !> !> This module acts as a proxy to the `toml-f` public Fortran API and allows !> to selectively expose components from the library to `fpm`. !> The interaction with `toml-f` data types outside of this module should be !> limited to tables, arrays and key-lists, most of the necessary interactions !> are implemented in the building interface with the `get_value` and `set_value` !> procedures. !> !> This module allows to implement features necessary for `fpm`, which are !> not yet available in upstream `toml-f`. !> !> For more details on the library used see: https://toml-f.github.io/toml-f module fpm_toml use fpm_error , only : error_t , fatal_error , file_not_found_error use fpm_strings , only : string_t use tomlf , only : toml_table , toml_array , toml_key , toml_stat , get_value , & & set_value , toml_parse , toml_error , new_table , add_table , add_array , len implicit none private public :: read_package_file public :: toml_table , toml_array , toml_key , toml_stat , get_value , set_value public :: new_table , add_table , add_array , len interface get_value module procedure :: get_child_value_string_list end interface get_value contains !> Process the configuration file to a TOML data structure subroutine read_package_file ( table , manifest , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the package configuration file character ( len =* ), intent ( in ) :: manifest !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = manifest , exist = exist ) if (. not . exist ) then call file_not_found_error ( error , manifest ) return end if open ( file = manifest , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_package_file subroutine get_child_value_string_list ( table , key , list , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Key to read from character ( len =* ), intent ( in ) :: key !> List of strings to read type ( string_t ), allocatable , intent ( out ) :: list (:) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat , ilist , nlist type ( toml_array ), pointer :: children character ( len = :), allocatable :: str call get_value ( table , key , children , requested = . false .) if ( associated ( children )) then nlist = len ( children ) allocate ( list ( nlist )) do ilist = 1 , nlist call get_value ( children , ilist , str , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Entry in \" // key // \" field cannot be read\" ) exit end if call move_alloc ( str , list ( ilist )% s ) end do if ( allocated ( error )) return else call get_value ( table , key , str , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Entry in \" // key // \" field cannot be read\" ) return end if if ( allocated ( str )) then allocate ( list ( 1 )) call move_alloc ( str , list ( 1 )% s ) end if end if end subroutine get_child_value_string_list end module fpm_toml","tags":"","loc":"sourcefile/toml.f90.html"},{"title":"manifest.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest Source Code manifest.f90 Source Code !> Package configuration data. !> !> This module provides the necessary procedure to translate a TOML document !> to the corresponding Fortran type, while verifying it with respect to !> its schema. !> !> Additionally, the required data types for users of this module are reexported !> to hide the actual implementation details. module fpm_manifest use fpm_manifest_build , only : build_config_t use fpm_manifest_executable , only : executable_config_t use fpm_manifest_library , only : library_config_t use fpm_manifest_package , only : package_config_t , new_package use fpm_error , only : error_t , fatal_error , file_not_found_error use fpm_toml , only : toml_table , read_package_file use fpm_manifest_test , only : test_config_t use fpm_filesystem , only : join_path , exists implicit none private public :: get_package_data , default_executable , default_library , default_test public :: package_config_t contains !> Populate library in case we find the default src directory subroutine default_library ( self ) !> Instance of the library meta data type ( library_config_t ), intent ( out ) :: self self % source_dir = \"src\" end subroutine default_library !> Populate executable in case we find the default app directory subroutine default_executable ( self , name ) !> Instance of the executable meta data type ( executable_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"app\" self % main = \"main.f90\" end subroutine default_executable !> Populate test in case we find the default test/ directory subroutine default_test ( self , name ) !> Instance of the executable meta data type ( test_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"test\" self % main = \"main.f90\" end subroutine default_test !> Obtain package meta data from a configuation file subroutine get_package_data ( package , file , error , apply_defaults ) !> Parsed package meta data type ( package_config_t ), intent ( out ) :: package !> Name of the package configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error !> Apply package defaults (uses file system operations) logical , intent ( in ), optional :: apply_defaults type ( toml_table ), allocatable :: table call read_package_file ( table , file , error ) if ( allocated ( error )) return if (. not . allocated ( table )) then call fatal_error ( error , \"Unclassified error while reading: '\" // file // \"'\" ) return end if call new_package ( package , table , error ) if ( present ( apply_defaults )) then if ( apply_defaults ) then call package_defaults ( package , error ) if ( allocated ( error )) return end if end if end subroutine get_package_data !> Apply package defaults subroutine package_defaults ( package , error ) !> Parsed package meta data type ( package_config_t ), intent ( inout ) :: package !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error ! Populate library in case we find the default src directory if (. not . allocated ( package % library ) . and . exists ( \"src\" )) then allocate ( package % library ) call default_library ( package % library ) end if ! Populate executable in case we find the default app if (. not . allocated ( package % executable ) . and . & exists ( join_path ( 'app' , \"main.f90\" ))) then allocate ( package % executable ( 1 )) call default_executable ( package % executable ( 1 ), package % name ) end if ! Populate test in case we find the default test directory if (. not . allocated ( package % test ) . and . & exists ( join_path ( \"test\" , \"main.f90\" ))) then allocate ( package % test ( 1 )) call default_test ( package % test ( 1 ), package % name ) endif if (. not .( allocated ( package % library ) . or . allocated ( package % executable ))) then call fatal_error ( error , \"Neither library nor executable found, there is nothing to do\" ) return end if end subroutine package_defaults end module fpm_manifest","tags":"","loc":"sourcefile/manifest.f90.html"},{"title":"test.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_test Source Code test.f90 Source Code !> Implementation of the meta data for a test. !> !> The test data structure is effectively a decorated version of an executable !> and shares most of its properties, except for the defaults and can be !> handled under most circumstances just like any other executable. !> !> A test table can currently have the following fields !> !>```toml !>[[ test ]] !>name = \"string\" !>source-dir = \"path\" !>main = \"file\" !>link = [\"lib\"] !>[test.dependencies] !>``` module fpm_manifest_test use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_manifest_executable , only : executable_config_t use fpm_error , only : error_t , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: test_config_t , new_test !> Configuation meta data for an test type , extends ( executable_config_t ) :: test_config_t contains !> Print information on this instance procedure :: info end type test_config_t contains !> Construct a new test configuration from a TOML data structure subroutine new_test ( self , table , error ) !> Instance of the test configuration type ( test_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve test name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"test\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_test !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Test section does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in test entry\" ) exit case ( \"name\" ) name_present = . true . case ( \"source-dir\" , \"main\" , \"dependencies\" , \"link\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Test name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the test configuration class ( test_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Test target\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % source_dir )) then if ( self % source_dir /= \"test\" . or . pr > 2 ) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if end if if ( allocated ( self % main )) then if ( self % main /= \"main.f90\" . or . pr > 2 ) then write ( unit , fmt ) \"- test source\" , self % main end if end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_test","tags":"","loc":"sourcefile/test.f90.html"},{"title":"build.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_build Source Code build.f90 Source Code !> Implementation of the build configuration data. !> !> A build table can currently have the following fields !> !>```toml !>[build] !>auto-executables = bool !>auto-tests = bool !>link = [\"lib\"] !>``` module fpm_manifest_build use fpm_error , only : error_t , syntax_error , fatal_error use fpm_strings , only : string_t use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: build_config_t , new_build_config !> Configuration data for build type :: build_config_t !> Automatic discovery of executables logical :: auto_executables !> Automatic discovery of tests logical :: auto_tests !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type build_config_t contains !> Construct a new build configuration from a TOML data structure subroutine new_build_config ( self , table , error ) !> Instance of the build configuration type ( build_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"auto-executables\" , self % auto_executables , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-executables' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-tests\" , self % auto_tests , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-tests' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_build_config !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) integer :: ikey call table % get_keys ( list ) ! table can be empty if ( size ( list ) < 1 ) return do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case ( \"auto-executables\" , \"auto-tests\" , \"link\" ) continue case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in [build]\" ) exit end select end do end subroutine check !> Write information on build configuration instance subroutine info ( self , unit , verbosity ) !> Instance of the build configuration class ( build_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ilink character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Build configuration\" write ( unit , fmt ) \" - auto-discovery (apps) \" , merge ( \"enabled \" , \"disabled\" , self % auto_executables ) write ( unit , fmt ) \" - auto-discovery (tests) \" , merge ( \"enabled \" , \"disabled\" , self % auto_tests ) if ( allocated ( self % link )) then write ( unit , fmt ) \" - link against\" do ilink = 1 , size ( self % link ) write ( unit , fmt ) \"   - \" // self % link ( ilink )% s end do end if end subroutine info end module fpm_manifest_build","tags":"","loc":"sourcefile/build.f90.html"},{"title":"dependency.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_dependency Source Code dependency.f90 Source Code !> Implementation of the meta data for dependencies. !> !> A dependency table can currently have the following fields !> !>```toml !>[dependencies] !>\"dep1\" = { git = \"url\" } !>\"dep2\" = { git = \"url\", branch = \"name\" } !>\"dep3\" = { git = \"url\", tag = \"name\" } !>\"dep4\" = { git = \"url\", rev = \"sha1\" } !>\"dep0\" = { path = \"path\" } !>``` !> !> To reduce the amount of boilerplate code this module provides two constructors !> for dependency types, one basic for an actual dependency (inline) table !> and another to collect all dependency objects from a dependencies table, !> which is handling the allocation of the objects and is forwarding the !> individual dependency tables to their respective constructors. !> The usual entry point should be the constructor for the super table. !> !> This objects contains a target to retrieve required `fpm` projects to !> build the target declaring the dependency. !> Resolving a dependency will result in obtaining a new package configuration !> data for the respective project. module fpm_manifest_dependency use fpm_error , only : error_t , syntax_error use fpm_git , only : git_target_t , git_target_tag , git_target_branch , & & git_target_revision , git_target_default use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: dependency_config_t , new_dependency , new_dependencies !> Configuration meta data for a dependency type :: dependency_config_t !> Name of the dependency character ( len = :), allocatable :: name !> Local target character ( len = :), allocatable :: path !> Git descriptor type ( git_target_t ), allocatable :: git contains !> Print information on this instance procedure :: info end type dependency_config_t contains !> Construct a new dependency configuration from a TOML data structure subroutine new_dependency ( self , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: url , obj call check ( table , error ) if ( allocated ( error )) return call table % get_key ( self % name ) call get_value ( table , \"path\" , url ) if ( allocated ( url )) then call move_alloc ( url , self % path ) else call get_value ( table , \"git\" , url ) call get_value ( table , \"tag\" , obj ) if ( allocated ( obj )) then self % git = git_target_tag ( url , obj ) end if if (. not . allocated ( self % git )) then call get_value ( table , \"branch\" , obj ) if ( allocated ( obj )) then self % git = git_target_branch ( url , obj ) end if end if if (. not . allocated ( self % git )) then call get_value ( table , \"rev\" , obj ) if ( allocated ( obj )) then self % git = git_target_revision ( url , obj ) end if end if if (. not . allocated ( self % git )) then self % git = git_target_default ( url ) end if end if end subroutine new_dependency !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: name type ( toml_key ), allocatable :: list (:) logical :: url_present , git_target_present , has_path integer :: ikey has_path = . false . url_present = . false . git_target_present = . false . call table % get_key ( name ) call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Dependency \" // name // \" does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in dependency \" // name ) exit case ( \"git\" , \"path\" ) if ( url_present ) then call syntax_error ( error , \"Dependency \" // name // \" cannot have both git and path entries\" ) exit end if url_present = . true . has_path = list ( ikey )% key == 'path' case ( \"branch\" , \"rev\" , \"tag\" ) if ( git_target_present ) then call syntax_error ( error , \"Dependency \" // name // \" can only have one of branch, rev or tag present\" ) exit end if git_target_present = . true . end select end do if ( allocated ( error )) return if (. not . url_present ) then call syntax_error ( error , \"Dependency \" // name // \" does not provide a method to actually retrieve itself\" ) return end if if ( has_path . and . git_target_present ) then call syntax_error ( error , \"Dependency \" // name // \" uses a local path, therefore no git identifiers are allowed\" ) end if end subroutine check !> Construct new dependency array from a TOML data structure subroutine new_dependencies ( deps , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), allocatable , intent ( out ) :: deps (:) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: node type ( toml_key ), allocatable :: list (:) integer :: idep , stat call table % get_keys ( list ) ! An empty table is okay if ( size ( list ) < 1 ) return allocate ( deps ( size ( list ))) do idep = 1 , size ( list ) call get_value ( table , list ( idep )% key , node , stat = stat ) if ( stat /= toml_stat % success ) then call syntax_error ( error , \"Dependency \" // list ( idep )% key // \" must be a table entry\" ) exit end if call new_dependency ( deps ( idep ), node , error ) if ( allocated ( error )) exit end do end subroutine new_dependencies !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the dependency configuration class ( dependency_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if write ( unit , fmt ) \"Dependency\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % git )) then write ( unit , fmt ) \"- kind\" , \"git\" call self % git % info ( unit , pr - 1 ) end if if ( allocated ( self % path )) then write ( unit , fmt ) \"- kind\" , \"local\" write ( unit , fmt ) \"- path\" , self % path end if end subroutine info end module fpm_manifest_dependency","tags":"","loc":"sourcefile/dependency.f90.html"},{"title":"executable.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_executable Source Code executable.f90 Source Code !> Implementation of the meta data for an executables. !> !> An executable table can currently have the following fields !> !>```toml !>[[ executable ]] !>name = \"string\" !>source-dir = \"path\" !>main = \"file\" !>link = [\"lib\"] !>[executable.dependencies] !>``` module fpm_manifest_executable use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_error , only : error_t , syntax_error use fpm_strings , only : string_t use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: executable_config_t , new_executable !> Configuation meta data for an executable type :: executable_config_t !> Name of the resulting executable character ( len = :), allocatable :: name !> Source directory for collecting the executable character ( len = :), allocatable :: source_dir !> Name of the source file declaring the main program character ( len = :), allocatable :: main !> Dependency meta data for this executable type ( dependency_config_t ), allocatable :: dependency (:) !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type executable_config_t contains !> Construct a new executable configuration from a TOML data structure subroutine new_executable ( self , table , error ) !> Instance of the executable configuration type ( executable_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve executable name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"app\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_executable !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Executable section does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed as executable entry\" ) exit case ( \"name\" ) name_present = . true . case ( \"source-dir\" , \"main\" , \"dependencies\" , \"link\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Executable name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the executable configuration class ( executable_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Executable target\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % source_dir )) then if ( self % source_dir /= \"app\" . or . pr > 2 ) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if end if if ( allocated ( self % main )) then if ( self % main /= \"main.f90\" . or . pr > 2 ) then write ( unit , fmt ) \"- program source\" , self % main end if end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_executable","tags":"","loc":"sourcefile/executable.f90.html"},{"title":"package.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_package Source Code package.f90 Source Code !> Define the package data containing the meta data from the configuration file. !> !> The package data defines a Fortran type corresponding to the respective !> TOML document, after creating it from a package file no more interaction !> with the TOML document is required. !> !> Every configuration type provides it custom constructor (prefixed with `new_`) !> and knows how to deserialize itself from a TOML document. !> To ensure we find no untracked content in the package file all keywords are !> checked and possible entries have to be explicitly allowed in the `check` !> function. !> If entries are mutally exclusive or interdependent inside the current table !> the `check` function is required to enforce this schema on the data structure. !> !> The package file root allows the following keywords !> !>```toml !>name = \"string\" !>version = \"string\" !>license = \"string\" !>author = \"string\" !>maintainer = \"string\" !>copyright = \"string\" !>[library] !>[dependencies] !>[dev-dependencies] !>[[ executable ]] !>[[ test ]] !>``` module fpm_manifest_package use fpm_manifest_build , only : build_config_t , new_build_config use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_manifest_executable , only : executable_config_t , new_executable use fpm_manifest_library , only : library_config_t , new_library use fpm_manifest_test , only : test_config_t , new_test use fpm_error , only : error_t , fatal_error , syntax_error use fpm_toml , only : toml_table , toml_array , toml_key , toml_stat , get_value , & & len use fpm_versioning , only : version_t , new_version implicit none private public :: package_config_t , new_package !> Package meta data type :: package_config_t !> Name of the package character ( len = :), allocatable :: name !> Build configuration data type ( build_config_t ) :: build !> Package version type ( version_t ) :: version !> Library meta data type ( library_config_t ), allocatable :: library !> Executable meta data type ( executable_config_t ), allocatable :: executable (:) !> Dependency meta data type ( dependency_config_t ), allocatable :: dependency (:) !> Development dependency meta data type ( dependency_config_t ), allocatable :: dev_dependency (:) !> Test meta data type ( test_config_t ), allocatable :: test (:) contains !> Print information on this instance procedure :: info end type package_config_t contains !> Construct a new package configuration from a TOML data structure subroutine new_package ( self , table , error ) !> Instance of the package configuration type ( package_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child , node type ( toml_array ), pointer :: children character ( len = :), allocatable :: version integer :: ii , nn , stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve package name\" ) return end if call get_value ( table , \"build\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for build entry, must be a table\" ) return end if call new_build_config ( self % build , child , error ) if ( allocated ( error )) return call get_value ( table , \"version\" , version , \"0\" ) call new_version ( self % version , version , error ) if ( allocated ( error )) return call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"dev-dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dev_dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"library\" , child , requested = . false .) if ( associated ( child )) then allocate ( self % library ) call new_library ( self % library , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"executable\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % executable ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve executable from array entry\" ) exit end if call new_executable ( self % executable ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end if call get_value ( table , \"test\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % test ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve test from array entry\" ) exit end if call new_test ( self % test ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end if end subroutine new_package !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Package file is empty\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in package file\" ) exit case ( \"name\" ) name_present = . true . case ( \"version\" , \"license\" , \"author\" , \"maintainer\" , \"copyright\" , & & \"description\" , \"keywords\" , \"categories\" , \"homepage\" , \"build\" , & & \"dependencies\" , \"dev-dependencies\" , \"test\" , \"executable\" , & & \"library\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Package name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the package configuration class ( package_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Package\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if call self % build % info ( unit , pr - 1 ) if ( allocated ( self % library )) then write ( unit , fmt ) \"- target\" , \"archive\" call self % library % info ( unit , pr - 1 ) end if if ( allocated ( self % executable )) then if ( size ( self % executable ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- executables\" , size ( self % executable ) end if do ii = 1 , size ( self % executable ) call self % executable ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % test )) then if ( size ( self % test ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- tests\" , size ( self % test ) end if do ii = 1 , size ( self % test ) call self % test ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % dev_dependency )) then if ( size ( self % dev_dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- development deps.\" , size ( self % dev_dependency ) end if do ii = 1 , size ( self % dev_dependency ) call self % dev_dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_package","tags":"","loc":"sourcefile/package.f90.html"},{"title":"library.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_library Source Code library.f90 Source Code !> Implementation of the meta data for libraries. !> !> A library table can currently have the following fields !> !>```toml !>[library] !>source-dir = \"path\" !>build-script = \"file\" !>``` module fpm_manifest_library use fpm_error , only : error_t , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: library_config_t , new_library !> Configuration meta data for a library type :: library_config_t !> Source path prefix character ( len = :), allocatable :: source_dir !> Alternative build script to be invoked character ( len = :), allocatable :: build_script contains !> Print information on this instance procedure :: info end type library_config_t contains !> Construct a new library configuration from a TOML data structure subroutine new_library ( self , table , error ) !> Instance of the library configuration type ( library_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"source-dir\" , self % source_dir , \"src\" ) call get_value ( table , \"build-script\" , self % build_script ) end subroutine new_library !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) integer :: ikey call table % get_keys ( list ) ! table can be empty if ( size ( list ) < 1 ) return do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in library\" ) exit case ( \"source-dir\" , \"build-script\" ) continue end select end do end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the library configuration class ( library_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Library target\" if ( allocated ( self % source_dir )) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if if ( allocated ( self % build_script )) then write ( unit , fmt ) \"- custom build\" , self % build_script end if end subroutine info end module fpm_manifest_library","tags":"","loc":"sourcefile/library.f90.html"},{"title":"new.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_cmd_new Source Code new.f90 Source Code module fpm_cmd_new use fpm_command_line , only : fpm_new_settings use fpm_environment , only : run , OS_LINUX , OS_MACOS , OS_WINDOWS use fpm_filesystem , only : join_path , exists , basename , mkdir , is_dir use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none private public :: cmd_new contains subroutine cmd_new ( settings ) type ( fpm_new_settings ), intent ( in ) :: settings character ( len = :), allocatable :: bname ! baeename of NAME character ( len = :), allocatable :: message (:) character ( len = :), allocatable :: littlefile (:) character ( len = 8 ) :: date call date_and_time ( DATE = date ) if ( exists ( settings % name ) . and . . not . settings % backfill ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists.' write ( stderr , '(*(g0,1x))' )& & '        perhaps you wanted to add --backfill ?' return elseif ( is_dir ( settings % name ) . and . settings % backfill ) then write ( * , '(*(g0))' ) 'backfilling ' , settings % name elseif ( exists ( settings % name ) ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists and is not a directory.' return else ! make new directory call mkdir ( settings % name ) endif ! change to new directory as a test. System dependent potentially call run ( 'cd ' // settings % name ) ! NOTE: need some system routines to handle filenames like \".\" ! like realpath() or getcwd(). bname = basename ( settings % name ) ! create NAME/.gitignore file call warnwrite ( join_path ( settings % name , '.gitignore' ), [ 'build/*' ]) littlefile = [ character ( len = 80 ) :: '# ' // bname , 'My cool new project!' ] ! create NAME/README.md call warnwrite ( join_path ( settings % name , 'README.md' ), littlefile ) ! start building NAME/fpm.toml message = [ character ( len = 80 ) :: & & 'name = \"' // bname // '\"                     ' , & & 'version = \"0.1.0\"                        ' , & & 'license = \"license\"                      ' , & & 'author = \"Jane Doe\"                      ' , & & 'maintainer = \"jane.doe@example.com\"      ' , & & 'copyright = \"' // date ( 1 : 4 ) // ' Jane Doe\"   ' , & & '                                         ' , & & '' ] if ( settings % with_lib ) then call mkdir ( join_path ( settings % name , 'src' ) ) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[library]                            ' , & & 'source-dir=\"src\"                     ' , & & '' ] ! create placeholder module src/bname.f90 littlefile = [ character ( len = 80 ) :: & & 'module ' // bname , & & '  implicit none' , & & '  private' , & & '' , & & '  public :: say_hello' , & & 'contains' , & & '  subroutine say_hello' , & & '    print *, \"Hello, ' // bname // '!\"' , & & '  end subroutine say_hello' , & & 'end module ' // bname ] ! create NAME/src/NAME.f90 call warnwrite ( join_path ( settings % name , 'src' , bname // '.f90' ),& & littlefile ) endif if ( settings % with_test ) then ! create NAME/test or stop call mkdir ( join_path ( settings % name , 'test' )) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[[test]]                             ' , & & 'name=\"runTests\"                      ' , & & 'source-dir=\"test\"                    ' , & & 'main=\"main.f90\"                      ' , & & '' ] littlefile = [ character ( len = 80 ) :: & & 'program main' , & & 'implicit none' , & & '' , & & 'print *, \"Put some tests in here!\"' , & & 'end program main' ] ! create NAME/test/main.f90 call warnwrite ( join_path ( settings % name , 'test/main.f90' ), littlefile ) endif if ( settings % with_executable ) then ! create next section of fpm.toml call mkdir ( join_path ( settings % name , 'app' )) ! create NAME/app or stop message = [ character ( len = 80 ) :: message , & & '[[executable]]                       ' , & & 'name=\"' // bname // '\"                   ' , & & 'source-dir=\"app\"                     ' , & & 'main=\"main.f90\"                      ' , & & '' ] if ( exists ( bname // '/src/' )) then littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  use ' // bname // ', only: say_hello' , & & '  implicit none' , & & '' , & & '  call say_hello()' , & & 'end program main' ] else littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  implicit none' , & & '' , & & '  print *, \"hello from project ' // bname // '\"' , & & 'end program main' ] endif call warnwrite ( join_path ( settings % name , 'app/main.f90' ), littlefile ) endif ! now that built it write NAME/fpm.toml call warnwrite ( join_path ( settings % name , 'fpm.toml' ), message ) ! assumes git(1) is installed and in path call run ( 'git init ' // settings % name ) contains subroutine warnwrite ( fname , data ) character ( len =* ), intent ( in ) :: fname character ( len =* ), intent ( in ) :: data (:) if (. not . exists ( fname )) then call filewrite ( fname , data ) else write ( stderr , '(*(g0,1x))' ) 'INFO:   ' , fname ,& & 'already exists. Not overwriting' endif end subroutine warnwrite subroutine filewrite ( filename , filedata ) ! procedure to write filedata to file filename use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ) :: filedata (:) integer :: lun , i , ios character ( len = 256 ) :: message message = ' ' ios = 0 if ( filename . ne . ' ' ) then open ( file = filename , & & newunit = lun , & & form = 'formatted' , & ! FORM    = FORMATTED | UNFORMATTED & access = 'sequential' , & ! ACCESS  = SEQUENTIAL| DIRECT | STREAM & action = 'write' , & ! ACTION  = READ|WRITE| READWRITE & position = 'rewind' , & ! POSITION= ASIS      | REWIND | APPEND & status = 'new' , & ! STATUS  = NEW| REPLACE| OLD| SCRATCH| UNKNOWN & iostat = ios , & & iomsg = message ) else lun = stdout ios = 0 endif if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 1 endif ! write file do i = 1 , size ( filedata ) write ( lun , '(a)' , iostat = ios , iomsg = message ) trim ( filedata ( i )) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 4 endif enddo ! close file close ( unit = lun , iostat = ios , iomsg = message ) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' ) '*filewrite* error:' , trim ( message ) error stop 2 endif end subroutine filewrite end subroutine cmd_new end module fpm_cmd_new","tags":"","loc":"sourcefile/new.f90.html"},{"title":"string_t – Fortran-lang/fpm ","text":"type, public :: string_t Contents Variables s Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s","tags":"","loc":"type/string_t.html"},{"title":"fpm_build_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_build_settings Contents Variables list release Components Type Visibility Attributes Name Initial logical, public :: list = .false. logical, public :: release = .false.","tags":"","loc":"type/fpm_build_settings.html"},{"title":"fpm_cmd_settings – Fortran-lang/fpm ","text":"type, public, abstract :: fpm_cmd_settings Contents None","tags":"","loc":"type/fpm_cmd_settings.html"},{"title":"fpm_install_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_install_settings Contents None","tags":"","loc":"type/fpm_install_settings.html"},{"title":"fpm_new_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_new_settings Contents Variables backfill name with_executable with_lib with_test Components Type Visibility Attributes Name Initial logical, public :: backfill = .true. character(len=:), public, allocatable :: name logical, public :: with_executable = .false. logical, public :: with_lib = .true. logical, public :: with_test = .false.","tags":"","loc":"type/fpm_new_settings.html"},{"title":"fpm_run_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_build_settings ) :: fpm_run_settings Contents Variables args list name release Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) logical, public :: release = .false.","tags":"","loc":"type/fpm_run_settings.html"},{"title":"fpm_test_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_run_settings ) :: fpm_test_settings Contents Variables args list name release Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) logical, public :: release = .false.","tags":"","loc":"type/fpm_test_settings.html"},{"title":"build_target_ptr – Fortran-lang/fpm ","text":"type, public :: build_target_ptr Contents Variables ptr Source Code build_target_ptr Components Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: ptr => null() Source Code type build_target_ptr ! For constructing arrays of build_target_t pointers type ( build_target_t ), pointer :: ptr => null () end type build_target_ptr","tags":"","loc":"type/build_target_ptr.html"},{"title":"build_target_t – Fortran-lang/fpm ","text":"type, public :: build_target_t Contents Variables built dependencies link_libraries output_file source target_type touched Source Code build_target_t Components Type Visibility Attributes Name Initial logical, public :: built = .false. type( build_target_ptr ), public, allocatable :: dependencies (:) type( string_t ), public, allocatable :: link_libraries (:) character(len=:), public, allocatable :: output_file type( srcfile_t ), public, allocatable :: source integer, public :: target_type = FPM_TARGET_UNKNOWN logical, public :: touched = .false. Source Code type build_target_t character (:), allocatable :: output_file ! File path of build target object relative to cwd type ( srcfile_t ), allocatable :: source ! Primary source for this build target type ( build_target_ptr ), allocatable :: dependencies (:) ! Resolved build dependencies integer :: target_type = FPM_TARGET_UNKNOWN type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against logical :: built = . false . logical :: touched = . false . end type build_target_t","tags":"","loc":"type/build_target_t.html"},{"title":"fpm_model_t – Fortran-lang/fpm ","text":"type, public :: fpm_model_t Contents Variables fortran_compile_flags fortran_compiler link_flags link_libraries output_directory package_name sources targets Source Code fpm_model_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fortran_compile_flags character(len=:), public, allocatable :: fortran_compiler character(len=:), public, allocatable :: link_flags type( string_t ), public, allocatable :: link_libraries (:) character(len=:), public, allocatable :: output_directory character(len=:), public, allocatable :: package_name type( srcfile_t ), public, allocatable :: sources (:) type( build_target_ptr ), public, allocatable :: targets (:) Source Code type :: fpm_model_t character (:), allocatable :: package_name ! Name of package type ( srcfile_t ), allocatable :: sources (:) ! Array of sources type ( build_target_ptr ), allocatable :: targets (:) ! Array of targets with module-dependencies resolved character (:), allocatable :: fortran_compiler ! Command line name to invoke fortran compiler character (:), allocatable :: fortran_compile_flags ! Command line flags passed to fortran for compilation character (:), allocatable :: link_flags ! Command line flags pass for linking character (:), allocatable :: output_directory ! Base directory for build type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against end type fpm_model_t","tags":"","loc":"type/fpm_model_t.html"},{"title":"srcfile_t – Fortran-lang/fpm ","text":"type, public :: srcfile_t Contents Variables exe_name file_name include_dependencies is_test link_libraries modules_provided modules_used unit_scope unit_type Source Code srcfile_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: exe_name character(len=:), public, allocatable :: file_name type( string_t ), public, allocatable :: include_dependencies (:) logical, public :: is_test = .false. type( string_t ), public, allocatable :: link_libraries (:) type( string_t ), public, allocatable :: modules_provided (:) type( string_t ), public, allocatable :: modules_used (:) integer, public :: unit_scope = FPM_SCOPE_UNKNOWN integer, public :: unit_type = FPM_UNIT_UNKNOWN Source Code type srcfile_t ! Type for encapsulating a source file !  and it's metadata character (:), allocatable :: file_name ! File path relative to cwd character (:), allocatable :: exe_name ! Name of executable for FPM_UNIT_PROGRAM integer :: unit_scope = FPM_SCOPE_UNKNOWN ! app/test/lib/dependency logical :: is_test = . false . ! Is executable a test? type ( string_t ), allocatable :: modules_provided (:) ! Modules provided by this source file (lowerstring) integer :: unit_type = FPM_UNIT_UNKNOWN ! Type of program unit type ( string_t ), allocatable :: modules_used (:) ! Modules USEd by this source file (lowerstring) type ( string_t ), allocatable :: include_dependencies (:) ! Files INCLUDEd by this source file type ( string_t ), allocatable :: link_libraries (:) ! Native libraries to link against end type srcfile_t","tags":"","loc":"type/srcfile_t.html"},{"title":"version_t – Fortran-lang/fpm ","text":"type, public :: version_t Contents Type-Bound Procedures operator(.match.) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) to_string Source Code version_t Type-Bound Procedures generic, public :: operator(.match.) => match Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) private elemental function match(lhs, rhs) Try to match first version against second version Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version match following semantic versioning rules generic, public :: operator(/=) => not_equals private elemental function not_equals(lhs, rhs) result(not_equal) Check two versions for inequality Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version mismatch generic, public :: operator(<) => less private elemental function less(lhs, rhs) result(is_less) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is less generic, public :: operator(<=) => less_equals private elemental function less_equals(lhs, rhs) result(is_less_equal) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is less or equal generic, public :: operator(==) => equals private elemental function equals(lhs, rhs) result(is_equal) Check to version numbers for equality Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version match generic, public :: operator(>) => greater private elemental function greater(lhs, rhs) result(is_greater) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is greater generic, public :: operator(>=) => greater_equals private elemental function greater_equals(lhs, rhs) result(is_greater_equal) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is greater or equal procedure, public :: to_string Create a printable string from a version data type private subroutine to_string(self, string) Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: self Version number character(len=:), intent(out), allocatable :: string Character representation of the version Source Code type :: version_t private !> Version numbers found integer , allocatable :: num (:) contains generic :: operator ( == ) => equals procedure , private :: equals generic :: operator ( /= ) => not_equals procedure , private :: not_equals generic :: operator ( > ) => greater procedure , private :: greater generic :: operator ( < ) => less procedure , private :: less generic :: operator ( >= ) => greater_equals procedure , private :: greater_equals generic :: operator ( <= ) => less_equals procedure , private :: less_equals !> Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic :: operator (. match .) => match procedure , private :: match !> Create a printable string from a version data type procedure :: to_string end type version_t","tags":"","loc":"type/version_t.html"},{"title":"error_t – Fortran-lang/fpm ","text":"type, public :: error_t Data type defining an error Contents Variables message Source Code error_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message Source Code type :: error_t !> Error message character ( len = :), allocatable :: message end type error_t","tags":"","loc":"type/error_t.html"},{"title":"enum_descriptor – Fortran-lang/fpm ","text":"type, public :: enum_descriptor Possible git target Contents Variables branch default revision tag Source Code enum_descriptor Components Type Visibility Attributes Name Initial integer, public :: branch = 201 Branch in git repository integer, public :: default = 200 Default target integer, public :: revision = 203 Commit hash integer, public :: tag = 202 Tag in git repository Source Code type :: enum_descriptor !> Default target integer :: default = 200 !> Branch in git repository integer :: branch = 201 !> Tag in git repository integer :: tag = 202 !> Commit hash integer :: revision = 203 end type enum_descriptor","tags":"","loc":"type/enum_descriptor.html"},{"title":"git_target_t – Fortran-lang/fpm ","text":"type, public :: git_target_t Description of an git target Contents Type-Bound Procedures checkout info Source Code git_target_t Type-Bound Procedures procedure, public :: checkout Fetch and checkout in local directory public subroutine checkout (self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error procedure, public :: info Show information on instance public subroutine info (self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: git_target_t private !> Kind of the git target integer :: descriptor = git_descriptor % default !> Target URL of the git repository character ( len = :), allocatable :: url !> Additional descriptor of the git object character ( len = :), allocatable :: object contains !> Fetch and checkout in local directory procedure :: checkout !> Show information on instance procedure :: info end type git_target_t","tags":"","loc":"type/git_target_t.html"},{"title":"test_config_t – Fortran-lang/fpm ","text":"type, public, extends( executable_config_t ) :: test_config_t Configuation meta data for an test Contents Variables dependency link main name source_dir Type-Bound Procedures info Source Code test_config_t Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( test_config_t ), intent(in) :: self Instance of the test configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type , extends ( executable_config_t ) :: test_config_t contains !> Print information on this instance procedure :: info end type test_config_t","tags":"","loc":"type/test_config_t.html"},{"title":"build_config_t – Fortran-lang/fpm ","text":"type, public :: build_config_t Configuration data for build Contents Variables auto_executables auto_tests link Type-Bound Procedures info Source Code build_config_t Components Type Visibility Attributes Name Initial logical, public :: auto_executables Automatic discovery of executables logical, public :: auto_tests Automatic discovery of tests type( string_t ), public, allocatable :: link (:) Libraries to link against Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on build configuration instance Arguments Type Intent Optional Attributes Name class( build_config_t ), intent(in) :: self Instance of the build configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: build_config_t !> Automatic discovery of executables logical :: auto_executables !> Automatic discovery of tests logical :: auto_tests !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type build_config_t","tags":"","loc":"type/build_config_t.html"},{"title":"dependency_config_t – Fortran-lang/fpm ","text":"type, public :: dependency_config_t Configuration meta data for a dependency Contents Variables git name path Type-Bound Procedures info Source Code dependency_config_t Components Type Visibility Attributes Name Initial type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( dependency_config_t ), intent(in) :: self Instance of the dependency configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: dependency_config_t !> Name of the dependency character ( len = :), allocatable :: name !> Local target character ( len = :), allocatable :: path !> Git descriptor type ( git_target_t ), allocatable :: git contains !> Print information on this instance procedure :: info end type dependency_config_t","tags":"","loc":"type/dependency_config_t.html"},{"title":"executable_config_t – Fortran-lang/fpm ","text":"type, public :: executable_config_t Configuation meta data for an executable Contents Variables dependency link main name source_dir Type-Bound Procedures info Source Code executable_config_t Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( executable_config_t ), intent(in) :: self Instance of the executable configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: executable_config_t !> Name of the resulting executable character ( len = :), allocatable :: name !> Source directory for collecting the executable character ( len = :), allocatable :: source_dir !> Name of the source file declaring the main program character ( len = :), allocatable :: main !> Dependency meta data for this executable type ( dependency_config_t ), allocatable :: dependency (:) !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type executable_config_t","tags":"","loc":"type/executable_config_t.html"},{"title":"package_config_t – Fortran-lang/fpm ","text":"type, public :: package_config_t Package meta data Contents Variables build dependency dev_dependency executable library name test version Type-Bound Procedures info Source Code package_config_t Components Type Visibility Attributes Name Initial type( build_config_t ), public :: build Build configuration data type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data type( dependency_config_t ), public, allocatable :: dev_dependency (:) Development dependency meta data type( executable_config_t ), public, allocatable :: executable (:) Executable meta data type( library_config_t ), public, allocatable :: library Library meta data character(len=:), public, allocatable :: name Name of the package type( test_config_t ), public, allocatable :: test (:) Test meta data type( version_t ), public :: version Package version Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( package_config_t ), intent(in) :: self Instance of the package configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: package_config_t !> Name of the package character ( len = :), allocatable :: name !> Build configuration data type ( build_config_t ) :: build !> Package version type ( version_t ) :: version !> Library meta data type ( library_config_t ), allocatable :: library !> Executable meta data type ( executable_config_t ), allocatable :: executable (:) !> Dependency meta data type ( dependency_config_t ), allocatable :: dependency (:) !> Development dependency meta data type ( dependency_config_t ), allocatable :: dev_dependency (:) !> Test meta data type ( test_config_t ), allocatable :: test (:) contains !> Print information on this instance procedure :: info end type package_config_t","tags":"","loc":"type/package_config_t.html"},{"title":"library_config_t – Fortran-lang/fpm ","text":"type, public :: library_config_t Configuration meta data for a library Contents Variables build_script source_dir Type-Bound Procedures info Source Code library_config_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_script Alternative build script to be invoked character(len=:), public, allocatable :: source_dir Source path prefix Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( library_config_t ), intent(in) :: self Instance of the library configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: library_config_t !> Source path prefix character ( len = :), allocatable :: source_dir !> Alternative build script to be invoked character ( len = :), allocatable :: build_script contains !> Print information on this instance procedure :: info end type library_config_t","tags":"","loc":"type/library_config_t.html"},{"title":"basename – Fortran-lang/fpm","text":"public function basename(path, suffix) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path logical, intent(in), optional :: suffix Return Value character(len=:),\n  allocatable Contents Variables file_parts with_suffix Source Code basename Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_parts (:) logical, public :: with_suffix Source Code function basename ( path , suffix ) result ( base ) ! Extract filename from path with/without suffix ! character ( * ), intent ( In ) :: path logical , intent ( in ), optional :: suffix character (:), allocatable :: base character (:), allocatable :: file_parts (:) logical :: with_suffix if (. not . present ( suffix )) then with_suffix = . true . else with_suffix = suffix end if if ( with_suffix ) then call split ( path , file_parts , delimiters = '\\/' ) base = trim ( file_parts ( size ( file_parts ))) else call split ( path , file_parts , delimiters = '\\/.' ) base = trim ( file_parts ( size ( file_parts ) - 1 )) end if end function basename","tags":"","loc":"proc/basename.html"},{"title":"canon_path – Fortran-lang/fpm","text":"public function canon_path(path) result(canon) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables i iback j nixpath temp Source Code canon_path Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iback integer, public :: j character(len=len(path)), public :: nixpath character(len=len(path)), public :: temp Source Code function canon_path ( path ) result ( canon ) ! Canonicalize path for comparison !  Handles path string redundancies !  Does not test existence of path ! ! To be replaced by realpath/_fullname in stdlib_os ! character ( * ), intent ( in ) :: path character (:), allocatable :: canon integer :: i , j integer :: iback character ( len ( path )) :: nixpath character ( len ( path )) :: temp nixpath = unix_path ( path ) j = 1 do i = 1 , len ( nixpath ) ! Skip back to last directory for '/../' if ( i > 4 ) then if ( nixpath ( i - 3 : i ) == '/../' ) then iback = scan ( nixpath ( 1 : i - 4 ), '/' , back = . true .) if ( iback > 0 ) then j = iback + 1 cycle end if end if end if if ( i > 1 . and . j > 1 ) then ! Ignore current directory reference if ( nixpath ( i - 1 : i ) == './' ) then j = j - 1 cycle end if ! Ignore repeated separators if ( nixpath ( i - 1 : i ) == '//' ) then cycle end if ! Do NOT include trailing slash if ( i == len ( nixpath ) . and . nixpath ( i : i ) == '/' ) then cycle end if end if temp ( j : j ) = nixpath ( i : i ) j = j + 1 end do canon = temp ( 1 : j - 1 ) end function canon_path","tags":"","loc":"proc/canon_path.html"},{"title":"dirname – Fortran-lang/fpm","text":"public function dirname(path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables file_parts Source Code dirname Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_parts (:) Source Code function dirname ( path ) result ( dir ) ! Extract dirname from path ! character ( * ), intent ( in ) :: path character (:), allocatable :: dir character (:), allocatable :: file_parts (:) dir = path ( 1 : scan ( path , ' / \\' , back = . true .)) end function dirname","tags":"","loc":"proc/dirname.html"},{"title":"exists – Fortran-lang/fpm","text":"public function exists(filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Contents None","tags":"","loc":"proc/exists.html"},{"title":"get_temp_filename – Fortran-lang/fpm","text":"public function get_temp_filename() result(tempfile) Uses iso_c_binding Arguments None Return Value character(len=:),\n  allocatable Contents Variables c_tempfile c_tempfile_ptr Interfaces c_free c_tempnam Source Code get_temp_filename Variables Type Visibility Attributes Name Initial character(len=1), public, pointer :: c_tempfile (:) type(c_ptr), public :: c_tempfile_ptr Interfaces interface subroutine c_free(ptr) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr interface function c_tempnam(dir, pfx) result(tmp) bind(c,name=\"tempnam\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: dir type(c_ptr), intent(in), value :: pfx Return Value type(c_ptr) Source Code function get_temp_filename () result ( tempfile ) ! Get a unused temporary filename !  Calls posix 'tempnam' - not recommended, but !   we have no security concerns for this application !   and use here is temporary. ! Works with MinGW ! use iso_c_binding , only : c_ptr , C_NULL_PTR , c_f_pointer character (:), allocatable :: tempfile type ( c_ptr ) :: c_tempfile_ptr character ( len = 1 ), pointer :: c_tempfile (:) interface function c_tempnam ( dir , pfx ) result ( tmp ) bind ( c , name = \"tempnam\" ) import type ( c_ptr ), intent ( in ), value :: dir type ( c_ptr ), intent ( in ), value :: pfx type ( c_ptr ) :: tmp end function c_tempnam subroutine c_free ( ptr ) BIND ( C , name = \"free\" ) import type ( c_ptr ), value :: ptr end subroutine c_free end interface c_tempfile_ptr = c_tempnam ( C_NULL_PTR , C_NULL_PTR ) call c_f_pointer ( c_tempfile_ptr , c_tempfile ,[ LINE_BUFFER_LEN ]) tempfile = f_string ( c_tempfile ) call c_free ( c_tempfile_ptr ) end function get_temp_filename","tags":"","loc":"proc/get_temp_filename.html"},{"title":"is_dir – Fortran-lang/fpm","text":"public function is_dir(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Return Value logical Contents Variables stat Source Code is_dir Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code logical function is_dir ( dir ) character ( * ), intent ( in ) :: dir integer :: stat select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( \"test -d \" // dir , exitstat = stat ) case ( OS_WINDOWS ) call execute_command_line ( 'cmd /c \"if not exist ' // windows_path ( dir ) // '\\ exit /B 1\"' , exitstat = stat ) end select is_dir = ( stat == 0 ) end function is_dir","tags":"","loc":"proc/is_dir.html"},{"title":"join_path – Fortran-lang/fpm","text":"public function join_path(a1, a2, a3, a4, a5) result(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 character(len=*), intent(in), optional :: a3 character(len=*), intent(in), optional :: a4 character(len=*), intent(in), optional :: a5 Return Value character(len=:),\n  allocatable Contents Variables filesep Source Code join_path Variables Type Visibility Attributes Name Initial character(len=1), public :: filesep Source Code function join_path ( a1 , a2 , a3 , a4 , a5 ) result ( path ) ! Construct path by joining strings with os file separator ! character ( len =* ), intent ( in ) :: a1 , a2 character ( len =* ), intent ( in ), optional :: a3 , a4 , a5 character ( len = :), allocatable :: path character ( len = 1 ) :: filesep select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) filesep = '/' case ( OS_WINDOWS ) filesep = '\\' end select path = a1 // filesep // a2 if ( present ( a3 )) then path = path // filesep // a3 else return end if if ( present ( a4 )) then path = path // filesep // a4 else return end if if ( present ( a5 )) then path = path // filesep // a5 else return end if end function join_path","tags":"","loc":"proc/join_path.html"},{"title":"number_of_rows – Fortran-lang/fpm","text":"public function number_of_rows(s) result(nrows) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value integer Contents Variables ios r Source Code number_of_rows Variables Type Visibility Attributes Name Initial integer, public :: ios character(len=100), public :: r Source Code integer function number_of_rows ( s ) result ( nrows ) ! determine number or rows integer , intent ( in ) :: s integer :: ios character ( len = 100 ) :: r rewind ( s ) nrows = 0 do read ( s , '(A)' , iostat = ios ) r if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) end function number_of_rows","tags":"","loc":"proc/number_of_rows.html"},{"title":"read_lines – Fortran-lang/fpm","text":"public function read_lines(fh) result(lines) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh Return Value type( string_t ),\n  allocatable,(:) Contents Variables i line_buffer Source Code read_lines Variables Type Visibility Attributes Name Initial integer, public :: i character(len=LINE_BUFFER_LEN), public :: line_buffer Source Code function read_lines ( fh ) result ( lines ) integer , intent ( in ) :: fh type ( string_t ), allocatable :: lines (:) integer :: i character ( LINE_BUFFER_LEN ) :: line_buffer allocate ( lines ( number_of_rows ( fh ))) do i = 1 , size ( lines ) read ( fh , '(A)' ) line_buffer lines ( i )% s = trim ( line_buffer ) end do end function read_lines","tags":"","loc":"proc/read_lines.html"},{"title":"windows_path – Fortran-lang/fpm","text":"public function windows_path(path) result(winpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables idx Source Code windows_path Variables Type Visibility Attributes Name Initial integer, public :: idx Source Code function windows_path ( path ) result ( winpath ) ! Replace file system separators for windows ! character ( * ), intent ( in ) :: path character (:), allocatable :: winpath integer :: idx winpath = path idx = index ( winpath , '/' ) do while ( idx > 0 ) winpath ( idx : idx ) = '\\' idx = index(winpath,' / ' ) end do end function windows_path","tags":"","loc":"proc/windows_path.html"},{"title":"list_files – Fortran-lang/fpm","text":"public recursive subroutine list_files(dir, files, recurse) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir type( string_t ), intent(out), allocatable :: files (:) logical, intent(in), optional :: recurse Contents Variables dir_files fh i stat sub_dir_files temp_file Source Code list_files Variables Type Visibility Attributes Name Initial type( string_t ), public, allocatable :: dir_files (:) integer, public :: fh integer, public :: i integer, public :: stat type( string_t ), public, allocatable :: sub_dir_files (:) character(len=:), public, allocatable :: temp_file Source Code recursive subroutine list_files ( dir , files , recurse ) ! Get file & directory names in directory `dir`. ! !  - File/directory names return are relative to cwd, ie. preprended with `dir` !  - Includes files starting with `.` except current directory and parent directory ! character ( len =* ), intent ( in ) :: dir type ( string_t ), allocatable , intent ( out ) :: files (:) logical , intent ( in ), optional :: recurse integer :: stat , fh , i character (:), allocatable :: temp_file type ( string_t ), allocatable :: dir_files (:) type ( string_t ), allocatable :: sub_dir_files (:) if (. not . is_dir ( dir )) then allocate ( files ( 0 )) return end if allocate ( temp_file , source = get_temp_filename ()) select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( 'ls -A ' // dir // ' > ' // temp_file , & exitstat = stat ) case ( OS_WINDOWS ) call execute_command_line ( 'dir /b ' // windows_path ( dir ) // ' > ' // temp_file , & exitstat = stat ) end select if ( stat /= 0 ) then print * , 'execute_command_line() failed' error stop end if open ( newunit = fh , file = temp_file , status = 'old' ) files = read_lines ( fh ) close ( fh , status = \"delete\" ) do i = 1 , size ( files ) files ( i )% s = join_path ( dir , files ( i )% s ) end do if ( present ( recurse )) then if ( recurse ) then allocate ( sub_dir_files ( 0 )) do i = 1 , size ( files ) if ( is_dir ( files ( i )% s )) then call list_files ( files ( i )% s , dir_files , recurse = . true .) sub_dir_files = [ sub_dir_files , dir_files ] end if end do files = [ files , sub_dir_files ] end if end if end subroutine list_files","tags":"","loc":"proc/list_files.html"},{"title":"mkdir – Fortran-lang/fpm","text":"public subroutine mkdir(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Contents Variables stat Source Code mkdir Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine mkdir ( dir ) character ( len =* ), intent ( in ) :: dir integer :: stat if ( is_dir ( dir )) return select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( 'mkdir -p ' // dir , exitstat = stat ) write ( * , '(\" + \",2a)' ) 'mkdir -p ' // dir case ( OS_WINDOWS ) call execute_command_line ( \"mkdir \" // windows_path ( dir ), exitstat = stat ) write ( * , '(\" + \",2a)' ) 'mkdir ' // windows_path ( dir ) end select if ( stat /= 0 ) then print * , 'execute_command_line() failed' error stop end if end subroutine mkdir","tags":"","loc":"proc/mkdir.html"},{"title":"f_string – Fortran-lang/fpm","text":"public function f_string(c_string) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c_string (:) Return Value character(len=:),\n  allocatable Contents Variables i n Source Code f_string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n Source Code function f_string ( c_string ) use iso_c_binding character ( len = 1 ), intent ( in ) :: c_string (:) character (:), allocatable :: f_string integer :: i , n i = 0 do while ( c_string ( i + 1 ) /= C_NULL_CHAR ) i = i + 1 end do n = i allocate ( character ( n ) :: f_string ) do i = 1 , n f_string ( i : i ) = c_string ( i ) end do end function f_string","tags":"","loc":"proc/f_string.html"},{"title":"lower – Fortran-lang/fpm","text":"public pure elemental function lower(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Contents Variables i ibegin iend Source Code lower Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ibegin integer, public :: iend Source Code elemental pure function lower ( str , begin , end ) result ( string ) ! Changes a string to lowercase over specified range ! Author: John S. Urban ! License: Public Domain character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower","tags":"","loc":"proc/lower.html"},{"title":"str_ends_with – Fortran-lang/fpm","text":"public function str_ends_with(s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e Return Value logical Contents Variables n1 n2 Source Code str_ends_with Variables Type Visibility Attributes Name Initial integer, public :: n1 integer, public :: n2 Source Code logical function str_ends_with ( s , e ) result ( r ) character ( * ), intent ( in ) :: s , e integer :: n1 , n2 n1 = len ( s ) - len ( e ) + 1 n2 = len ( s ) if ( n1 < 1 ) then r = . false . else r = ( s ( n1 : n2 ) == e ) end if end function str_ends_with","tags":"","loc":"proc/str_ends_with.html"},{"title":"string_array_contains – Fortran-lang/fpm","text":"public function string_array_contains(search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical Contents Variables i Source Code string_array_contains Variables Type Visibility Attributes Name Initial integer, public :: i Source Code logical function string_array_contains ( search_string , array ) ! Check if array of string_t contains a particular string ! character ( * ), intent ( in ) :: search_string type ( string_t ), intent ( in ) :: array (:) integer :: i string_array_contains = any ([( array ( i )% s == search_string , & i = 1 , size ( array ))]) end function string_array_contains","tags":"","loc":"proc/string_array_contains.html"},{"title":"split – Fortran-lang/fpm","text":"public subroutine split(input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Contents Variables dlim i10 i20 i30 ibegin icol icount idlim ifound ii iiii ilen imax inotnull ireturn iterm n nlls ordr Source Code split Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlim integer, public :: i10 integer, public :: i20 integer, public :: i30 integer, public, allocatable :: ibegin (:) integer, public :: icol integer, public :: icount integer, public :: idlim integer, public :: ifound integer, public :: ii integer, public :: iiii integer, public :: ilen integer, public :: imax integer, public :: inotnull integer, public :: ireturn integer, public, allocatable :: iterm (:) integer, public :: n character(len=:), public, allocatable :: nlls character(len=:), public, allocatable :: ordr Source Code subroutine split ( input_line , array , delimiters , order , nulls ) ! parse string on delimiter characters and store tokens into an allocatable array\" ! Author: John S. Urban ! License: Public Domain !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found select case ( ilen ) case (: 0 ) ! command was totally blank case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE end select select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split","tags":"","loc":"proc/split.html"},{"title":"operator(.in.) – Fortran-lang/fpm","text":"public interface operator(.in.) Contents Module Procedures string_array_contains Module Procedures public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical","tags":"","loc":"interface/operator(.in.).html"},{"title":"parse_c_source – Fortran-lang/fpm","text":"public function parse_c_source(c_filename, error) result(c_source) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) Contents Variables fh file_lines i n_include pass stat Source Code parse_c_source Variables Type Visibility Attributes Name Initial integer, public :: fh type( string_t ), public, allocatable :: file_lines (:) integer, public :: i integer, public :: n_include integer, public :: pass integer, public :: stat Source Code function parse_c_source ( c_filename , error ) result ( c_source ) ! Rudimentary scan of c source file and !  extract include dependencies ! character ( * ), intent ( in ) :: c_filename type ( srcfile_t ) :: c_source type ( error_t ), allocatable , intent ( out ) :: error integer :: fh , n_include , i , pass , stat type ( string_t ), allocatable :: file_lines (:) c_source % file_name = c_filename if ( str_ends_with ( lower ( c_filename ), \".c\" )) then c_source % unit_type = FPM_UNIT_CSOURCE elseif ( str_ends_with ( lower ( c_filename ), \".h\" )) then c_source % unit_type = FPM_UNIT_CHEADER end if allocate ( c_source % modules_used ( 0 )) allocate ( c_source % modules_provided ( 0 )) open ( newunit = fh , file = c_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) do pass = 1 , 2 n_include = 0 file_loop : do i = 1 , size ( file_lines ) ! Process 'INCLUDE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), '#include' ) == 1 . and . & index ( file_lines ( i )% s , '\"' ) > 0 ) then n_include = n_include + 1 if ( pass == 2 ) then c_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , c_filename , & 'unable to get c include file' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '\"' )) return end if end if end if end do file_loop if ( pass == 1 ) then allocate ( c_source % include_dependencies ( n_include )) end if end do end function parse_c_source","tags":"","loc":"proc/parse_c_source.html"},{"title":"parse_f_source – Fortran-lang/fpm","text":"public function parse_f_source(f_filename, error) result(f_source) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: f_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) Contents Variables fh file_lines i ic j mod_name n_include n_mod n_use pass stat temp_string Functions validate_name Source Code parse_f_source Variables Type Visibility Attributes Name Initial integer, public :: fh type( string_t ), public, allocatable :: file_lines (:) integer, public :: i integer, public :: ic integer, public :: j character(len=:), public, allocatable :: mod_name integer, public :: n_include integer, public :: n_mod integer, public :: n_use integer, public :: pass integer, public :: stat character(len=:), public, allocatable :: temp_string Functions function validate_name(name) result(valid) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value logical Source Code function parse_f_source ( f_filename , error ) result ( f_source ) ! Rudimentary scan of Fortran source file and !  extract program unit name and use/include dependencies ! character ( * ), intent ( in ) :: f_filename type ( srcfile_t ) :: f_source type ( error_t ), allocatable , intent ( out ) :: error integer :: stat integer :: fh , n_use , n_include , n_mod , i , j , ic , pass type ( string_t ), allocatable :: file_lines (:) character (:), allocatable :: temp_string , mod_name f_source % file_name = f_filename open ( newunit = fh , file = f_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) do pass = 1 , 2 n_use = 0 n_include = 0 n_mod = 0 file_loop : do i = 1 , size ( file_lines ) ! Skip lines that are continued: not statements if ( i > 1 ) then ic = index ( file_lines ( i - 1 )% s , '!' ) if ( ic < 1 ) then ic = len ( file_lines ( i - 1 )% s ) end if temp_string = trim ( file_lines ( i - 1 )% s ( 1 : ic )) if ( len ( temp_string ) > 0 . and . index ( temp_string , '&' ) == len ( temp_string )) then cycle end if end if ! Process 'USE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'use ' ) == 1 . or . & index ( adjustl ( lower ( file_lines ( i )% s )), 'use::' ) == 1 ) then if ( index ( file_lines ( i )% s , '::' ) > 0 ) then temp_string = split_n ( file_lines ( i )% s , delims = ':' , n = 2 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '::' )) return end if mod_name = split_n ( temp_string , delims = ' ,' , n = 1 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) else mod_name = split_n ( file_lines ( i )% s , n = 2 , delims = ' ,' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) end if if (. not . validate_name ( mod_name )) then cycle end if if ( any ([( index ( mod_name , trim ( INTRINSIC_MODULE_NAMES ( j ))) > 0 , & j = 1 , size ( INTRINSIC_MODULE_NAMES ))])) then cycle end if n_use = n_use + 1 if ( pass == 2 ) then f_source % modules_used ( n_use )% s = mod_name end if end if ! Process 'INCLUDE' statements ic = index ( adjustl ( lower ( file_lines ( i )% s )), 'include' ) if ( ic == 1 ) then ic = index ( lower ( file_lines ( i )% s ), 'include' ) if ( index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), '\"' ) == 1 . or . & index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), \"'\" ) == 1 ) then n_include = n_include + 1 if ( pass == 2 ) then f_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = \"'\" // '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find include file name' , i , & file_lines ( i )% s ) return end if end if end if end if ! Extract name of module if is module if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'module ' ) == 1 ) then mod_name = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find module name' , i , & file_lines ( i )% s ) return end if if ( mod_name == 'procedure' . or . & mod_name == 'subroutine' . or . & mod_name == 'function' ) then ! Ignore these cases cycle end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for module' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 if ( pass == 2 ) then f_source % modules_provided ( n_mod ) = string_t ( mod_name ) end if f_source % unit_type = FPM_UNIT_MODULE end if ! Extract name of submodule if is submodule if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'submodule' ) == 1 ) then mod_name = split_n ( file_lines ( i )% s , n = 3 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule name' , i , & file_lines ( i )% s ) return end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 temp_string = split_n ( file_lines ( i )% s , n = 2 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule ancestry' , i , & file_lines ( i )% s ) return end if f_source % unit_type = FPM_UNIT_SUBMODULE n_use = n_use + 1 if ( pass == 2 ) then if ( index ( temp_string , ':' ) > 0 ) then temp_string = temp_string ( index ( temp_string , ':' ) + 1 :) end if if (. not . validate_name ( temp_string )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule parent' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , temp_string )) return end if f_source % modules_used ( n_use )% s = lower ( temp_string ) f_source % modules_provided ( n_mod )% s = lower ( mod_name ) end if end if ! Detect if contains a program !  (no modules allowed after program def) if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'program' ) == 1 ) then f_source % unit_type = FPM_UNIT_PROGRAM end if end do file_loop ! Default to subprogram unit type if ( f_source % unit_type == FPM_UNIT_UNKNOWN ) then f_source % unit_type = FPM_UNIT_SUBPROGRAM end if if ( pass == 1 ) then allocate ( f_source % modules_used ( n_use )) allocate ( f_source % include_dependencies ( n_include )) allocate ( f_source % modules_provided ( n_mod )) end if end do contains function validate_name ( name ) result ( valid ) character ( * ), intent ( in ) :: name logical :: valid integer :: i if ( len_trim ( name ) < 1 ) then valid = . false . return end if if ( lower ( name ( 1 : 1 )) < 'a' . or . & lower ( name ( 1 : 1 )) > 'z' ) then valid = . false . return end if do i = 1 , len ( name ) if (. not .( & ( name ( i : i ) >= '0' . and . name ( i : i ) <= '9' ). or . & ( lower ( name ( i : i )) >= 'a' . and . lower ( name ( i : i )) <= 'z' ). or . & name ( i : i ) == '_' ) ) then valid = . false . return end if end do valid = . true . return end function validate_name end function parse_f_source","tags":"","loc":"proc/parse_f_source.html"},{"title":"add_executable_sources – Fortran-lang/fpm","text":"public subroutine add_executable_sources(sources, executables, scope, auto_discover, error) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) class( executable_config_t ), intent(in) :: executables (:) integer, intent(in) :: scope logical, intent(in) :: auto_discover type( error_t ), intent(out), allocatable :: error Contents Variables exe_dirs exe_source i j Source Code add_executable_sources Variables Type Visibility Attributes Name Initial type( string_t ), public, allocatable :: exe_dirs (:) type( srcfile_t ), public :: exe_source integer, public :: i integer, public :: j Source Code subroutine add_executable_sources ( sources , executables , scope , auto_discover , error ) ! Include sources from any directories specified !  in [[executable]] entries and apply any customisations ! type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) class ( executable_config_t ), intent ( in ) :: executables (:) integer , intent ( in ) :: scope logical , intent ( in ) :: auto_discover type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j type ( string_t ), allocatable :: exe_dirs (:) type ( srcfile_t ) :: exe_source call get_executable_source_dirs ( exe_dirs , executables ) do i = 1 , size ( exe_dirs ) call add_sources_from_dir ( sources , exe_dirs ( i )% s , scope , & with_executables = auto_discover , recurse = . false ., error = error ) if ( allocated ( error )) then return end if end do exe_loop : do i = 1 , size ( executables ) ! Check if executable already discovered automatically !  and apply any overrides do j = 1 , size ( sources ) if ( basename ( sources ( j )% file_name , suffix = . true .) == executables ( i )% main . and .& canon_path ( dirname ( sources ( j )% file_name )) == & canon_path ( executables ( i )% source_dir ) ) then sources ( j )% exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if cycle exe_loop end if end do ! Add if not already discovered (auto_discovery off) exe_source = parse_source ( join_path ( executables ( i )% source_dir , executables ( i )% main ), error ) exe_source % exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if exe_source % unit_scope = scope if ( allocated ( error )) return if (. not . allocated ( sources )) then sources = [ exe_source ] else sources = [ sources , exe_source ] end if end do exe_loop end subroutine add_executable_sources","tags":"","loc":"proc/add_executable_sources.html"},{"title":"add_sources_from_dir – Fortran-lang/fpm","text":"public subroutine add_sources_from_dir(sources, directory, scope, with_executables, recurse, error) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) character(len=*), intent(in) :: directory integer, intent(in) :: scope logical, intent(in), optional :: with_executables logical, intent(in), optional :: recurse type( error_t ), intent(out), allocatable :: error Contents Variables dir_sources exclude_source existing_src_files file_names i is_source src_file_names Source Code add_sources_from_dir Variables Type Visibility Attributes Name Initial type( srcfile_t ), public, allocatable :: dir_sources (:) logical, public, allocatable :: exclude_source (:) type( string_t ), public, allocatable :: existing_src_files (:) type( string_t ), public, allocatable :: file_names (:) integer, public :: i logical, public, allocatable :: is_source (:) type( string_t ), public, allocatable :: src_file_names (:) Source Code subroutine add_sources_from_dir ( sources , directory , scope , with_executables , recurse , error ) ! Enumerate sources in a directory ! type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) character ( * ), intent ( in ) :: directory integer , intent ( in ) :: scope logical , intent ( in ), optional :: with_executables logical , intent ( in ), optional :: recurse type ( error_t ), allocatable , intent ( out ) :: error integer :: i logical , allocatable :: is_source (:), exclude_source (:) type ( string_t ), allocatable :: file_names (:) type ( string_t ), allocatable :: src_file_names (:) type ( string_t ), allocatable :: existing_src_files (:) type ( srcfile_t ), allocatable :: dir_sources (:) ! Scan directory for sources call list_files ( directory , file_names , recurse = merge ( recurse ,. true ., present ( recurse ))) if ( allocated ( sources )) then allocate ( existing_src_files ( size ( sources ))) do i = 1 , size ( sources ) existing_src_files ( i )% s = canon_path ( sources ( i )% file_name ) end do else allocate ( existing_src_files ( 0 )) end if is_source = [(. not .( canon_path ( file_names ( i )% s ) . in . existing_src_files ) . and . & ( str_ends_with ( lower ( file_names ( i )% s ), \".f90\" ) . or . & str_ends_with ( lower ( file_names ( i )% s ), \".c\" ) . or . & str_ends_with ( lower ( file_names ( i )% s ), \".h\" ) ), i = 1 , size ( file_names ))] src_file_names = pack ( file_names , is_source ) allocate ( dir_sources ( size ( src_file_names ))) allocate ( exclude_source ( size ( src_file_names ))) do i = 1 , size ( src_file_names ) dir_sources ( i ) = parse_source ( src_file_names ( i )% s , error ) if ( allocated ( error )) return dir_sources ( i )% unit_scope = scope ! Exclude executables unless specified otherwise exclude_source ( i ) = ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM ) if ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM . and . & & present ( with_executables )) then if ( with_executables ) then exclude_source ( i ) = . false . end if end if end do if (. not . allocated ( sources )) then sources = pack ( dir_sources ,. not . exclude_source ) else sources = [ sources , pack ( dir_sources ,. not . exclude_source )] end if end subroutine add_sources_from_dir","tags":"","loc":"proc/add_sources_from_dir.html"},{"title":"get_command_line_settings – Fortran-lang/fpm","text":"public subroutine get_command_line_settings(cmd_settings) ! canon_path is not converting “.”, etc. Arguments Type Intent Optional Attributes Name class( fpm_cmd_settings ), intent(out), allocatable :: cmd_settings Contents Variables cmdarg i widest Subroutines printhelp Source Code get_command_line_settings Variables Type Visibility Attributes Name Initial character(len=4096), public :: cmdarg integer, public :: i integer, public :: widest Subroutines subroutine printhelp(lines) Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: lines (:) Source Code subroutine get_command_line_settings ( cmd_settings ) class ( fpm_cmd_settings ), allocatable , intent ( out ) :: cmd_settings character ( len = 4096 ) :: cmdarg integer :: i integer :: widest call set_help () ! text for --version switch, select case ( get_os_type ()) case ( OS_LINUX ); os_type = \"OS Type:     Linux\" case ( OS_MACOS ); os_type = \"OS Type:     macOS\" case ( OS_WINDOWS ); os_type = \"OS Type:     Windows\" case ( OS_CYGWIN ); os_type = \"OS Type:     Cygwin\" case ( OS_SOLARIS ); os_type = \"OS Type:     Solaris\" case ( OS_FREEBSD ); os_type = \"OS Type:     FreeBSD\" case ( OS_UNKNOWN ); os_type = \"OS Type:     Unknown\" case default ; os_type = \"OS Type:     UNKNOWN\" end select version_text = [ character ( len = 80 ) :: & & 'Version:     0.1.0, Pre-alpha' , & & 'Program:     fpm(1)' , & & 'Description: A Fortran package manager and build system' , & & 'Home Page:   https://github.com/fortran-lang/fpm' , & & 'License:     MIT' , & & os_type ] ! find the subcommand name by looking for first word on command ! not starting with dash cmdarg = '' do i = 1 , command_argument_count () call get_command_argument ( i , cmdarg ) if ( adjustl ( cmdarg ( 1 : 1 )) . ne . '-' ) exit enddo ! now set subcommand-specific help text and process commandline ! arguments. Then call subcommand routine select case ( trim ( cmdarg )) case ( 'run' ) call set_args ( '--list F --release F --' , help_run , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_run_settings :: cmd_settings ) cmd_settings = fpm_run_settings ( name = names , list = lget ( 'list' ), & & release = lget ( 'release' ), args = remaining ) case ( 'build' ) call set_args ( '--release F --list F --' , help_build , version_text ) allocate ( fpm_build_settings :: cmd_settings ) cmd_settings = fpm_build_settings ( release = lget ( 'release' ), & & list = lget ( 'list' ) ) case ( 'new' ) call set_args ( ' --src F --lib F --app F --test F --backfill F' , & & help_new , version_text ) select case ( size ( unnamed )) case ( 1 ) write ( stderr , '(*(g0,/))' ) 'ERROR: directory name required' write ( stderr , '(*(7x,g0,/))' ) & & 'USAGE: fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 1 case ( 2 ) name = trim ( unnamed ( 2 )) case default write ( stderr , '(g0)' ) 'ERROR: only one directory name allowed' write ( stderr , '(7x,g0)' ) & & 'USAGE: fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 2 end select !*! canon_path is not converting \".\", etc. name = canon_path ( name ) if ( . not . is_fortran_name ( basename ( name )) ) then write ( stderr , '(g0)' ) [ character ( len = 72 ) :: & & 'ERROR: the new directory basename must be an allowed ' , & & '       Fortran name. It must be composed of 1 to 63 ASCII' , & & '       characters and start with a letter and be composed' , & & '       entirely of alphanumeric characters [a-zA-Z0-9]' , & & '       and underscores.' ] stop 4 endif allocate ( fpm_new_settings :: cmd_settings ) if ( any ( specified ([ 'src ' , 'lib ' , 'app ' , 'test' ]) ) ) then cmd_settings = fpm_new_settings ( name = name , & & with_executable = lget ( 'app' ), & & with_test = lget ( 'test' ), & & with_lib = any ([ lget ( 'lib' ), lget ( 'src' )]), & & backfill = lget ( 'backfill' ) ) else cmd_settings = fpm_new_settings ( name = name , & & with_executable = . true ., & & with_test = . true ., & & with_lib = . true ., & & backfill = lget ( 'backfill' ) ) endif case ( 'help' ) call set_args ( ' ' , help_help , version_text ) if ( size ( unnamed ). lt . 2 ) then unnamed = [ 'help' , 'fpm ' ] endif widest = 256 allocate ( character ( len = widest ) :: help_text ( 0 )) do i = 2 , size ( unnamed ) select case ( unnamed ( i )) case ( 'build  ' ) help_text = [ character ( len = widest ) :: help_text , help_build ] case ( 'run    ' ) help_text = [ character ( len = widest ) :: help_text , help_run ] case ( 'help   ' ) help_text = [ character ( len = widest ) :: help_text , help_help ] case ( 'test   ' ) help_text = [ character ( len = widest ) :: help_text , help_test ] case ( 'new    ' ) help_text = [ character ( len = widest ) :: help_text , help_new ] case ( 'fpm    ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] case ( 'list   ' ) help_text = [ character ( len = widest ) :: help_text , help_list ] case ( 'version' ) help_text = [ character ( len = widest ) :: help_text , version_text ] case ( 'manual ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] help_text = [ character ( len = widest ) :: help_text , help_new ] help_text = [ character ( len = widest ) :: help_text , help_build ] help_text = [ character ( len = widest ) :: help_text , help_run ] help_text = [ character ( len = widest ) :: help_text , help_test ] help_text = [ character ( len = widest ) :: help_text , help_help ] help_text = [ character ( len = widest ) :: help_text , help_list ] help_text = [ character ( len = widest ) :: help_text , version_text ] case default help_text = [ character ( len = widest ) :: help_text , & & 'ERROR: unknown help topic \"' // trim ( unnamed ( i )) // '\"' ] end select enddo call printhelp ( help_text ) case ( 'install' ) call set_args ( '--release F ' , help_install , version_text ) allocate ( fpm_install_settings :: cmd_settings ) case ( 'list' ) call set_args ( ' --list F' , help_list , version_text ) call printhelp ( help_list_nodash ) if ( lget ( 'list' )) then call printhelp ( help_list_dash ) endif case ( 'test' ) call set_args ( '--list F --release F --' , help_test , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_test_settings :: cmd_settings ) cmd_settings = fpm_test_settings ( name = names , list = lget ( 'list' ), & & release = lget ( 'release' ), args = remaining ) case default call set_args ( ' --list F' , help_fpm , version_text ) ! Note: will not get here if --version or --usage or --help ! is present on commandline help_text = help_usage if ( lget ( 'list' )) then help_text = help_list_dash elseif ( len_trim ( cmdarg ). eq . 0 ) then write ( stdout , '(*(a))' ) 'Fortran Package Manager:' write ( stdout , '(*(a))' ) ' ' call printhelp ( help_list_nodash ) else write ( stderr , '(*(a))' ) 'ERROR: unknown subcommand [' , & & trim ( cmdarg ), ']' call printhelp ( help_list_dash ) endif call printhelp ( help_text ) end select contains subroutine printhelp ( lines ) character ( len = :), intent ( in ), allocatable :: lines (:) write ( stdout , '(g0)' )( trim ( lines ( i )), i = 1 , size ( lines ) ) end subroutine printhelp end subroutine get_command_line_settings","tags":"","loc":"proc/get_command_line_settings.html"},{"title":"build_package – Fortran-lang/fpm","text":"public subroutine build_package(model) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout) :: model Contents Variables base i ilib link_flags linking subdir Source Code build_package Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: base integer, public :: i integer, public :: ilib character(len=:), public, allocatable :: link_flags character(len=:), public, allocatable :: linking character(len=:), public, allocatable :: subdir Source Code subroutine build_package ( model ) type ( fpm_model_t ), intent ( inout ) :: model integer :: i , ilib character (:), allocatable :: base , linking , subdir , link_flags if (. not . exists ( model % output_directory )) then call mkdir ( model % output_directory ) end if if (. not . exists ( join_path ( model % output_directory , model % package_name ))) then call mkdir ( join_path ( model % output_directory , model % package_name )) end if if ( model % targets ( 1 )% ptr % target_type == FPM_TARGET_ARCHIVE ) then linking = \" \" // model % targets ( 1 )% ptr % output_file else linking = \" \" end if linking = linking // \" \" // model % link_flags do i = 1 , size ( model % targets ) call build_target ( model , model % targets ( i )% ptr , linking ) end do end subroutine build_package","tags":"","loc":"proc/build_package.html"},{"title":"get_os_type – Fortran-lang/fpm","text":"public function get_os_type() result(r) Determine the OS type Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN,\n OS_SOLARIS, OS_FREEBSD. At first, the environment variable OS is checked, which is usually\n found on Windows. Then, OSTYPE is read in and compared with common\n names. If this fails too, check the existence of files that can be\n found on specific system types only. Returns OS_UNKNOWN if the operating system cannot be determined. Arguments None Return Value integer Contents Variables file_exists length rc val Source Code get_os_type Variables Type Visibility Attributes Name Initial logical, public :: file_exists integer, public :: length integer, public :: rc character(len=32), public :: val Source Code integer function get_os_type () result ( r ) !! Determine the OS type !! !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN, !! OS_SOLARIS, OS_FREEBSD. !! !! At first, the environment variable `OS` is checked, which is usually !! found on Windows. Then, `OSTYPE` is read in and compared with common !! names. If this fails too, check the existence of files that can be !! found on specific system types only. !! !! Returns OS_UNKNOWN if the operating system cannot be determined. character ( len = 32 ) :: val integer :: length , rc logical :: file_exists r = OS_UNKNOWN ! Check environment variable `OS`. call get_environment_variable ( 'OS' , val , length , rc ) if ( rc == 0 . and . length > 0 . and . index ( val , 'Windows_NT' ) > 0 ) then r = OS_WINDOWS return end if ! Check environment variable `OSTYPE`. call get_environment_variable ( 'OSTYPE' , val , length , rc ) if ( rc == 0 . and . length > 0 ) then ! Linux if ( index ( val , 'linux' ) > 0 ) then r = OS_LINUX return end if ! macOS if ( index ( val , 'darwin' ) > 0 ) then r = OS_MACOS return end if ! Windows, MSYS, MinGW, Git Bash if ( index ( val , 'win' ) > 0 . or . index ( val , 'msys' ) > 0 ) then r = OS_WINDOWS return end if ! Cygwin if ( index ( val , 'cygwin' ) > 0 ) then r = OS_CYGWIN return end if ! Solaris, OpenIndiana, ... if ( index ( val , 'SunOS' ) > 0 . or . index ( val , 'solaris' ) > 0 ) then r = OS_SOLARIS return end if ! FreeBSD if ( index ( val , 'FreeBSD' ) > 0 . or . index ( val , 'freebsd' ) > 0 ) then r = OS_FREEBSD return end if end if ! Linux inquire ( file = '/etc/os-release' , exist = file_exists ) if ( file_exists ) then r = OS_LINUX return end if ! macOS inquire ( file = '/usr/bin/sw_vers' , exist = file_exists ) if ( file_exists ) then r = OS_MACOS return end if ! FreeBSD inquire ( file = '/bin/freebsd-version' , exist = file_exists ) if ( file_exists ) then r = OS_FREEBSD return end if end function get_os_type","tags":"","loc":"proc/get_os_type.html"},{"title":"run – Fortran-lang/fpm","text":"public subroutine run(cmd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd Contents Variables stat Source Code run Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine run ( cmd ) character ( len =* ), intent ( in ) :: cmd integer :: stat print * , '+ ' , cmd call execute_command_line ( cmd , exitstat = stat ) if ( stat /= 0 ) then print * , 'Command failed' error stop end if end subroutine run","tags":"","loc":"proc/run.html"},{"title":"find_module_dependency – Fortran-lang/fpm","text":"public function find_module_dependency(targets, module_name, include_dir) result(target_ptr) Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(in), target :: targets (:) character(len=*), intent(in) :: module_name character(len=*), intent(in), optional :: include_dir Return Value type( build_target_t ),\n  pointer Contents Variables k l Source Code find_module_dependency Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: l Source Code function find_module_dependency ( targets , module_name , include_dir ) result ( target_ptr ) ! Find a module dependency in the library or a dependency library ! ! 'include_dir' specifies an allowable non-library search directory !   (Used for executable dependencies) ! type ( build_target_ptr ), intent ( in ), target :: targets (:) character ( * ), intent ( in ) :: module_name character ( * ), intent ( in ), optional :: include_dir type ( build_target_t ), pointer :: target_ptr integer :: k , l target_ptr => NULL () do k = 1 , size ( targets ) if (. not . allocated ( targets ( k )% ptr % source )) cycle do l = 1 , size ( targets ( k )% ptr % source % modules_provided ) if ( module_name == targets ( k )% ptr % source % modules_provided ( l )% s ) then select case ( targets ( k )% ptr % source % unit_scope ) case ( FPM_SCOPE_LIB , FPM_SCOPE_DEP ) target_ptr => targets ( k )% ptr exit case default if ( present ( include_dir )) then if ( dirname ( targets ( k )% ptr % source % file_name ) == include_dir ) then target_ptr => targets ( k )% ptr exit end if end if end select end if end do end do end function find_module_dependency","tags":"","loc":"proc/find_module_dependency.html"},{"title":"add_dependency – Fortran-lang/fpm","text":"public subroutine add_dependency(target, dependency) Add pointer to dependeny in target%dependencies Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout) :: target type( build_target_t ), intent(in), target :: dependency Contents Source Code add_dependency Source Code subroutine add_dependency ( target , dependency ) type ( build_target_t ), intent ( inout ) :: target type ( build_target_t ) , intent ( in ), target :: dependency target % dependencies = [ target % dependencies , build_target_ptr ( dependency )] end subroutine add_dependency","tags":"","loc":"proc/add_dependency.html"},{"title":"add_target – Fortran-lang/fpm","text":"public subroutine add_target(targets, type, output_file, source, link_libraries) Add new target to target list Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), allocatable :: targets (:) integer, intent(in) :: type character(len=*), intent(in) :: output_file type( srcfile_t ), intent(in), optional :: source type( string_t ), intent(in), optional :: link_libraries (:) Contents Variables i new_target temp Source Code add_target Variables Type Visibility Attributes Name Initial integer, public :: i type( build_target_t ), public, pointer :: new_target type( build_target_ptr ), public, allocatable :: temp (:) Source Code subroutine add_target ( targets , type , output_file , source , link_libraries ) type ( build_target_ptr ), allocatable , intent ( inout ) :: targets (:) integer , intent ( in ) :: type character ( * ), intent ( in ) :: output_file type ( srcfile_t ), intent ( in ), optional :: source type ( string_t ), intent ( in ), optional :: link_libraries (:) integer :: i type ( build_target_ptr ), allocatable :: temp (:) type ( build_target_t ), pointer :: new_target if (. not . allocated ( targets )) allocate ( targets ( 0 )) ! Check for duplicate outputs do i = 1 , size ( targets ) if ( targets ( i )% ptr % output_file == output_file ) then write ( * , * ) 'Error while building target list: duplicate output object \"' ,& output_file , '\"' if ( present ( source )) write ( * , * ) ' Source file: \"' , source % file_name , '\"' stop 1 end if end do allocate ( new_target ) new_target % target_type = type new_target % output_file = output_file if ( present ( source )) new_target % source = source if ( present ( link_libraries )) new_target % link_libraries = link_libraries allocate ( new_target % dependencies ( 0 )) targets = [ targets , build_target_ptr ( new_target )] end subroutine add_target","tags":"","loc":"proc/add_target.html"},{"title":"resolve_module_dependencies – Fortran-lang/fpm","text":"public subroutine resolve_module_dependencies(targets, error) Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) type( error_t ), intent(out), allocatable :: error Contents Variables dep i j Source Code resolve_module_dependencies Variables Type Visibility Attributes Name Initial type( build_target_ptr ), public :: dep integer, public :: i integer, public :: j Source Code subroutine resolve_module_dependencies ( targets , error ) ! After enumerating all source files: resolve file dependencies !  by searching on module names ! type ( build_target_ptr ), intent ( inout ), target :: targets (:) type ( error_t ), allocatable , intent ( out ) :: error type ( build_target_ptr ) :: dep integer :: i , j do i = 1 , size ( targets ) if (. not . allocated ( targets ( i )% ptr % source )) cycle do j = 1 , size ( targets ( i )% ptr % source % modules_used ) if ( targets ( i )% ptr % source % modules_used ( j )% s . in . targets ( i )% ptr % source % modules_provided ) then ! Dependency satisfied in same file, skip cycle end if if ( targets ( i )% ptr % source % unit_scope == FPM_SCOPE_APP . OR . & targets ( i )% ptr % source % unit_scope == FPM_SCOPE_TEST ) then dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s , & include_dir = dirname ( targets ( i )% ptr % source % file_name )) else dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s ) end if if (. not . associated ( dep % ptr )) then call fatal_error ( error , & 'Unable to find source for module dependency: \"' // & targets ( i )% ptr % source % modules_used ( j )% s // & '\" used by \"' // targets ( i )% ptr % source % file_name // '\"' ) return end if call add_dependency ( targets ( i )% ptr , dep % ptr ) end do end do end subroutine resolve_module_dependencies","tags":"","loc":"proc/resolve_module_dependencies.html"},{"title":"targets_from_sources – Fortran-lang/fpm","text":"public subroutine targets_from_sources(model, sources) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout), target :: model type( srcfile_t ), intent(in) :: sources (:) Contents Variables dep i with_lib Functions get_object_name Source Code targets_from_sources Variables Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: dep integer, public :: i logical, public :: with_lib Functions function get_object_name(source) result(object_file) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(in) :: source Return Value character(len=:),\n  allocatable Source Code subroutine targets_from_sources ( model , sources ) type ( fpm_model_t ), intent ( inout ), target :: model type ( srcfile_t ), intent ( in ) :: sources (:) integer :: i type ( build_target_t ), pointer :: dep logical :: with_lib with_lib = any ([( sources ( i )% unit_scope == FPM_SCOPE_LIB , i = 1 , size ( sources ))]) if ( with_lib ) call add_target ( model % targets , type = FPM_TARGET_ARCHIVE ,& output_file = join_path ( model % output_directory ,& model % package_name , 'lib' // model % package_name // '.a' )) do i = 1 , size ( sources ) select case ( sources ( i )% unit_type ) case ( FPM_UNIT_MODULE , FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE ) call add_target ( model % targets , source = sources ( i ), & type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i ))) if ( with_lib . and . sources ( i )% unit_scope == FPM_SCOPE_LIB ) then ! Archive depends on object call add_dependency ( model % targets ( 1 )% ptr , model % targets ( size ( model % targets ))% ptr ) end if case ( FPM_UNIT_PROGRAM ) call add_target ( model % targets , type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i )), & source = sources ( i ) & ) if ( sources ( i )% unit_scope == FPM_SCOPE_APP ) then call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , 'app' , sources ( i )% exe_name )) else call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , 'test' , sources ( i )% exe_name )) end if ! Executable depends on object call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( size ( model % targets ) - 1 )% ptr ) if ( with_lib ) then ! Executable depends on library call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( 1 )% ptr ) end if end select end do contains function get_object_name ( source ) result ( object_file ) ! Generate object target path from source name and model params ! ! type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: object_file integer :: i character ( 1 ), parameter :: filesep = '/' character (:), allocatable :: dir object_file = canon_path ( source % file_name ) ! Ignore first directory level object_file = object_file ( index ( object_file , filesep ) + 1 :) ! Convert any remaining directory separators to underscores i = index ( object_file , filesep ) do while ( i > 0 ) object_file ( i : i ) = '_' i = index ( object_file , filesep ) end do select case ( source % unit_scope ) case ( FPM_SCOPE_APP ) object_file = join_path ( model % output_directory , 'app' , object_file ) // '.o' case ( FPM_SCOPE_TEST ) object_file = join_path ( model % output_directory , 'test' , object_file ) // '.o' case default object_file = join_path ( model % output_directory , model % package_name , object_file ) // '.o' end select end function get_object_name end subroutine targets_from_sources","tags":"","loc":"proc/targets_from_sources.html"},{"title":"cmd_build – Fortran-lang/fpm","text":"public subroutine cmd_build(settings) Arguments Type Intent Optional Attributes Name type( fpm_build_settings ), intent(in) :: settings Contents Variables error i model package Variables Type Visibility Attributes Name Initial type( error_t ), public, allocatable :: error integer, public :: i type( fpm_model_t ), public :: model type( package_config_t ), public :: package","tags":"","loc":"proc/cmd_build.html"},{"title":"cmd_install – Fortran-lang/fpm","text":"public subroutine cmd_install(settings) Arguments Type Intent Optional Attributes Name type( fpm_install_settings ), intent(in) :: settings Contents Source Code cmd_install Source Code subroutine cmd_install ( settings ) type ( fpm_install_settings ), intent ( in ) :: settings print * , \"fpm error: 'fpm install' not implemented.\" error stop 8 end subroutine cmd_install","tags":"","loc":"proc/cmd_install.html"},{"title":"cmd_run – Fortran-lang/fpm","text":"public subroutine cmd_run(settings, test) Arguments Type Intent Optional Attributes Name class( fpm_run_settings ), intent(in) :: settings logical, intent(in) :: test Contents Variables LINE_WIDTH col_width error exe_cmd exe_source exe_target executables found i j model nCol package Source Code cmd_run Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_WIDTH = 80 integer, public :: col_width type( error_t ), public, allocatable :: error type( string_t ), public :: exe_cmd type( srcfile_t ), public, pointer :: exe_source type( build_target_t ), public, pointer :: exe_target type( string_t ), public, allocatable :: executables (:) logical, public :: found (size(settings%name)) integer, public :: i integer, public :: j type( fpm_model_t ), public :: model integer, public :: nCol type( package_config_t ), public :: package Source Code subroutine cmd_run ( settings , test ) class ( fpm_run_settings ), intent ( in ) :: settings logical , intent ( in ) :: test integer , parameter :: LINE_WIDTH = 80 integer :: i , j , col_width , nCol logical :: found ( size ( settings % name )) type ( error_t ), allocatable :: error type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( string_t ) :: exe_cmd type ( string_t ), allocatable :: executables (:) type ( build_target_t ), pointer :: exe_target type ( srcfile_t ), pointer :: exe_source call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings % fpm_build_settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if ! Enumerate executable targets to run col_width = - 1 found (:) = . false . allocate ( executables ( 0 )) do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == & merge ( FPM_SCOPE_TEST , FPM_SCOPE_APP , test )) then col_width = max ( col_width , len ( basename ( exe_target % output_file )) + 2 ) if ( size ( settings % name ) == 0 ) then exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] else do j = 1 , size ( settings % name ) if ( trim ( settings % name ( j )) == exe_source % exe_name ) then found ( j ) = . true . exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] end if end do end if end if end if end do ! Check if any apps/tests were found if ( col_width < 0 ) then if ( test ) then write ( stderr , * ) 'No tests to run' else write ( stderr , * ) 'No executables to run' end if stop end if ! Check all names are valid if ( any (. not . found )) then write ( stderr , '(A)' , advance = \"no\" ) 'fpm::run<ERROR> specified names ' do j = 1 , size ( settings % name ) if (. not . found ( j )) write ( stderr , '(A)' , advance = \"no\" ) '\"' // trim ( settings % name ( j )) // '\" ' end do write ( stderr , '(A)' ) 'not found.' write ( stderr , * ) j = 1 nCol = LINE_WIDTH / col_width write ( stderr , * ) 'Available names:' do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == & merge ( FPM_SCOPE_TEST , FPM_SCOPE_APP , test )) then write ( stderr , '(A)' , advance = ( merge ( \"yes\" , \"no \" , modulo ( j , nCol ) == 0 ))) & & [ character ( len = col_width ) :: basename ( exe_target % output_file )] j = j + 1 end if end if end do write ( stderr , * ) stop 1 end if ! NB. To be replaced after incremental rebuild is implemented if (. not . settings % list . and . & any ([(. not . exists ( executables ( i )% s ), i = 1 , size ( executables ))])) then call build_package ( model ) end if do i = 1 , size ( executables ) if ( settings % list ) then write ( stderr , * ) executables ( i )% s else if ( exists ( executables ( i )% s )) then call run ( executables ( i )% s // \" \" // settings % args ) else write ( stderr , * ) 'fpm::run<ERROR>' , executables ( i )% s , ' not found' stop 1 end if end if end do end subroutine cmd_run","tags":"","loc":"proc/cmd_run.html"},{"title":"new_version – Fortran-lang/fpm","text":"public interface new_version Contents Module Procedures new_version_from_string new_version_from_int Module Procedures private subroutine new_version_from_string(self, string, error) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data character(len=*), intent(in) :: string String describing the version information type( error_t ), intent(out), allocatable :: error Error handling private subroutine new_version_from_int(self, num) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data integer, intent(in) :: num (:) Subversion numbers to define version data","tags":"","loc":"interface/new_version.html"},{"title":"fatal_error – Fortran-lang/fpm","text":"public subroutine fatal_error(error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message Contents Source Code fatal_error Source Code subroutine fatal_error ( error , message ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Error message character ( len =* ), intent ( in ) :: message allocate ( error ) error % message = message end subroutine fatal_error","tags":"","loc":"proc/fatal_error.html"},{"title":"file_not_found_error – Fortran-lang/fpm","text":"public subroutine file_not_found_error(error, file_name) Error created when a file is missing or not found Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of the missing file Contents Source Code file_not_found_error Source Code subroutine file_not_found_error ( error , file_name ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of the missing file character ( len =* ), intent ( in ) :: file_name allocate ( error ) error % message = \"'\" // file_name // \"' could not be found, check if the file exists\" end subroutine file_not_found_error","tags":"","loc":"proc/file_not_found_error.html"},{"title":"file_parse_error – Fortran-lang/fpm","text":"public subroutine file_parse_error(error, file_name, message, line_num, line_string, line_col) Error created when file parsing fails Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of file character(len=*), intent(in) :: message Parse error message integer, intent(in), optional :: line_num Line number of parse error character(len=*), intent(in), optional :: line_string Line context string integer, intent(in), optional :: line_col Line context column Contents Variables temp_string Source Code file_parse_error Variables Type Visibility Attributes Name Initial character(len=50), public :: temp_string Source Code subroutine file_parse_error ( error , file_name , message , line_num , & line_string , line_col ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of file character ( len =* ), intent ( in ) :: file_name !> Parse error message character ( len =* ), intent ( in ) :: message !> Line number of parse error integer , intent ( in ), optional :: line_num !> Line context string character ( len =* ), intent ( in ), optional :: line_string !> Line context column integer , intent ( in ), optional :: line_col character ( 50 ) :: temp_string allocate ( error ) error % message = 'Parse error: ' // message // new_line ( 'a' ) error % message = error % message // file_name if ( present ( line_num )) then write ( temp_string , '(I0)' ) line_num error % message = error % message // ':' // trim ( temp_string ) end if if ( present ( line_col )) then if ( line_col > 0 ) then write ( temp_string , '(I0)' ) line_col error % message = error % message // ':' // trim ( temp_string ) end if end if if ( present ( line_string )) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // line_string if ( present ( line_col )) then if ( line_col > 0 ) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // repeat ( ' ' , line_col - 1 ) // '&#94;' end if end if end if end subroutine file_parse_error","tags":"","loc":"proc/file_parse_error.html"},{"title":"syntax_error – Fortran-lang/fpm","text":"public interface syntax_error Alias syntax errors to fatal errors for now Contents Module Procedures fatal_error Module Procedures public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message","tags":"","loc":"interface/syntax_error.html"},{"title":"git_target_branch – Fortran-lang/fpm","text":"public function git_target_branch(url, branch) result(self) Target a branch in the git repository Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: branch Name of the branch of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_branch Source Code function git_target_branch ( url , branch ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Name of the branch of interest character ( len =* ), intent ( in ) :: branch !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % branch self % url = url self % object = branch end function git_target_branch","tags":"","loc":"proc/git_target_branch.html"},{"title":"git_target_default – Fortran-lang/fpm","text":"public function git_target_default(url) result(self) Default target Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository Return Value type( git_target_t ) New git target Contents Source Code git_target_default Source Code function git_target_default ( url ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % default self % url = url end function git_target_default","tags":"","loc":"proc/git_target_default.html"},{"title":"git_target_revision – Fortran-lang/fpm","text":"public function git_target_revision(url, sha1) result(self) Target a specific git revision Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: sha1 Commit hash of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_revision Source Code function git_target_revision ( url , sha1 ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Commit hash of interest character ( len =* ), intent ( in ) :: sha1 !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % revision self % url = url self % object = sha1 end function git_target_revision","tags":"","loc":"proc/git_target_revision.html"},{"title":"git_target_tag – Fortran-lang/fpm","text":"public function git_target_tag(url, tag) result(self) Target a git tag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: tag Tag name of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_tag Source Code function git_target_tag ( url , tag ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Tag name of interest character ( len =* ), intent ( in ) :: tag !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % tag self % url = url self % object = tag end function git_target_tag","tags":"","loc":"proc/git_target_tag.html"},{"title":"checkout – Fortran-lang/fpm","text":"public subroutine checkout(self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error Contents Variables object stat Source Code checkout Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: object git object ref integer, public :: stat Stat for execute_command_line Source Code subroutine checkout ( self , local_path , error ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Error type ( error_t ), allocatable , intent ( out ) :: error !> git object ref character (:), allocatable :: object !> Stat for execute_command_line integer :: stat if ( allocated ( self % object )) then object = self % object else object = 'HEAD' end if call execute_command_line ( \"git init \" // local_path , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while initiating git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" fetch \" // self % url // & \" \" // object , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while fetching git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" checkout -qf FETCH_HEAD\" , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while checking out git repository for remote dependency' ) return end if end subroutine checkout","tags":"","loc":"proc/checkout.html"},{"title":"info – Fortran-lang/fpm","text":"public subroutine info(self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Contents Variables fmt pr Source Code info Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: fmt = '(\"#\", 1x, a, t30, a)' integer, public :: pr Source Code subroutine info ( self , unit , verbosity ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Git target\" if ( allocated ( self % url )) then write ( unit , fmt ) \"- URL\" , self % url end if if ( allocated ( self % object )) then select case ( self % descriptor ) case default write ( unit , fmt ) \"- object\" , self % object case ( git_descriptor % tag ) write ( unit , fmt ) \"- tag\" , self % object case ( git_descriptor % branch ) write ( unit , fmt ) \"- branch\" , self % object case ( git_descriptor % revision ) write ( unit , fmt ) \"- sha1\" , self % object end select end if end subroutine info","tags":"","loc":"proc/info.html"},{"title":"read_package_file – Fortran-lang/fpm","text":"public subroutine read_package_file(table, manifest, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: manifest Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation Contents Variables exist parse_error unit Source Code read_package_file Variables Type Visibility Attributes Name Initial logical, public :: exist type(toml_error), public, allocatable :: parse_error integer, public :: unit Source Code subroutine read_package_file ( table , manifest , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the package configuration file character ( len =* ), intent ( in ) :: manifest !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = manifest , exist = exist ) if (. not . exist ) then call file_not_found_error ( error , manifest ) return end if open ( file = manifest , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_package_file","tags":"","loc":"proc/read_package_file.html"},{"title":"get_value – Fortran-lang/fpm","text":"public interface get_value Contents Module Procedures get_child_value_string_list Module Procedures private subroutine get_child_value_string_list(table, key, list, error) Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table Instance of the TOML data structure character(len=*), intent(in) :: key Key to read from type( string_t ), intent(out), allocatable :: list (:) List of strings to read type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/get_value.html"},{"title":"default_executable – Fortran-lang/fpm","text":"public subroutine default_executable(self, name) Populate executable in case we find the default app directory Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package Contents Source Code default_executable Source Code subroutine default_executable ( self , name ) !> Instance of the executable meta data type ( executable_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"app\" self % main = \"main.f90\" end subroutine default_executable","tags":"","loc":"proc/default_executable.html"},{"title":"default_library – Fortran-lang/fpm","text":"public subroutine default_library(self) Populate library in case we find the default src directory Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library meta data Contents Source Code default_library Source Code subroutine default_library ( self ) !> Instance of the library meta data type ( library_config_t ), intent ( out ) :: self self % source_dir = \"src\" end subroutine default_library","tags":"","loc":"proc/default_library.html"},{"title":"default_test – Fortran-lang/fpm","text":"public subroutine default_test(self, name) Populate test in case we find the default test/ directory Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package Contents Source Code default_test Source Code subroutine default_test ( self , name ) !> Instance of the executable meta data type ( test_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"test\" self % main = \"main.f90\" end subroutine default_test","tags":"","loc":"proc/default_test.html"},{"title":"get_package_data – Fortran-lang/fpm","text":"public subroutine get_package_data(package, file, error, apply_defaults) Obtain package meta data from a configuation file Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: package Parsed package meta data character(len=*), intent(in) :: file Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation logical, intent(in), optional :: apply_defaults Apply package defaults (uses file system operations) Contents Variables table Source Code get_package_data Variables Type Visibility Attributes Name Initial type(toml_table), public, allocatable :: table Source Code subroutine get_package_data ( package , file , error , apply_defaults ) !> Parsed package meta data type ( package_config_t ), intent ( out ) :: package !> Name of the package configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error !> Apply package defaults (uses file system operations) logical , intent ( in ), optional :: apply_defaults type ( toml_table ), allocatable :: table call read_package_file ( table , file , error ) if ( allocated ( error )) return if (. not . allocated ( table )) then call fatal_error ( error , \"Unclassified error while reading: '\" // file // \"'\" ) return end if call new_package ( package , table , error ) if ( present ( apply_defaults )) then if ( apply_defaults ) then call package_defaults ( package , error ) if ( allocated ( error )) return end if end if end subroutine get_package_data","tags":"","loc":"proc/get_package_data.html"},{"title":"new_test – Fortran-lang/fpm","text":"public subroutine new_test(self, table, error) Construct a new test configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the test configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child Source Code new_test Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child Source Code subroutine new_test ( self , table , error ) !> Instance of the test configuration type ( test_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve test name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"test\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_test","tags":"","loc":"proc/new_test.html"},{"title":"new_build_config – Fortran-lang/fpm","text":"public subroutine new_build_config(self, table, error) Construct a new build configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( build_config_t ), intent(out) :: self Instance of the build configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables stat Source Code new_build_config Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine new_build_config ( self , table , error ) !> Instance of the build configuration type ( build_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"auto-executables\" , self % auto_executables , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-executables' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-tests\" , self % auto_tests , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-tests' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_build_config","tags":"","loc":"proc/new_build_config.html"},{"title":"new_dependencies – Fortran-lang/fpm","text":"public subroutine new_dependencies(deps, table, error) Construct new dependency array from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out), allocatable :: deps (:) Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables idep list node stat Source Code new_dependencies Variables Type Visibility Attributes Name Initial integer, public :: idep type(toml_key), public, allocatable :: list (:) type(toml_table), public, pointer :: node integer, public :: stat Source Code subroutine new_dependencies ( deps , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), allocatable , intent ( out ) :: deps (:) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: node type ( toml_key ), allocatable :: list (:) integer :: idep , stat call table % get_keys ( list ) ! An empty table is okay if ( size ( list ) < 1 ) return allocate ( deps ( size ( list ))) do idep = 1 , size ( list ) call get_value ( table , list ( idep )% key , node , stat = stat ) if ( stat /= toml_stat % success ) then call syntax_error ( error , \"Dependency \" // list ( idep )% key // \" must be a table entry\" ) exit end if call new_dependency ( deps ( idep ), node , error ) if ( allocated ( error )) exit end do end subroutine new_dependencies","tags":"","loc":"proc/new_dependencies.html"},{"title":"new_dependency – Fortran-lang/fpm","text":"public subroutine new_dependency(self, table, error) Construct a new dependency configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out) :: self Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables obj url Source Code new_dependency Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: obj character(len=:), public, allocatable :: url Source Code subroutine new_dependency ( self , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: url , obj call check ( table , error ) if ( allocated ( error )) return call table % get_key ( self % name ) call get_value ( table , \"path\" , url ) if ( allocated ( url )) then call move_alloc ( url , self % path ) else call get_value ( table , \"git\" , url ) call get_value ( table , \"tag\" , obj ) if ( allocated ( obj )) then self % git = git_target_tag ( url , obj ) end if if (. not . allocated ( self % git )) then call get_value ( table , \"branch\" , obj ) if ( allocated ( obj )) then self % git = git_target_branch ( url , obj ) end if end if if (. not . allocated ( self % git )) then call get_value ( table , \"rev\" , obj ) if ( allocated ( obj )) then self % git = git_target_revision ( url , obj ) end if end if if (. not . allocated ( self % git )) then self % git = git_target_default ( url ) end if end if end subroutine new_dependency","tags":"","loc":"proc/new_dependency.html"},{"title":"new_executable – Fortran-lang/fpm","text":"public subroutine new_executable(self, table, error) Construct a new executable configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child Source Code new_executable Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child Source Code subroutine new_executable ( self , table , error ) !> Instance of the executable configuration type ( executable_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve executable name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"app\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_executable","tags":"","loc":"proc/new_executable.html"},{"title":"new_package – Fortran-lang/fpm","text":"public subroutine new_package(self, table, error) Construct a new package configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: self Instance of the package configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child children ii nn node stat version Source Code new_package Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child type(toml_array), public, pointer :: children integer, public :: ii integer, public :: nn type(toml_table), public, pointer :: node integer, public :: stat character(len=:), public, allocatable :: version Source Code subroutine new_package ( self , table , error ) !> Instance of the package configuration type ( package_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child , node type ( toml_array ), pointer :: children character ( len = :), allocatable :: version integer :: ii , nn , stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve package name\" ) return end if call get_value ( table , \"build\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for build entry, must be a table\" ) return end if call new_build_config ( self % build , child , error ) if ( allocated ( error )) return call get_value ( table , \"version\" , version , \"0\" ) call new_version ( self % version , version , error ) if ( allocated ( error )) return call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"dev-dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dev_dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"library\" , child , requested = . false .) if ( associated ( child )) then allocate ( self % library ) call new_library ( self % library , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"executable\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % executable ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve executable from array entry\" ) exit end if call new_executable ( self % executable ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end if call get_value ( table , \"test\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % test ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve test from array entry\" ) exit end if call new_test ( self % test ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end if end subroutine new_package","tags":"","loc":"proc/new_package.html"},{"title":"new_library – Fortran-lang/fpm","text":"public subroutine new_library(self, table, error) Construct a new library configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Source Code new_library Source Code subroutine new_library ( self , table , error ) !> Instance of the library configuration type ( library_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"source-dir\" , self % source_dir , \"src\" ) call get_value ( table , \"build-script\" , self % build_script ) end subroutine new_library","tags":"","loc":"proc/new_library.html"},{"title":"cmd_new – Fortran-lang/fpm","text":"public subroutine cmd_new(settings) Arguments Type Intent Optional Attributes Name type( fpm_new_settings ), intent(in) :: settings Contents Variables bname date littlefile message Subroutines filewrite warnwrite Source Code cmd_new Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bname character(len=8), public :: date character(len=:), public, allocatable :: littlefile (:) character(len=:), public, allocatable :: message (:) Subroutines subroutine filewrite(filename, filedata) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: filedata (:) subroutine warnwrite(fname, data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=*), intent(in) :: data (:) Source Code subroutine cmd_new ( settings ) type ( fpm_new_settings ), intent ( in ) :: settings character ( len = :), allocatable :: bname ! baeename of NAME character ( len = :), allocatable :: message (:) character ( len = :), allocatable :: littlefile (:) character ( len = 8 ) :: date call date_and_time ( DATE = date ) if ( exists ( settings % name ) . and . . not . settings % backfill ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists.' write ( stderr , '(*(g0,1x))' )& & '        perhaps you wanted to add --backfill ?' return elseif ( is_dir ( settings % name ) . and . settings % backfill ) then write ( * , '(*(g0))' ) 'backfilling ' , settings % name elseif ( exists ( settings % name ) ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists and is not a directory.' return else ! make new directory call mkdir ( settings % name ) endif ! change to new directory as a test. System dependent potentially call run ( 'cd ' // settings % name ) ! NOTE: need some system routines to handle filenames like \".\" ! like realpath() or getcwd(). bname = basename ( settings % name ) ! create NAME/.gitignore file call warnwrite ( join_path ( settings % name , '.gitignore' ), [ 'build/*' ]) littlefile = [ character ( len = 80 ) :: '# ' // bname , 'My cool new project!' ] ! create NAME/README.md call warnwrite ( join_path ( settings % name , 'README.md' ), littlefile ) ! start building NAME/fpm.toml message = [ character ( len = 80 ) :: & & 'name = \"' // bname // '\"                     ' , & & 'version = \"0.1.0\"                        ' , & & 'license = \"license\"                      ' , & & 'author = \"Jane Doe\"                      ' , & & 'maintainer = \"jane.doe@example.com\"      ' , & & 'copyright = \"' // date ( 1 : 4 ) // ' Jane Doe\"   ' , & & '                                         ' , & & '' ] if ( settings % with_lib ) then call mkdir ( join_path ( settings % name , 'src' ) ) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[library]                            ' , & & 'source-dir=\"src\"                     ' , & & '' ] ! create placeholder module src/bname.f90 littlefile = [ character ( len = 80 ) :: & & 'module ' // bname , & & '  implicit none' , & & '  private' , & & '' , & & '  public :: say_hello' , & & 'contains' , & & '  subroutine say_hello' , & & '    print *, \"Hello, ' // bname // '!\"' , & & '  end subroutine say_hello' , & & 'end module ' // bname ] ! create NAME/src/NAME.f90 call warnwrite ( join_path ( settings % name , 'src' , bname // '.f90' ),& & littlefile ) endif if ( settings % with_test ) then ! create NAME/test or stop call mkdir ( join_path ( settings % name , 'test' )) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[[test]]                             ' , & & 'name=\"runTests\"                      ' , & & 'source-dir=\"test\"                    ' , & & 'main=\"main.f90\"                      ' , & & '' ] littlefile = [ character ( len = 80 ) :: & & 'program main' , & & 'implicit none' , & & '' , & & 'print *, \"Put some tests in here!\"' , & & 'end program main' ] ! create NAME/test/main.f90 call warnwrite ( join_path ( settings % name , 'test/main.f90' ), littlefile ) endif if ( settings % with_executable ) then ! create next section of fpm.toml call mkdir ( join_path ( settings % name , 'app' )) ! create NAME/app or stop message = [ character ( len = 80 ) :: message , & & '[[executable]]                       ' , & & 'name=\"' // bname // '\"                   ' , & & 'source-dir=\"app\"                     ' , & & 'main=\"main.f90\"                      ' , & & '' ] if ( exists ( bname // '/src/' )) then littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  use ' // bname // ', only: say_hello' , & & '  implicit none' , & & '' , & & '  call say_hello()' , & & 'end program main' ] else littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  implicit none' , & & '' , & & '  print *, \"hello from project ' // bname // '\"' , & & 'end program main' ] endif call warnwrite ( join_path ( settings % name , 'app/main.f90' ), littlefile ) endif ! now that built it write NAME/fpm.toml call warnwrite ( join_path ( settings % name , 'fpm.toml' ), message ) ! assumes git(1) is installed and in path call run ( 'git init ' // settings % name ) contains subroutine warnwrite ( fname , data ) character ( len =* ), intent ( in ) :: fname character ( len =* ), intent ( in ) :: data (:) if (. not . exists ( fname )) then call filewrite ( fname , data ) else write ( stderr , '(*(g0,1x))' ) 'INFO:   ' , fname ,& & 'already exists. Not overwriting' endif end subroutine warnwrite subroutine filewrite ( filename , filedata ) ! procedure to write filedata to file filename use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ) :: filedata (:) integer :: lun , i , ios character ( len = 256 ) :: message message = ' ' ios = 0 if ( filename . ne . ' ' ) then open ( file = filename , & & newunit = lun , & & form = 'formatted' , & ! FORM    = FORMATTED | UNFORMATTED & access = 'sequential' , & ! ACCESS  = SEQUENTIAL| DIRECT | STREAM & action = 'write' , & ! ACTION  = READ|WRITE| READWRITE & position = 'rewind' , & ! POSITION= ASIS      | REWIND | APPEND & status = 'new' , & ! STATUS  = NEW| REPLACE| OLD| SCRATCH| UNKNOWN & iostat = ios , & & iomsg = message ) else lun = stdout ios = 0 endif if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 1 endif ! write file do i = 1 , size ( filedata ) write ( lun , '(a)' , iostat = ios , iomsg = message ) trim ( filedata ( i )) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 4 endif enddo ! close file close ( unit = lun , iostat = ios , iomsg = message ) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' ) '*filewrite* error:' , trim ( message ) error stop 2 endif end subroutine filewrite end subroutine cmd_new","tags":"","loc":"proc/cmd_new.html"},{"title":"fpm_filesystem – Fortran-lang/fpm","text":"Uses fpm_environment fpm_strings Contents Functions basename canon_path dirname exists get_temp_filename is_dir join_path number_of_rows read_lines windows_path Subroutines list_files mkdir Functions public function basename (path, suffix) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path logical, intent(in), optional :: suffix Return Value character(len=:),\n  allocatable public function canon_path (path) result(canon) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable public function dirname (path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable public function exists (filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical public function get_temp_filename () result(tempfile) Arguments None Return Value character(len=:),\n  allocatable public function is_dir (dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Return Value logical public function join_path (a1, a2, a3, a4, a5) result(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 character(len=*), intent(in), optional :: a3 character(len=*), intent(in), optional :: a4 character(len=*), intent(in), optional :: a5 Return Value character(len=:),\n  allocatable public function number_of_rows (s) result(nrows) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value integer public function read_lines (fh) result(lines) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh Return Value type( string_t ),\n  allocatable, (:) public function windows_path (path) result(winpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Subroutines public recursive subroutine list_files (dir, files, recurse) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir type( string_t ), intent(out), allocatable :: files (:) logical, intent(in), optional :: recurse public subroutine mkdir (dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir","tags":"","loc":"module/fpm_filesystem.html"},{"title":"fpm_strings – Fortran-lang/fpm","text":"Contents Interfaces operator(.in.) Derived Types string_t Functions f_string lower str_ends_with string_array_contains Subroutines split Interfaces public interface operator(.in.) public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical Derived Types type, public :: string_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s Functions public function f_string (c_string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c_string (:) Return Value character(len=:),\n  allocatable public pure elemental function lower (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) public function str_ends_with (s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e Return Value logical public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical Subroutines public subroutine split (input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls","tags":"","loc":"module/fpm_strings.html"},{"title":"fpm_sources – Fortran-lang/fpm","text":"Uses fpm_error fpm_model fpm_filesystem fpm_strings fpm_manifest_executable Contents Functions parse_c_source parse_f_source Subroutines add_executable_sources add_sources_from_dir Functions public function parse_c_source (c_filename, error) result(c_source) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) public function parse_f_source (f_filename, error) result(f_source) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: f_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) Subroutines public subroutine add_executable_sources (sources, executables, scope, auto_discover, error) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) class( executable_config_t ), intent(in) :: executables (:) integer, intent(in) :: scope logical, intent(in) :: auto_discover type( error_t ), intent(out), allocatable :: error public subroutine add_sources_from_dir (sources, directory, scope, with_executables, recurse, error) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) character(len=*), intent(in) :: directory integer, intent(in) :: scope logical, intent(in), optional :: with_executables logical, intent(in), optional :: recurse type( error_t ), intent(out), allocatable :: error","tags":"","loc":"module/fpm_sources.html"},{"title":"fpm_command_line – Fortran-lang/fpm","text":"Uses fpm_environment M_CLI2 fpm_strings fpm_filesystem iso_fortran_env Contents Derived Types fpm_build_settings fpm_cmd_settings fpm_install_settings fpm_new_settings fpm_run_settings fpm_test_settings Subroutines get_command_line_settings Derived Types type, public, extends( fpm_cmd_settings ) :: fpm_build_settings Components Type Visibility Attributes Name Initial logical, public :: list = .false. logical, public :: release = .false. type, public, abstract :: fpm_cmd_settings type, public, extends( fpm_cmd_settings ) :: fpm_install_settings type, public, extends( fpm_cmd_settings ) :: fpm_new_settings Components Type Visibility Attributes Name Initial logical, public :: backfill = .true. character(len=:), public, allocatable :: name logical, public :: with_executable = .false. logical, public :: with_lib = .true. logical, public :: with_test = .false. type, public, extends( fpm_build_settings ) :: fpm_run_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) logical, public :: release = .false. type, public, extends( fpm_run_settings ) :: fpm_test_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) logical, public :: release = .false. Subroutines public subroutine get_command_line_settings (cmd_settings) ! canon_path is not converting “.”, etc. Arguments Type Intent Optional Attributes Name class( fpm_cmd_settings ), intent(out), allocatable :: cmd_settings","tags":"","loc":"module/fpm_command_line.html"},{"title":"fpm_backend – Fortran-lang/fpm","text":"Uses fpm_environment fpm_filesystem fpm_model fpm_strings Contents Subroutines build_package Subroutines public subroutine build_package (model) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout) :: model","tags":"","loc":"module/fpm_backend.html"},{"title":"fpm_environment – Fortran-lang/fpm","text":"Contents Variables OS_CYGWIN OS_FREEBSD OS_LINUX OS_MACOS OS_SOLARIS OS_UNKNOWN OS_WINDOWS Functions get_os_type Subroutines run Variables Type Visibility Attributes Name Initial integer, public, parameter :: OS_CYGWIN = 4 integer, public, parameter :: OS_FREEBSD = 6 integer, public, parameter :: OS_LINUX = 1 integer, public, parameter :: OS_MACOS = 2 integer, public, parameter :: OS_SOLARIS = 5 integer, public, parameter :: OS_UNKNOWN = 0 integer, public, parameter :: OS_WINDOWS = 3 Functions public function get_os_type () result(r) Determine the OS type Read more… Arguments None Return Value integer Subroutines public subroutine run (cmd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd","tags":"","loc":"module/fpm_environment.html"},{"title":"fpm_model – Fortran-lang/fpm","text":"Uses fpm_strings Contents Variables FPM_SCOPE_APP FPM_SCOPE_DEP FPM_SCOPE_LIB FPM_SCOPE_TEST FPM_SCOPE_UNKNOWN FPM_TARGET_ARCHIVE FPM_TARGET_EXECUTABLE FPM_TARGET_OBJECT FPM_TARGET_UNKNOWN FPM_UNIT_CHEADER FPM_UNIT_CSOURCE FPM_UNIT_MODULE FPM_UNIT_PROGRAM FPM_UNIT_SUBMODULE FPM_UNIT_SUBPROGRAM FPM_UNIT_UNKNOWN Derived Types build_target_ptr build_target_t fpm_model_t srcfile_t Variables Type Visibility Attributes Name Initial integer, public, parameter :: FPM_SCOPE_APP = 3 integer, public, parameter :: FPM_SCOPE_DEP = 2 integer, public, parameter :: FPM_SCOPE_LIB = 1 integer, public, parameter :: FPM_SCOPE_TEST = 4 integer, public, parameter :: FPM_SCOPE_UNKNOWN = -1 integer, public, parameter :: FPM_TARGET_ARCHIVE = 2 integer, public, parameter :: FPM_TARGET_EXECUTABLE = 1 integer, public, parameter :: FPM_TARGET_OBJECT = 3 integer, public, parameter :: FPM_TARGET_UNKNOWN = -1 integer, public, parameter :: FPM_UNIT_CHEADER = 6 integer, public, parameter :: FPM_UNIT_CSOURCE = 5 integer, public, parameter :: FPM_UNIT_MODULE = 2 integer, public, parameter :: FPM_UNIT_PROGRAM = 1 integer, public, parameter :: FPM_UNIT_SUBMODULE = 3 integer, public, parameter :: FPM_UNIT_SUBPROGRAM = 4 integer, public, parameter :: FPM_UNIT_UNKNOWN = -1 Derived Types type, public :: build_target_ptr Components Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: ptr => null() type, public :: build_target_t Components Type Visibility Attributes Name Initial logical, public :: built = .false. type( build_target_ptr ), public, allocatable :: dependencies (:) type( string_t ), public, allocatable :: link_libraries (:) character(len=:), public, allocatable :: output_file type( srcfile_t ), public, allocatable :: source integer, public :: target_type = FPM_TARGET_UNKNOWN logical, public :: touched = .false. type, public :: fpm_model_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fortran_compile_flags character(len=:), public, allocatable :: fortran_compiler character(len=:), public, allocatable :: link_flags type( string_t ), public, allocatable :: link_libraries (:) character(len=:), public, allocatable :: output_directory character(len=:), public, allocatable :: package_name type( srcfile_t ), public, allocatable :: sources (:) type( build_target_ptr ), public, allocatable :: targets (:) type, public :: srcfile_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: exe_name character(len=:), public, allocatable :: file_name type( string_t ), public, allocatable :: include_dependencies (:) logical, public :: is_test = .false. type( string_t ), public, allocatable :: link_libraries (:) type( string_t ), public, allocatable :: modules_provided (:) type( string_t ), public, allocatable :: modules_used (:) integer, public :: unit_scope = FPM_SCOPE_UNKNOWN integer, public :: unit_type = FPM_UNIT_UNKNOWN","tags":"","loc":"module/fpm_model.html"},{"title":"fpm_targets – Fortran-lang/fpm","text":"Uses fpm_error fpm_model fpm_environment fpm_filesystem fpm_strings Contents Functions find_module_dependency Subroutines add_dependency add_target resolve_module_dependencies targets_from_sources Functions public function find_module_dependency (targets, module_name, include_dir) result(target_ptr) Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(in), target :: targets (:) character(len=*), intent(in) :: module_name character(len=*), intent(in), optional :: include_dir Return Value type( build_target_t ),\n  pointer Subroutines public subroutine add_dependency (target, dependency) Add pointer to dependeny in target%dependencies Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout) :: target type( build_target_t ), intent(in), target :: dependency public subroutine add_target (targets, type, output_file, source, link_libraries) Add new target to target list Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), allocatable :: targets (:) integer, intent(in) :: type character(len=*), intent(in) :: output_file type( srcfile_t ), intent(in), optional :: source type( string_t ), intent(in), optional :: link_libraries (:) public subroutine resolve_module_dependencies (targets, error) Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) type( error_t ), intent(out), allocatable :: error public subroutine targets_from_sources (model, sources) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout), target :: model type( srcfile_t ), intent(in) :: sources (:)","tags":"","loc":"module/fpm_targets.html"},{"title":"fpm – Fortran-lang/fpm","text":"Uses fpm_strings fpm_backend fpm_command_line fpm_environment fpm_filesystem fpm_model fpm_sources fpm_targets fpm_manifest fpm_error fpm_manifest_test iso_fortran_env fpm_manifest_dependency Contents Subroutines cmd_build cmd_install cmd_run Subroutines public subroutine cmd_build (settings) Arguments Type Intent Optional Attributes Name type( fpm_build_settings ), intent(in) :: settings public subroutine cmd_install (settings) Arguments Type Intent Optional Attributes Name type( fpm_install_settings ), intent(in) :: settings public subroutine cmd_run (settings, test) Arguments Type Intent Optional Attributes Name class( fpm_run_settings ), intent(in) :: settings logical, intent(in) :: test","tags":"","loc":"module/fpm.html"},{"title":"fpm_versioning – Fortran-lang/fpm","text":"Implementation of versioning data for comparing packages Uses fpm_error Contents Interfaces new_version Derived Types version_t Interfaces public interface new_version private subroutine new_version_from_string(self, string, error) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data character(len=*), intent(in) :: string String describing the version information type( error_t ), intent(out), allocatable :: error Error handling private subroutine new_version_from_int(self, num) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data integer, intent(in) :: num (:) Subversion numbers to define version data Derived Types type, public :: version_t Type-Bound Procedures generic, public :: operator(.match.) => match Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic, public :: operator(/=) => not_equals generic, public :: operator(<) => less generic, public :: operator(<=) => less_equals generic, public :: operator(==) => equals generic, public :: operator(>) => greater generic, public :: operator(>=) => greater_equals procedure, public :: to_string Create a printable string from a version data type","tags":"","loc":"module/fpm_versioning.html"},{"title":"fpm_error – Fortran-lang/fpm","text":"Implementation of basic error handling. Contents Interfaces syntax_error Derived Types error_t Subroutines fatal_error file_not_found_error file_parse_error Interfaces public interface syntax_error Alias syntax errors to fatal errors for now public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message Derived Types type, public :: error_t Data type defining an error Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message Subroutines public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message public subroutine file_not_found_error (error, file_name) Error created when a file is missing or not found Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of the missing file public subroutine file_parse_error (error, file_name, message, line_num, line_string, line_col) Error created when file parsing fails Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of file character(len=*), intent(in) :: message Parse error message integer, intent(in), optional :: line_num Line number of parse error character(len=*), intent(in), optional :: line_string Line context string integer, intent(in), optional :: line_col Line context column","tags":"","loc":"module/fpm_error.html"},{"title":"fpm_git – Fortran-lang/fpm","text":"Implementation for interacting with git repositories. Uses fpm_error Contents Variables git_descriptor Derived Types enum_descriptor git_target_t Functions git_target_branch git_target_default git_target_revision git_target_tag Subroutines checkout info Variables Type Visibility Attributes Name Initial type( enum_descriptor ), public, parameter :: git_descriptor = enum_descriptor() Actual enumerator for descriptors Derived Types type, public :: enum_descriptor Possible git target Components Type Visibility Attributes Name Initial integer, public :: branch = 201 Branch in git repository integer, public :: default = 200 Default target integer, public :: revision = 203 Commit hash integer, public :: tag = 202 Tag in git repository type, public :: git_target_t Description of an git target Type-Bound Procedures procedure, public :: checkout Fetch and checkout in local directory procedure, public :: info Show information on instance Functions public function git_target_branch (url, branch) result(self) Target a branch in the git repository Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: branch Name of the branch of interest Return Value type( git_target_t ) New git target public function git_target_default (url) result(self) Default target Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository Return Value type( git_target_t ) New git target public function git_target_revision (url, sha1) result(self) Target a specific git revision Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: sha1 Commit hash of interest Return Value type( git_target_t ) New git target public function git_target_tag (url, tag) result(self) Target a git tag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: tag Tag name of interest Return Value type( git_target_t ) New git target Subroutines public subroutine checkout (self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error public subroutine info (self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout","tags":"","loc":"module/fpm_git.html"},{"title":"fpm_toml – Fortran-lang/fpm","text":"Interface to TOML processing library. This module acts as a proxy to the toml-f public Fortran API and allows\n to selectively expose components from the library to fpm .\n The interaction with toml-f data types outside of this module should be\n limited to tables, arrays and key-lists, most of the necessary interactions\n are implemented in the building interface with the get_value and set_value procedures. This module allows to implement features necessary for fpm , which are\n not yet available in upstream toml-f . For more details on the library used see: https://toml-f.github.io/toml-f Uses fpm_error fpm_strings tomlf Contents Interfaces get_value Subroutines read_package_file Interfaces public interface get_value private subroutine get_child_value_string_list(table, key, list, error) Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table Instance of the TOML data structure character(len=*), intent(in) :: key Key to read from type( string_t ), intent(out), allocatable :: list (:) List of strings to read type( error_t ), intent(out), allocatable :: error Error handling Subroutines public subroutine read_package_file (table, manifest, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: manifest Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation","tags":"","loc":"module/fpm_toml.html"},{"title":"fpm_manifest – Fortran-lang/fpm","text":"Package configuration data. This module provides the necessary procedure to translate a TOML document\n to the corresponding Fortran type, while verifying it with respect to\n its schema. Additionally, the required data types for users of this module are reexported\n to hide the actual implementation details. Uses fpm_manifest_build fpm_manifest_executable fpm_manifest_library fpm_manifest_package fpm_error fpm_toml fpm_manifest_test fpm_filesystem Contents Subroutines default_executable default_library default_test get_package_data Subroutines public subroutine default_executable (self, name) Populate executable in case we find the default app directory Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package public subroutine default_library (self) Populate library in case we find the default src directory Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library meta data public subroutine default_test (self, name) Populate test in case we find the default test/ directory Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package public subroutine get_package_data (package, file, error, apply_defaults) Obtain package meta data from a configuation file Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: package Parsed package meta data character(len=*), intent(in) :: file Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation logical, intent(in), optional :: apply_defaults Apply package defaults (uses file system operations)","tags":"","loc":"module/fpm_manifest.html"},{"title":"fpm_manifest_test – Fortran-lang/fpm","text":"Implementation of the meta data for a test. The test data structure is effectively a decorated version of an executable\n and shares most of its properties, except for the defaults and can be\n handled under most circumstances just like any other executable. A test table can currently have the following fields [[ test ]] name = \"string\" source-dir = \"path\" main = \"file\" link = [\"lib\"] [test.dependencies] Uses fpm_manifest_dependency fpm_manifest_executable fpm_error fpm_toml Contents Derived Types test_config_t Subroutines new_test Derived Types type, public, extends( executable_config_t ) :: test_config_t Configuation meta data for an test Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_test (self, table, error) Construct a new test configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the test configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_test.html"},{"title":"fpm_manifest_build – Fortran-lang/fpm","text":"Implementation of the build configuration data. A build table can currently have the following fields [build] auto-executables = bool auto-tests = bool link = [\"lib\"] Uses fpm_error fpm_strings fpm_toml Contents Derived Types build_config_t Subroutines new_build_config Derived Types type, public :: build_config_t Configuration data for build Components Type Visibility Attributes Name Initial logical, public :: auto_executables Automatic discovery of executables logical, public :: auto_tests Automatic discovery of tests type( string_t ), public, allocatable :: link (:) Libraries to link against Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_build_config (self, table, error) Construct a new build configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( build_config_t ), intent(out) :: self Instance of the build configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_build.html"},{"title":"fpm_manifest_dependency – Fortran-lang/fpm","text":"Implementation of the meta data for dependencies. A dependency table can currently have the following fields [dependencies] \"dep1\" = { git = \"url\" } \"dep2\" = { git = \"url\" , branch = \"name\" } \"dep3\" = { git = \"url\" , tag = \"name\" } \"dep4\" = { git = \"url\" , rev = \"sha1\" } \"dep0\" = { path = \"path\" } To reduce the amount of boilerplate code this module provides two constructors\n for dependency types, one basic for an actual dependency (inline) table\n and another to collect all dependency objects from a dependencies table,\n which is handling the allocation of the objects and is forwarding the\n individual dependency tables to their respective constructors.\n The usual entry point should be the constructor for the super table. This objects contains a target to retrieve required fpm projects to\n build the target declaring the dependency.\n Resolving a dependency will result in obtaining a new package configuration\n data for the respective project. Uses fpm_error fpm_git fpm_toml Contents Derived Types dependency_config_t Subroutines new_dependencies new_dependency Derived Types type, public :: dependency_config_t Configuration meta data for a dependency Components Type Visibility Attributes Name Initial type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_dependencies (deps, table, error) Construct new dependency array from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out), allocatable :: deps (:) Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling public subroutine new_dependency (self, table, error) Construct a new dependency configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out) :: self Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_dependency.html"},{"title":"fpm_manifest_executable – Fortran-lang/fpm","text":"Implementation of the meta data for an executables. An executable table can currently have the following fields [[ executable ]] name = \"string\" source-dir = \"path\" main = \"file\" link = [\"lib\"] [executable.dependencies] Uses fpm_manifest_dependency fpm_error fpm_strings fpm_toml Contents Derived Types executable_config_t Subroutines new_executable Derived Types type, public :: executable_config_t Configuation meta data for an executable Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_executable (self, table, error) Construct a new executable configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_executable.html"},{"title":"fpm_manifest_package – Fortran-lang/fpm","text":"Define the package data containing the meta data from the configuration file. The package data defines a Fortran type corresponding to the respective\n TOML document, after creating it from a package file no more interaction\n with the TOML document is required. Every configuration type provides it custom constructor (prefixed with new_ )\n and knows how to deserialize itself from a TOML document.\n To ensure we find no untracked content in the package file all keywords are\n checked and possible entries have to be explicitly allowed in the check function.\n If entries are mutally exclusive or interdependent inside the current table\n the check function is required to enforce this schema on the data structure. The package file root allows the following keywords name = \"string\" version = \"string\" license = \"string\" author = \"string\" maintainer = \"string\" copyright = \"string\" [library] [dependencies] [dev-dependencies] [[ executable ]] [[ test ]] Uses fpm_manifest_build fpm_manifest_dependency fpm_manifest_executable fpm_manifest_library fpm_manifest_test fpm_error fpm_toml fpm_versioning Contents Derived Types package_config_t Subroutines new_package Derived Types type, public :: package_config_t Package meta data Components Type Visibility Attributes Name Initial type( build_config_t ), public :: build Build configuration data type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data type( dependency_config_t ), public, allocatable :: dev_dependency (:) Development dependency meta data type( executable_config_t ), public, allocatable :: executable (:) Executable meta data type( library_config_t ), public, allocatable :: library Library meta data character(len=:), public, allocatable :: name Name of the package type( test_config_t ), public, allocatable :: test (:) Test meta data type( version_t ), public :: version Package version Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_package (self, table, error) Construct a new package configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: self Instance of the package configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_package.html"},{"title":"fpm_manifest_library – Fortran-lang/fpm","text":"Implementation of the meta data for libraries. A library table can currently have the following fields [library] source-dir = \"path\" build-script = \"file\" Uses fpm_error fpm_toml Contents Derived Types library_config_t Subroutines new_library Derived Types type, public :: library_config_t Configuration meta data for a library Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_script Alternative build script to be invoked character(len=:), public, allocatable :: source_dir Source path prefix Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_library (self, table, error) Construct a new library configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_library.html"},{"title":"fpm_cmd_new – Fortran-lang/fpm","text":"Uses fpm_command_line fpm_environment fpm_filesystem iso_fortran_env Contents Subroutines cmd_new Subroutines public subroutine cmd_new (settings) Arguments Type Intent Optional Attributes Name type( fpm_new_settings ), intent(in) :: settings","tags":"","loc":"module/fpm_cmd_new.html"},{"title":"Packaging and contributing – Fortran-lang/fpm","text":"","tags":"","loc":"page//index.html"},{"title":"Contributing Guidelines – Fortran-lang/fpm","text":"Contributing to the Fortran Package Manager Thank you for considering contributing to the Fortran Package Manager ( fpm ).\nPlease review and follow these guidelines to make the contribution process\nsimple and effective for all involved. It will help communicate that you\nrespect the time of the community developers. In return, the community will\nhelp address your problem, evaluate changes, and guide you through your pull\nrequests. By contributing to fpm , you certify that you own or are allowed to share the\ncontent of your contribution under the fpm license . Style Reporting a bug Suggesting a feature Workflow General guidelines For new contributors Style Please follow the Fortran stdlib style guide for any Fortran code that you contribute.\nThis allows us to focus on substance rather than style. Reporting a bug A bug is a demonstrable problem caused by the code in this repository.\nGood bug reports are extremely valuable to us—thank you! Before opening a bug report: Check if the issue has already been reported\n   ( issues ). Check if it is still an issue or it has been fixed?\n   Try to reproduce it with the latest version from the master branch. Isolate the problem and create a minimal test case. A good bug report should include all information needed to reproduce the bug.\nPlease be as detailed as possible: Which version of fpm are you using? Please be specific. What are the steps to reproduce the issue? What is the expected outcome? What happens instead? This information will help the community diagnose the issue quickly and with\nminimal back-and-forth. Suggesting a feature Before suggesting a new feature, take a moment to find out if it fits the scope\nof the project, or if it has already been discussed. It is up to you to provide\na strong argument to convince the community of the benefits of this feature.\nPlease provide as much detail and context as possible. If applicable, include a\nmocked-up snippet of what the output or behavior would look like with this\nfeature implemented. “Crazy”, out-of-the-box ideas are especially welcome.\nIt’s quite possible that we are not considering an unusually creative solution. Workflow fpm is a community project. There is no one single person making final\ndecisions. This is the workflow that we follow: Open a new issue to\n   describe a bug or propose a new feature.\n   Refer to the earlier sections on how to write a good bug report or feature\n   request. Discuss with the community and reach majority consensus about what should be\n   done about the bug or feature request.\n   We define “majority” loosely as 80%.\n   This means that at least 4 of 5 people engaged in the discussion should be\n   able to agree on the next step.\n   This allows us to have the community mostly agree while not getting stuck if\n   one person disagrees.\n   At this stage, the scope of the fix/feature, its behavior, and API if\n   applicable should be defined.\n   Only when you have community concensus on these items you should proceed to\n   writing code and opening a PR. When actively working on code towards a PR, please assign yourself to the\n   issue on GitHub. This is good collaborative practice to avoid duplicated effort and also\n   inform others what you are currently working on. Open a new Pull Request (PR) with your contribution.\n   The body of the PR should at least include a bullet-point summary of the\n   changes, and a detailed description is encouraged.\n   If the PR completely addresses the issue you opened in step 1, include in\n   the PR description the following line: Fixes #<issue-number> . Request reviewers to your PR.\n   For small bug fixes or documentation improvements, 1 to 2 reviewers is\n   sufficient.\n   For implementation of bigger features, request 3 to 4 or more reviewers.\n   Ideally, request reviewers that participated in step 2. If your PR implements a feature that adds or changes the behavior of fpm ,\n   your PR must also include appropriate changes to the documentation. This workflow can evolve and change over time as we learn how best to work\ntogether. If you have an idea on how to improve the workflow itself, please\nopen an issue and we’ll discuss it. General guidelines A PR should implement only one feature or bug fix. Do not commit changes to files that are irrelevant to your feature or bug fix. Smaller PRs are better than large PRs, and will lead to a shorter review and\n  merge cycle Add tests for your feature or bug fix to be sure that it stays functional and useful Be open to constructive criticism and requests for improving your code. Again, please follow the Fortran stdlib style guide . For new contributors If you have never created a pull request before, welcome :tada:.\nYou can learn how from this great tutorial . Don’t know where to start?\nYou can start by looking through the list of open issues .","tags":"","loc":"page/./Contributing.html"},{"title":"License – Fortran-lang/fpm","text":"MIT License Copyright (c) 2020 fpm contributors Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Manifest reference – Fortran-lang/fpm","text":"Fortran package manager (fpm) manifest reference The fpm.toml file for each project is called its manifest .\nIt is written using the TOML format.\nEvery manifest file consists of the following sections: name :\n  The name of the project version :\n  The version of the project license :\n  The project license maintainer :\n  Maintainer of the project author :\n  Author of the project copyright :\n  Copyright of the project description :\n  Description of the project categories :\n  Categories associated with the project keywords :\n  Keywords describing the project homepage :\n  The project’s homepage Build configuration: auto-tests :\n    Toggle automatic discovery of test executables auto-executables :\n    Toggle automatic discovery of executables link :\n    Link with external dependencies Target sections: library Configuration of the library target executable Configuration of the executable targets test Configuration of the test targets Dependency sections: dependencies :\n    Project library dependencies dev-dependencies :\n    Dependencies only needed for tests Project name The project name identifies the package and is used to refer to it.\nIt is used when listing the project as dependency for another package and the default name of the library and executable target.\nTherefore, the project name must always be present. Example: name = \"hello_world\" Project version The version number of the project is specified as string.\nA standardized way to manage and specify versions is the Semantic Versioning scheme. Example: version = \"1.0.0\" Project license The project license field contains the license identifier.\nA standardized way to specify licensing information are SPDX identifiers. Examples: Projects licensed under the GNU Lesser General Public License , either version 3 or any later version, is specified as license = \"LGPL-3.0-or-later\" Dual licensed project under the Apache license, version 2.0 or the MIT license are specified as license = \"Apache-2.0 OR MIT\" Project maintainer Information on the project maintainer and means to reach out to them. Example: maintainer = \"jane.doe@example.com\" Project author Information on the project author. Example: author = \"Jane Doe\" Project copyright A statement clarifying the copyright status of the project. Example: copyright = \"Copyright 2020 Jane Doe\" Project description The decription provides a short summary on the project.\nIt should be plain text and not using any markup formatting. Example: description = \"A short summary on this project\" Project categories The project can be associated with different categories. Example: categories = [\"io\"] Project keywords The keywords field is an array of strings describing the project. Example: keywords = [\"hdf5\", \"mpi\"] Project homepage URL to the webpage of the project. Example: homepage = \"https://stdlib.fortran-lang.org\" Project targets Every fpm project can define library, executable and test targets.\nLibrary targets are exported and useable for other projects. Library configuration Defines the exported library target of the project.\nA library is generated if the source directory is found in a project.\nThe default source directory is src but can be modifed in the library section using the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms. Example: [library] source-dir = \"lib\" Custom build script Supported in Bootstrap fpm only Projects with custom build scripts can specify those in the build-script entry.\nThe custom build script will be executeted when the library build step is reached. Example: [library] build-script = \"build.sh\" Build scripts written in make are automatically detected and executed with make [library] build-script = \"Makefile\" Executable targets Executable targets are Fortran programs defined as executable sections.\nIf no executable section is specified the app directory is searched for program definitions.\nFor explicitly specified executables the name entry must always be specified.\nThe source directory for each executable can be adjusted in the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms.\nThe source file containing the program body can be specified in the main entry. Executables can have their own dependencies.\nSee specifying dependencies for more details. Dependencies supported in Bootstrap fpm only Executables can also specify their own external library dependencies.\nSee external libraries for more details. Linking against libraries is supported in Fortran fpm only Example: [[ executable ]] name = \"app-name\" source-dir = \"prog\" main = \"program.f90\" [[ executable ]] name = \"app-tool\" link = \"z\" [executable.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } Specifying many separate executables can be done by using inline tables for brevity instead executable = [ { name = \"a-prog\" }, { name = \"app-tool\" , source-dir = \"tool\" }, ] Test targets Test targets are Fortran programs defined as test sections.\nThey follow similar rules as the executable targets.\nIf no test section is specified the test directory is searched for program definitions.\nFor explicitly specified tests the name entry must always be specified.\nThe source directory for each test can be adjusted in the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms.\nThe source file containing the program body can be specified in the main entry. Tests can have their own dependencies.\nSee specifying dependencies for more details. Dependencies supported in Bootstrap fpm only Tests can also specify their own external library dependencies.\nSee external libraries for more details. Linking against libraries is supported in Fortran fpm only Example: [[ test ]] name = \"test-name\" source-dir = \"testing\" main = \"tester.F90\" [[ test ]] name = \"tester\" link = [\"blas\", \"lapack\"] [test.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } Link external libraries Supported in Fortran fpm only To declare link time dependencies on external libraries a list of native libraries can be specified in the link entry.\nSpecify either one library as string or a list of strings in case several libraries should be linked.\nWhen possible the project should only link one native library.\nThe list of library dependencies is exported to dependent packages. Example: To link against the zlib compression library use [build] link = \"z\" To dependent on LAPACK also BLAS should be linked.\nIn this case the order of the libraries matters: [build] link = [\"blas\", \"lapack\"] Automatic target discovery Supported in Fortran fpm only Executables and test can be discovered automatically in their default directories.\nThe automatic discovery recursively searches the app and test directories for program definitions and declares them as executable and test targets, respectively.\nThe automatic discovery is enabled by default. To disable the automatic discovery of targets set the auto-executables and auto-tests entry to false . [build] auto-executables = false auto-tests = false Specifying dependencies Dependencies can be declared in the dependencies table in the manifest root or the executable or test sections.\nWhen declared in the manifest root the dependencies are exported with the project. Local dependencies To declare local dependencies use the path entry. [dependencies] my-utils = { path = \"utils\" } Local dependency paths are given relative to the project root and use / as path separator on all platforms. Dependencies from version control systems Dependencies can be specified by the projects git repository. [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" } To use a specific upstream branch declare the branch name with [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , branch = \"master\" } Alternatively, reference tags by using the tag entry [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , tag = \"v0.2.1\" } To pin a specific revision specify the commit hash in the rev entry [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , rev = \"2f5eaba\" } For more verbose layout use normal tables rather than inline tables to specify dependencies [dependencies] [dependencies.toml-f] git = \"https://github.com/toml-f/toml-f\" rev = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\" Development dependencies Development dependencies allow to declare dev-dependencies in the manifest root, which are available to all tests but not exported with the project.","tags":"","loc":"page/./Manifest.html"},{"title":"Packaging with fpm – Fortran-lang/fpm","text":"Preparing your package for FPM This document describes how you need to organize your application or library for\nit to successfully build with the Fortran Package Manager ( fpm ). What kind of package can fpm build? Example package layouts Single program Single-module library Multi-module library Application and library Multi-level library Be more explicit Add some tests Adding dependencies Custom build scripts What kind of package can fpm build? You can use fpm to build: Applications (program only) Libraries (modules only) Combination of the two (programs and modules combined) Let’s look at some examples of different kinds of package layouts that you can\nuse with fpm . Example package layouts This section describes some example package layouts that you can build with fpm . You can use them to model the layout of your own package. Single program Let’s start with the simplest package imaginable—a single program without\ndependencies or modules. Here’s what the layout of the top-level directory\nlooks like: . ├── app │   └── main.f90 └── fpm.toml We have one source file ( main.f90 ) in one directory ( app ). Its contents\nare: program main print * , 'Hello, World!' end program main This program prints the usual greeting to the standard output, and nothing more. There’s another important file in the top-level directory, fpm.toml .  This is fpm ’s configuration file specific to your package.  It includes all the data\nthat fpm needs to build your app.  In our simple case, it looks like this: name = \"hello\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" The preamble includes some metadata, such as license , author , and similar,\nthat you may have seen in other package manager configuration files.  The one\noption that matters here right now is: name = \"hello\" This line specifies the name of your package, which determines the name of the\nexecutable file of your program. In this example, our program executable, once\nbuilt, will be called hello . Let’s now build this program using fpm : $ fpm build # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/hello) On the first line, we ran fpm build to compile and link the application.\nThe latter two lines are emitted by fpm , and indicate which command was\nexecuted at each build step ( gfortran ), and which files have been output\nby it: object file main.o , and executable hello . We can now run the app with fpm run : $ fpm run\n Hello, World! If your application needs to use a module internally, but you don’t intend\nto build it as a library to be used in other projects, you can include the\nmodule in your program source file as well.\nFor example: $ cat app / main . f90 module math_constants real , parameter :: pi = 4 * atan ( 1. ) end module math_constants program main use math_constants , only : pi print * , 'Hello, World!' print * , 'pi = ' , pi end program main Now, run this using fpm run : $ fpm run # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/hello) Hello, World! pi = 3 .14159274 Notice that you can run fpm run , and if the package hasn’t been built yet, fpm build will run automatically for you. This is true if the source files\nhave been updated since the last build.  Thus, if you want to run your\napplication, you can skip the fpm build step, and go straight to fpm run . Although we have named our program hello , which is the same name as the\npackage name in fpm.toml , you can name it anything you want as long as it’s\npermitted by the language. In this last example, our source file defined a math_constants module inside\nthe same source file as the main program. Let’s see how we can define an fpm package that makes this module available as a library. Single-module library The package layout for this example looks like this: . ├── fpm . toml └── src └── math_constants . f90 In this example we’ll build a simple math constants library that exports\nthe number pi as a parameter: $ cat src / math_constants . f90 module math_constants real , parameter :: pi = 4 * atan ( 1. ) end module math_constants and our fpm.toml is the same as before. Now use fpm build to build the package: $ fpm build # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a Based on the output of fpm build , fpm first ran gfortran to emit the\nbinary object ( math_constants.o ) and module ( math_constants.mod ) files.\nThen it ran ar to create a static library archive math_constants.a . build/debug/library is thus both your include and library path, should you\nwant to compile and link an exteranl program with this library. For modules in the top-level ( src ) directory, fpm requires that: The module has the same name as the source file. There is only one module per file. These two requirements simplify the build process for fpm . As Fortran\ncompilers emit module files ( .mod ) with the same name as the module itself\n(but not the source file, .f90 ), naming the module the same as the source file\nallows fpm to: Uniquely and exactly map a source file ( .f90 ) to its object ( .o ) and\nmodule ( .mod ) files. Avoid conflicts with modules of the same name that could appear in dependency\npackages (more on this in a bit). Since this is a library without executable programs, fpm run here does\nnothing. In this example, our library is made of only one module. However, most\nreal-world libraries are likely to use multiple modules. Let’s see how you can\npackage your multi-module library. Multi-module library In this example, we’ll use another module to define a 64-bit real kind\nparameter and make it available in math_constants to define pi with\nhigher precision. To make this exercise worthwhile, we’ll define another math\nconstant, Euler’s number. Our package layout looks like this: . ├── fpm . toml └── src ├── math_constants . f90 └── type_kinds . f90 And our source file contents are: $ cat src / math_constants . f90 module math_constants use type_kinds , only : rk real ( rk ), parameter :: pi = 4 * atan ( 1._rk ) real ( rk ), parameter :: e = exp ( 1._rk ) end module math_constants $ cat src / type_kinds . f90 module type_kinds use iso_fortran_env , only : real64 integer , parameter :: rk = real64 end module type_kinds and there are no changes to our fpm.toml relative to previous examples. Like before, notice that the module type_kinds is name exactly as the\nsource file that contains it.\nThis is important. By now you know how to build the package: $ fpm build # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a Our build path now contains: $ ls build/debug/library/\nmath_constants.a  math_constants.mod  math_constants.o  type_kinds.mod  type_kinds.o And the static library includes all the object files: $ nm build/debug/library/math_constants.a\n\nmath_constants.o:\n\ntype_kinds.o: The takeaways from this example are that: fpm automatically scanned the src directory for any source files. It also resolved the dependency order between different modules. Application and library Let’s now combine the two previous examples into one: We’ll build the math\nconstants library and an executable program that uses it. We’ll use this\nprogram as a demo, and to verify that defining higher-precision constants from\nthe previous example actually worked. Here’s the package layout for your application + library package: . ├── app │ └── main . f90 ├── fpm . toml └── src ├── math_constants . f90 └── type_kinds . f90 Our fpm.toml remains unchanged and our executable program source file is: $ cat app / main . f90 program main use math_constants , only : e , pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , 'e = ' , e end program main Let’s go straight to running the demo program: $ fpm run # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) math_constants library demo pi = 3 .1415926535897931 e = 2 .7182818284590451 The fpm build + run process works as expected, and our program correctly\noutputs higher-precision constants. So far we covered how fpm builds: A single program A single-module library A multi-module library A program and a library However, all our modules so far have been organized in the top level source\ndirectory. More complex libraries may organize their modules in subdirectories.\nLet’s see how we can build this with fpm . Multi-level library In this example, we’ll define our library as a collection of modules, two of\nwhich are defined in a subdirectory: . ├── app │ └── main . f90 ├── fpm . toml └── src ├── math_constants │ ├── derived . f90 │ └── fundamental . f90 ├── math_constants . f90 └── type_kinds . f90 First, fpm.toml and src/type_kinds.f90 remain unchanged relative to the\nprevious example. The rest of the source files are: $ cat src / math_constants . f90 module math_constants use math_constants_fundamental , only : e , pi use math_constants_derived , only : half_pi , two_pi end module math_constants $ cat src / math_constants / fundamental . f90 module math_constants_fundamental use type_kinds , only : rk real ( rk ), parameter :: pi = 4 * atan ( 1._rk ) real ( rk ), parameter :: e = exp ( 1._rk ) end module math_constants_fundamental $ cat src / math_constants / derived . f90 module math_constants_derived use math_constants_fundamental , only : pi use type_kinds , only : rk real ( rk ), parameter :: two_pi = 2 * pi real ( rk ), parameter :: half_pi = pi / 2 end module math_constants_derived $ cat app / main . f90 program main use math_constants , only : e , pi , half_pi , two_pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , '2*pi = ' , two_pi print * , 'pi/2 = ' , half_pi print * , 'e = ' , e end program main Our top-level math_constants module now doesn’t define the constants, but\nimports them from the two modules in the subdirectory. Constants e and pi we define in the math_constants_fundamental module, and two_pi and half_pi in the math_constants_derived module. From the main program, we access all\nthe constants from the top-level module math_constants . Let’s build and run this package: $ fpm run # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants_fundamental.o build/debug/library/math_constants_fundamental.mod) # gfortran (for build/debug/library/math_constants_derived.o build/debug/library/math_constants_derived.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) math_constants library demo pi = 3 .1415926535897931 2 *pi = 6 .2831853071795862\n pi/2 = 1 .5707963267948966 e = 2 .7182818284590451 Again, fpm built and run the package as expected. Recall from an earlier example that fpm required the modules in the top-level src directory to be named the same as their source file. This is why src/math_constants.f90 defines module math_constants . For modules defined in subdirectories, there’s an additional requirement: module\nname must contain the path components of the directory that its source file is\nin.  In our case, src/math_constants/fundamental.f90 defines the math_constants_fundamental module.  Likewise, src/math_constants/derived.f90 defines the math_constants_derived module. This rule applies generally to any number of nested directories and modules.\nFor example, src/a/b/c/d.f90 must define a module called a_b_c_d . Takeaways from this example are that: You can place your module source files in any levels of subdirectories inside src . The module name must include the path components and the source file name–for example, src/a/b/c/d.f90 must define a module called a_b_c_d . Be more explicit So far we’ve let fpm use its defaults to determine the layout of our package.\nIt determined where our library sources would live, what the name of the\nexecutable will be, and some other things. But we can be more explicit about it,\nand make some changes to those things. Let’s look at what the fpm.toml file from our last example would look like if\nwe specified everything. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" You can see that by making these explicit in the fpm.toml we are able to\nchange many of the settings that fpm used by default. We can change the\nfolders where our sources are stored, we can change the name of our executable,\nand we can change the name of the file our program is defined in. Add some tests fpm also provides support for unit testing. By default, fpm looks for a\nprogram in test/main.f90 which it will compile and execute with the command fpm test . The tests are treated pretty much exactly like the executables.\nLet’s define one explicitly in our fpm.toml file. We’ll make sure that our\ndefinition of pi satisfies the property sin(pi) == 0.0 . Here’s the fpm.toml file: name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" where the contents of the main.f90 file are program main use math_constants , only : pi print * , \"sin(pi) = \" , sin ( pi ) end program main With this setup, we can run our tests. $ fpm test # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants_fundamental.o build/debug/library/math_constants_fundamental.mod) # gfortran (for build/debug/library/math_constants_derived.o build/debug/library/math_constants_derived.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) # gfortran (for build/debug/test/main.o) # gfortran (for build/debug/test/runTests) sin ( pi ) = 1 .2246467991473532E-016 Adding dependencies Inevitably, you’ll want to be able to include other libraries in your project.\nfpm makes this incredibly simple, by taking care of fetching and compiling your\ndependencies for you. You just tell it what your dependencies are, and where to\nfind them. Let’s add a dependency to our library. Now our fpm.toml file looks\nlike this: name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" Now you can use any modules from this library anywhere in your code. Just like\nthis: program main use helloff , only : create_greeting use math_constants , only : e , pi , half_pi , two_pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , '2*pi = ' , two_pi print * , 'pi/2 = ' , half_pi print * , 'e = ' , e print * , create_greeting ( \"fpm\" ) end program main And now, fpm run will output the following: math_constants library demo pi = 3.1415926535897931 2 * pi = 6.2831853071795862 pi / 2 = 1.5707963267948966 e = 2.7182818284590451 Hello , fpm ! Additionally, any users of your library will now automatically depend on your\ndependencies too. So if you don’t need that depedency for the library, like in\nthe above example, then you can specify it for the specific executable like\nbelow. Then fpm will still fetch and compile it when building your executable,\nbut users of your library won’t have to. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [executable.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" You can also specify dependencies for your tests in a similar way, with [test.dependencies] instead of [executable.dependencies] . There’s also\nanother option for test dependencies. The below example makes the dependencies\navailable for all the tests, but again your users won’t depend on these. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [dev-dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" You can also be specific about which version of a dependency you’d like. You can\nspecify a branch to use like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" } ,\nor a tag like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", tag = \"v1.2.3\" } ,\nor even a specific commit like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", rev = \"a1b2c3\" } .\nYou can even specify the path to another folder, if for example you’ve got\nanother fpm package in the same repository. Like this: helloff = { path = \"helloff\" } . Note that you should not specify paths\noutside of your repository, or things won’t work for your users. Custom build scripts If there is something special about your library that makes fpm unable to build\nit, you can provide your own build script. fpm will then simply call your build\nscript to build the library. To specify a build script to be used, put it in the library section of your fpm.toml file, like: [library] source-dir = \"src\" build-script = \"my_build_script\" fpm will set the following environment variables to specify some parameters to\nthe build script: FC – The Fortran compiler to be used. FFLAGS – The flags that should be passed to the Fortran compiler. BUILD_DIR – Where the compiled files should be placed. INCLUDE_DIRS – The folders where any dependencies can be found, space seperated.\nIt is then the responsibility of the build script to generate the appropriate\ninclude flags. Additionally, script will be called with the name of the archive ( *.a file)\nthat should be produced as the command line argument. Note: If the name of the build script is Makefile or ends with .mk , then\nthe make program will be used to run it. Not the the archive file is explicitly\nspecified as the target to be built Note: All file and directory names are specified with their full canonical\npath.","tags":"","loc":"page/./Packaging.html"}]}