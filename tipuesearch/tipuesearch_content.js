var tipuesearch = {"pages":[{"title":" Fortran-lang/fpm ","text":"Fortran-lang/fpm Fortran package manager developer documentation The package manifest Command line interface The package model The build backend Generating this documentation Fortran package manager developer documentation This is the main documentation of the Fortran package manager ( fpm ).\nThis document serves as developer documentation of fpm itself and contains general advice for developing in the fpm code base. The package manifest The central object describing an fpm project is the package manifest fpm.toml .\nThe manifest is written in TOML, you can find the TOML specification at the official TOML homepage . The fpm.toml file targets project developers and maintainers to relieve them from writing build files for their packages.\nWith the package manifest a central place to collect information about the project is provided.\nIt contains the versioning and licensing meta data, as well as the information on external dependencies and the required build-tools or compiler settings. The manifest format specific to fpm projects is documented in the manifest reference . Note For a more practical but less complete guide on creating fpm projects see the packaging guide . The details of the TOML parsing are implemented with using the tomlf module.\nGenerally, the interface to all TOML related functions for fpm is found in the proxy module fpm_toml . All the manifest types are bundled in fpm_manifest .\nWhile the specific subtables for the package configuration are found in the src/fpm/manifest directory, they should be reexported in the fpm_manifest module if they should be elsewhere in fpm . Command line interface fpm is mainly used as a command line tool.\nTo work with an fpm project as a user you can completely rely on the command line. The command line interface is build with the M_CLI2 module and can be found in fpm_command_line . The package model Once front-end inputs have been received from the package manifest and command line interface, fpm will construct an\ninternal representation of the package and its dependencies. This internal representation is known as the package model .\nThe model and its associated data types should encapsulate all the information required to correctly build a package and\nshould be independent of the intended backend build system. Information stored in the model includes: build targets and\ntheir inter-dependencies; compiler and compiler flags; library linking information. For more information on the contents of the package model and the process for constructing it, please see fpm_model . The build backend Once a complete package model has been constructed, it can be passed to a backend for either performing the compilation\nand linking of targets, or for generating configuration files for a third-party build system.\nCurrently, only a native backend is implemented in fpm . See fpm_backend for more information. Generating this documentation This documentation is generated by FORD .\nFor more details on the project file and the comment markup in the source code visit the FORD documentation . To regenerate this documentation run: ford docs.md Developer Info fortran-lang/fpm contributors","tags":"home","loc":"index.html"},{"title":"fpm_filesystem.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_filesystem Source Code fpm_filesystem.f90 Source Code module fpm_filesystem use fpm_environment , only : get_os_type , & OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_WINDOWS , & OS_CYGWIN , OS_SOLARIS , OS_FREEBSD use fpm_strings , only : f_string , string_t , split implicit none private public :: basename , canon_path , dirname , is_dir , join_path , number_of_rows , read_lines , list_files , env_variable , & mkdir , exists , get_temp_filename , windows_path , unix_path , getline , delete_file integer , parameter :: LINE_BUFFER_LEN = 1000 contains subroutine env_variable ( var , name ) character ( len = :), allocatable , intent ( out ) :: var character ( len =* ), intent ( in ) :: name integer :: length , stat call get_environment_variable ( name , length = length , status = stat ) if ( stat /= 0 ) return allocate ( character ( len = length ) :: var ) if ( length > 0 ) then call get_environment_variable ( name , var , status = stat ) if ( stat /= 0 ) then deallocate ( var ) return end if end if end subroutine env_variable function basename ( path , suffix ) result ( base ) ! Extract filename from path with/without suffix ! character ( * ), intent ( In ) :: path logical , intent ( in ), optional :: suffix character (:), allocatable :: base character (:), allocatable :: file_parts (:) logical :: with_suffix if (. not . present ( suffix )) then with_suffix = . true . else with_suffix = suffix end if if ( with_suffix ) then call split ( path , file_parts , delimiters = '\\/' ) if ( size ( file_parts ). gt . 0 ) then base = trim ( file_parts ( size ( file_parts ))) else base = '' endif else call split ( path , file_parts , delimiters = '\\/.' ) if ( size ( file_parts ). ge . 2 ) then base = trim ( file_parts ( size ( file_parts ) - 1 )) else base = '' endif end if end function basename function canon_path ( path ) result ( canon ) ! Canonicalize path for comparison !  Handles path string redundancies !  Does not test existence of path ! ! To be replaced by realpath/_fullname in stdlib_os ! character ( * ), intent ( in ) :: path character (:), allocatable :: canon integer :: i , j integer :: iback character ( len ( path )) :: nixpath character ( len ( path )) :: temp nixpath = unix_path ( path ) j = 1 do i = 1 , len ( nixpath ) ! Skip back to last directory for '/../' if ( i > 4 ) then if ( nixpath ( i - 3 : i ) == '/../' ) then iback = scan ( nixpath ( 1 : i - 4 ), '/' , back = . true .) if ( iback > 0 ) then j = iback + 1 cycle end if end if end if if ( i > 1 . and . j > 1 ) then ! Ignore current directory reference if ( nixpath ( i - 1 : i ) == './' ) then j = j - 1 cycle end if ! Ignore repeated separators if ( nixpath ( i - 1 : i ) == '//' ) then cycle end if ! Do NOT include trailing slash if ( i == len ( nixpath ) . and . nixpath ( i : i ) == '/' ) then cycle end if end if temp ( j : j ) = nixpath ( i : i ) j = j + 1 end do canon = temp ( 1 : j - 1 ) end function canon_path function dirname ( path ) result ( dir ) ! Extract dirname from path ! character ( * ), intent ( in ) :: path character (:), allocatable :: dir character (:), allocatable :: file_parts (:) dir = path ( 1 : scan ( path , '/\\',back=.true.)) end function dirname logical function is_dir(dir) character(*), intent(in) :: dir integer :: stat select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(\"test -d \" // dir , exitstat=stat) case (OS_WINDOWS) call execute_command_line(' cmd / c \"if not exist ' // windows_path(dir) // '\\ exit /B 1\" ', exitstat=stat) end select is_dir = (stat == 0) end function is_dir function join_path(a1,a2,a3,a4,a5) result(path) ! Construct path by joining strings with os file separator ! character(len=*), intent(in)           :: a1, a2 character(len=*), intent(in), optional :: a3, a4, a5 character(len=:), allocatable          :: path character(len=1)                       :: filesep select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) filesep = ' / ' case (OS_WINDOWS) filesep = ' \\ ' end select path = a1 // filesep // a2 if (present(a3)) then path = path // filesep // a3 else return end if if (present(a4)) then path = path // filesep // a4 else return end if if (present(a5)) then path = path // filesep // a5 else return end if end function join_path integer function number_of_rows(s) result(nrows) ! determine number or rows integer,intent(in)::s integer :: ios character(len=100) :: r rewind(s) nrows = 0 do read(s, ' ( A ) ', iostat=ios) r if (ios /= 0) exit nrows = nrows + 1 end do rewind(s) end function number_of_rows function read_lines(fh) result(lines) integer, intent(in) :: fh type(string_t), allocatable :: lines(:) integer :: i character(LINE_BUFFER_LEN) :: line_buffer allocate(lines(number_of_rows(fh))) do i = 1, size(lines) read(fh, ' ( A ) ') line_buffer lines(i)%s = trim(line_buffer) end do end function read_lines subroutine mkdir(dir) character(len=*), intent(in) :: dir integer                      :: stat if (is_dir(dir)) return select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(' mkdir - p ' // dir, exitstat=stat) write (*, ' ( \" + \" , 2 a ) ') ' mkdir - p ' // dir case (OS_WINDOWS) call execute_command_line(\"mkdir \" // windows_path(dir), exitstat=stat) write (*, ' ( \" + \" , 2 a ) ') ' mkdir ' // windows_path(dir) end select if (stat /= 0) then print *, ' execute_command_line () failed ' error stop end if end subroutine mkdir recursive subroutine list_files(dir, files, recurse) ! Get file & directory names in directory `dir`. ! !  - File/directory names return are relative to cwd, ie. preprended with `dir` !  - Includes files starting with `.` except current directory and parent directory ! character(len=*), intent(in) :: dir type(string_t), allocatable, intent(out) :: files(:) logical, intent(in), optional :: recurse integer :: stat, fh, i character(:), allocatable :: temp_file type(string_t), allocatable :: dir_files(:) type(string_t), allocatable :: sub_dir_files(:) if (.not. is_dir(dir)) then allocate (files(0)) return end if allocate (temp_file, source=get_temp_filename()) select case (get_os_type()) case (OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, OS_FREEBSD) call execute_command_line(' ls - A ' // dir // ' > ' // temp_file, & exitstat=stat) case (OS_WINDOWS) call execute_command_line(' dir / b ' // windows_path(dir) // ' > ' // temp_file, & exitstat=stat) end select if (stat /= 0) then print *, ' execute_command_line () failed ' error stop end if open (newunit=fh, file=temp_file, status=' old ') files = read_lines(fh) close(fh,status=\"delete\") do i=1,size(files) files(i)%s = join_path(dir,files(i)%s) end do if (present(recurse)) then if (recurse) then allocate(sub_dir_files(0)) do i=1,size(files) if (is_dir(files(i)%s)) then call list_files(files(i)%s, dir_files, recurse=.true.) sub_dir_files = [sub_dir_files, dir_files] end if end do files = [files, sub_dir_files] end if end if end subroutine list_files logical function exists(filename) result(r) character(len=*), intent(in) :: filename inquire(file=filename, exist=r) end function function get_temp_filename() result(tempfile) ! Get a unused temporary filename !  Calls posix ' tempnam ' - not recommended, but !   we have no security concerns for this application !   and use here is temporary. ! Works with MinGW ! use iso_c_binding, only: c_ptr, C_NULL_PTR, c_f_pointer character(:), allocatable :: tempfile type(c_ptr) :: c_tempfile_ptr character(len=1), pointer :: c_tempfile(:) interface function c_tempnam(dir,pfx) result(tmp) bind(c,name=\"tempnam\") import type(c_ptr), intent(in), value :: dir type(c_ptr), intent(in), value :: pfx type(c_ptr) :: tmp end function c_tempnam subroutine c_free(ptr) BIND(C,name=\"free\") import type(c_ptr), value :: ptr end subroutine c_free end interface c_tempfile_ptr = c_tempnam(C_NULL_PTR, C_NULL_PTR) call c_f_pointer(c_tempfile_ptr,c_tempfile,[LINE_BUFFER_LEN]) tempfile = f_string(c_tempfile) call c_free(c_tempfile_ptr) end function get_temp_filename function windows_path(path) result(winpath) ! Replace file system separators for windows ! character(*), intent(in) :: path character(:), allocatable :: winpath integer :: idx winpath = path idx = index(winpath,' / ') do while(idx > 0) winpath(idx:idx) = ' \\ ' idx = index(winpath,' / ') end do end function windows_path function unix_path(path) result(nixpath) ! Replace file system separators for unix ! character(*), intent(in) :: path character(:), allocatable :: nixpath integer :: idx nixpath = path idx = index(nixpath,' \\ ') do while(idx > 0) nixpath(idx:idx) = ' / ' idx = index(nixpath,' \\ ') end do end function unix_path subroutine getline(unit, line, iostat, iomsg) !> Formatted IO unit integer, intent(in) :: unit !> Line to read character(len=:), allocatable, intent(out) :: line !> Status of operation integer, intent(out) :: iostat !> Error message character(len=:), allocatable, optional :: iomsg character(len=LINE_BUFFER_LEN) :: buffer character(len=LINE_BUFFER_LEN) :: msg integer :: size integer :: stat allocate(character(len=0) :: line) do read(unit, ' ( a ) ', advance=' no ' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline subroutine delete_file ( file ) character ( len =* ), intent ( in ) :: file logical :: exist integer :: unit inquire ( file = file , exist = exist ) if ( exist ) then open ( file = file , newunit = unit ) close ( unit , status = \"delete\" ) end if end subroutine delete_file end module fpm_filesystem","tags":"","loc":"sourcefile/fpm_filesystem.f90.html"},{"title":"fpm_command_line.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_command_line Source Code fpm_command_line.f90 Source Code !># Definition of the command line interface !> !> This module uses [M_CLI2](https://github.com/urbanjost/M_CLI2) to define !> the command line interface. !> To define a command line interface create a new command settings type !> from the [[fpm_cmd_settings]] base class or the respective parent command !> settings. !> !> The subcommand is selected by the first non-option argument in the command !> line. In the subcase block the actual command line is defined and transferred !> to an instance of the [[fpm_cmd_settings]], the actual type is used by the !> *fpm* main program to determine which command entry point is chosen. !> !> To add a new subcommand add a new case to select construct and specify the !> wanted command line and the expected default values. !> Some of the following points also apply if you add a new option or argument !> to an existing *fpm* subcommand. !> Add this point you should create a help page for the new command in a simple !> catman-like format as well in the ``set_help`` procedure. !> Make sure to register new subcommands in the ``fpm-manual`` command by adding !> them to the manual character array and in the help/manual case as well. !> You should add the new command to the synopsis section of the ``fpm-list``, !> ``fpm-help`` and ``fpm --list`` help pages below to make sure the help output !> is complete and consistent as well. module fpm_command_line use fpm_environment , only : get_os_type , get_env , & OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_WINDOWS , & OS_CYGWIN , OS_SOLARIS , OS_FREEBSD use M_CLI2 , only : set_args , lget , sget , unnamed , remaining , specified use fpm_strings , only : lower , split use fpm_filesystem , only : basename , canon_path use , intrinsic :: iso_fortran_env , only : stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit implicit none private public :: fpm_cmd_settings , & fpm_build_settings , & fpm_install_settings , & fpm_new_settings , & fpm_run_settings , & fpm_test_settings , & fpm_update_settings , & get_command_line_settings type , abstract :: fpm_cmd_settings logical :: verbose = . true . end type integer , parameter :: ibug = 4096 type , extends ( fpm_cmd_settings ) :: fpm_new_settings character ( len = :), allocatable :: name logical :: with_executable = . false . logical :: with_test = . false . logical :: with_lib = . true . logical :: backfill = . true . end type type , extends ( fpm_cmd_settings ) :: fpm_build_settings logical :: list = . false . logical :: show_model = . false . character ( len = :), allocatable :: compiler character ( len = :), allocatable :: build_name end type type , extends ( fpm_build_settings ) :: fpm_run_settings character ( len = ibug ), allocatable :: name (:) character ( len = :), allocatable :: args character ( len = :), allocatable :: runner logical :: example end type type , extends ( fpm_run_settings ) :: fpm_test_settings end type type , extends ( fpm_build_settings ) :: fpm_install_settings character ( len = :), allocatable :: prefix character ( len = :), allocatable :: bindir character ( len = :), allocatable :: libdir character ( len = :), allocatable :: includedir logical :: no_rebuild end type !> Settings for interacting and updating with project dependencies type , extends ( fpm_cmd_settings ) :: fpm_update_settings character ( len = ibug ), allocatable :: name (:) logical :: fetch_only logical :: clean end type character ( len = :), allocatable :: name character ( len = :), allocatable :: os_type character ( len = ibug ), allocatable :: names (:) character ( len = :), allocatable :: tnames (:) character ( len = :), allocatable :: version_text (:) character ( len = :), allocatable :: help_new (:), help_fpm (:), help_run (:), & & help_test (:), help_build (:), help_usage (:), help_runner (:), & & help_text (:), help_install (:), help_help (:), help_update (:), & & help_list (:), help_list_dash (:), help_list_nodash (:) character ( len = 20 ), parameter :: manual ( * ) = [ character ( len = 20 ) :: & & ' ' , 'fpm' , 'new' , 'build' , 'run' , & & 'test' , 'runner' , 'install' , 'update' , 'list' , 'help' , 'version' ] character ( len = :), allocatable :: val_runner , val_build , val_compiler contains subroutine get_command_line_settings ( cmd_settings ) class ( fpm_cmd_settings ), allocatable , intent ( out ) :: cmd_settings character ( len = 4096 ) :: cmdarg integer :: i integer :: widest type ( fpm_install_settings ), allocatable :: install_settings call set_help () ! text for --version switch, select case ( get_os_type ()) case ( OS_LINUX ); os_type = \"OS Type:     Linux\" case ( OS_MACOS ); os_type = \"OS Type:     macOS\" case ( OS_WINDOWS ); os_type = \"OS Type:     Windows\" case ( OS_CYGWIN ); os_type = \"OS Type:     Cygwin\" case ( OS_SOLARIS ); os_type = \"OS Type:     Solaris\" case ( OS_FREEBSD ); os_type = \"OS Type:     FreeBSD\" case ( OS_UNKNOWN ); os_type = \"OS Type:     Unknown\" case default ; os_type = \"OS Type:     UNKNOWN\" end select version_text = [ character ( len = 80 ) :: & & 'Version:     0.1.3, alpha' , & & 'Program:     fpm(1)' , & & 'Description: A Fortran package manager and build system' , & & 'Home Page:   https://github.com/fortran-lang/fpm' , & & 'License:     MIT' , & & os_type ] ! find the subcommand name by looking for first word on command ! not starting with dash cmdarg = '' do i = 1 , command_argument_count () call get_command_argument ( i , cmdarg ) if ( adjustl ( cmdarg ( 1 : 1 )) . ne . '-' ) exit enddo ! now set subcommand-specific help text and process commandline ! arguments. Then call subcommand routine select case ( trim ( cmdarg )) case ( 'run' ) call set_args ( '& & --target \" \" & & --list F & & --release F& & --example F& & --runner \" \" & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_run , version_text ) call check_build_vals () if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif if ( specified ( 'target' ) ) then call split ( sget ( 'target' ), tnames , delimiters = ' ,:' ) names = [ character ( len = max ( len ( names ), len ( tnames ))) :: names , tnames ] endif allocate ( fpm_run_settings :: cmd_settings ) val_runner = sget ( 'runner' ) cmd_settings = fpm_run_settings (& & args = remaining ,& & build_name = val_build ,& & compiler = val_compiler , & & example = lget ( 'example' ), & & list = lget ( 'list' ),& & name = names ,& & runner = val_runner ,& & verbose = lget ( 'verbose' ) ) case ( 'build' ) call set_args ( '& & --release F & & --list F & & --show-model F & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_build , version_text ) call check_build_vals () allocate ( fpm_build_settings :: cmd_settings ) cmd_settings = fpm_build_settings ( & & build_name = val_build ,& & compiler = val_compiler , & & list = lget ( 'list' ),& & show_model = lget ( 'show-model' ),& & verbose = lget ( 'verbose' ) ) case ( 'new' ) call set_args ( '& & --src F & & --lib F & & --app F & & --test F & & --backfill F& & --verbose F' ,& & help_new , version_text ) select case ( size ( unnamed )) case ( 1 ) write ( stderr , '(*(g0,/))' ) '<ERROR> directory name required' write ( stderr , '(*(7x,g0,/))' ) & & '<USAGE> fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 1 case ( 2 ) name = trim ( unnamed ( 2 )) case default write ( stderr , '(g0)' ) '<ERROR> only one directory name allowed' write ( stderr , '(7x,g0)' ) & & '<USAGE> fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 2 end select !*! canon_path is not converting \".\", etc. name = canon_path ( name ) if ( . not . is_fortran_name ( basename ( name )) ) then write ( stderr , '(g0)' ) [ character ( len = 72 ) :: & & '<ERROR>the new directory basename must be an allowed ' , & & '       Fortran name. It must be composed of 1 to 63 ASCII' , & & '       characters and start with a letter and be composed' , & & '       entirely of alphanumeric characters [a-zA-Z0-9]' , & & '       and underscores.' ] stop 4 endif allocate ( fpm_new_settings :: cmd_settings ) if ( any ( specified ([ 'src ' , 'lib ' , 'app ' , 'test' ]) ) ) then cmd_settings = fpm_new_settings (& & backfill = lget ( 'backfill' ), & & name = name , & & with_executable = lget ( 'app' ), & & with_lib = any ([ lget ( 'lib' ), lget ( 'src' )]), & & with_test = lget ( 'test' ), & & verbose = lget ( 'verbose' ) ) else cmd_settings = fpm_new_settings (& & backfill = lget ( 'backfill' ) , & & name = name , & & with_executable = . true ., & & with_lib = . true ., & & with_test = . true ., & & verbose = lget ( 'verbose' ) ) endif case ( 'help' , 'manual' ) call set_args ( '& & --verbose F & & ' , help_help , version_text ) if ( size ( unnamed ). lt . 2 ) then if ( unnamed ( 1 ). eq . 'help' ) then unnamed = [ '   ' , 'fpm' ] else unnamed = manual endif elseif ( unnamed ( 2 ). eq . 'manual' ) then unnamed = manual endif widest = 256 allocate ( character ( len = widest ) :: help_text ( 0 )) do i = 2 , size ( unnamed ) select case ( unnamed ( i )) case ( '       ' ) case ( 'fpm    ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] case ( 'new    ' ) help_text = [ character ( len = widest ) :: help_text , help_new ] case ( 'build  ' ) help_text = [ character ( len = widest ) :: help_text , help_build ] case ( 'install' ) help_text = [ character ( len = widest ) :: help_text , help_install ] case ( 'run    ' ) help_text = [ character ( len = widest ) :: help_text , help_run ] case ( 'test   ' ) help_text = [ character ( len = widest ) :: help_text , help_test ] case ( 'runner' ) help_text = [ character ( len = widest ) :: help_text , help_runner ] case ( 'list   ' ) help_text = [ character ( len = widest ) :: help_text , help_list ] case ( 'update ' ) help_text = [ character ( len = widest ) :: help_text , help_update ] case ( 'help   ' ) help_text = [ character ( len = widest ) :: help_text , help_help ] case ( 'version' ) help_text = [ character ( len = widest ) :: help_text , version_text ] case default help_text = [ character ( len = widest ) :: help_text , & & '<ERROR> unknown help topic \"' // trim ( unnamed ( i )) // '\"' ] !!& '<ERROR> unknown help topic \"'//trim(unnamed(i)).'not found in:',manual] end select enddo call printhelp ( help_text ) case ( 'install' ) call set_args ( '--release F --no-rebuild F --verbose F --prefix \" \" & & --list F & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --libdir \"lib\" --bindir \"bin\" --includedir \"include\"' , & help_install , version_text ) call check_build_vals () allocate ( install_settings ) install_settings = fpm_install_settings (& list = lget ( 'list' ), & build_name = val_build , & compiler = val_compiler , & no_rebuild = lget ( 'no-rebuild' ), & verbose = lget ( 'verbose' )) call get_char_arg ( install_settings % prefix , 'prefix' ) call get_char_arg ( install_settings % libdir , 'libdir' ) call get_char_arg ( install_settings % bindir , 'bindir' ) call get_char_arg ( install_settings % includedir , 'includedir' ) call move_alloc ( install_settings , cmd_settings ) case ( 'list' ) call set_args ( '& & --list F& & --verbose F& &' , help_list , version_text ) call printhelp ( help_list_nodash ) if ( lget ( 'list' )) then call printhelp ( help_list_dash ) endif case ( 'test' ) call set_args ( '& & --target \" \" & & --list F& & --release F& & --runner \" \" & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_test , version_text ) call check_build_vals () if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif if ( specified ( 'target' ) ) then call split ( sget ( 'target' ), tnames , delimiters = ' ,:' ) names = [ character ( len = max ( len ( names ), len ( tnames ))) :: names , tnames ] endif allocate ( fpm_test_settings :: cmd_settings ) val_runner = sget ( 'runner' ) cmd_settings = fpm_test_settings (& & args = remaining , & & build_name = val_build , & & compiler = val_compiler , & & example = . false ., & & list = lget ( 'list' ), & & name = names , & & runner = val_runner , & & verbose = lget ( 'verbose' ) ) case ( 'update' ) call set_args ( '--fetch-only F --verbose F --clean F' , & help_update , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_update_settings :: cmd_settings ) cmd_settings = fpm_update_settings ( name = names , & fetch_only = lget ( 'fetch-only' ), verbose = lget ( 'verbose' ), & clean = lget ( 'clean' )) case default call set_args ( '& & --list F& & --verbose F& &' , help_fpm , version_text ) ! Note: will not get here if --version or --usage or --help ! is present on commandline help_text = help_usage if ( lget ( 'list' )) then help_text = help_list_dash elseif ( len_trim ( cmdarg ). eq . 0 ) then write ( stdout , '(*(a))' ) 'Fortran Package Manager:' write ( stdout , '(*(a))' ) ' ' call printhelp ( help_list_nodash ) else write ( stderr , '(*(a))' ) '<ERROR> unknown subcommand [' , & & trim ( cmdarg ), ']' call printhelp ( help_list_dash ) endif call printhelp ( help_text ) end select contains subroutine check_build_vals () val_compiler = sget ( 'compiler' ) if ( val_compiler . eq . '' ) then val_compiler = 'gfortran' endif val_build = trim ( merge ( 'release' , 'debug  ' , lget ( 'release' ))) end subroutine check_build_vals subroutine printhelp ( lines ) character ( len = :), intent ( in ), allocatable :: lines (:) integer :: iii , ii if ( allocated ( lines )) then ii = size ( lines ) if ( ii . gt . 0 . and . len ( lines ). gt . 0 ) then write ( stdout , '(g0)' )( trim ( lines ( iii )), iii = 1 , ii ) else write ( stdout , '(a)' ) '<WARNING> *printhelp* output requested is empty' endif endif end subroutine printhelp end subroutine get_command_line_settings function is_fortran_name ( line ) result ( lout ) ! determine if a string is a valid Fortran name ignoring trailing spaces ! (but not leading spaces) character ( len =* ), parameter :: int = '0123456789' character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character ( len =* ), parameter :: allowed = upper // lower // int // '_' character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: name logical :: lout name = trim ( line ) if ( len ( name ). ne . 0 ) then lout = . true . & & . and . verify ( name ( 1 : 1 ), lower // upper ) == 0 & & . and . verify ( name , allowed ) == 0 & & . and . len ( name ) <= 63 else lout = . false . endif end function is_fortran_name subroutine set_help () help_list_nodash = [ character ( len = 80 ) :: & 'USAGE: fpm [ SUBCOMMAND [SUBCOMMAND_OPTIONS] ]|[--list|--help|--version]' , & '       where SUBCOMMAND is commonly new|build|run|test                  ' , & '                                                                        ' , & ' subcommand may be one of                                               ' , & '                                                                        ' , & '  build     Compile the package placing results in the \"build\" directory' , & '  help      Display help                                                ' , & '  list      Display this list of subcommand descriptions                ' , & '  new       Create a new Fortran package directory with sample files    ' , & '  run       Run the local package application programs                  ' , & '  test      Run the test programs                                       ' , & '  update    Update and manage project dependencies                      ' , & '  install   Install project                                             ' , & '                                                                        ' , & ' Enter \"fpm --list\" for a brief list of subcommand options. Enter       ' , & ' \"fpm --help\" or \"fpm SUBCOMMAND --help\" for detailed descriptions.     ' , & ' ' ] help_list_dash = [ character ( len = 80 ) :: & '                                                                                ' , & ' build [--compiler COMPILER_NAME] [--release] [--list]                          ' , & ' help [NAME(s)]                                                                 ' , & ' new NAME [--lib|--src] [--app] [--test] [--backfill]                           ' , & ' update [NAME(s)] [--fetch-only] [--clean] [--verbose]                          ' , & ' list [--list]                                                                  ' , & ' run  [[--target] NAME(s)] [--release] [--runner \"CMD\"] [--list] [--example]    ' , & '      [--compiler COMPILER_NAME] [-- ARGS]                                      ' , & ' test [[--target] NAME(s)] [--release] [--runner \"CMD\"] [--list]                ' , & '      [--compiler COMPILER_NAME] [-- ARGS]                                      ' , & ' install [--release] [--no-rebuild] [--prefix PATH] [options]                   ' , & ' ' ] help_usage = [ character ( len = 80 ) :: & '' ] help_runner = [ character ( len = 80 ) :: & 'NAME                                                                            ' , & '   --runner(1) - a shared option for specifying an application to launch        ' , & '                 executables.                                                   ' , & '                                                                                ' , & 'SYNOPSIS                                                                        ' , & '   fpm run|test --runner CMD ... -- SUFFIX_OPTIONS                              ' , & '                                                                                ' , & 'DESCRIPTION                                                                     ' , & '   The --runner option allows specifying a program to launch                    ' , & '   executables selected via the fpm(1) subcommands \"run\" and \"test\". This       ' , & '   gives easy recourse to utilities such as debuggers and other tools           ' , & '   that wrap other executables.                                                 ' , & '                                                                                ' , & '   These external commands are not part of fpm(1) itself as they vary           ' , & '   from platform to platform or require independent installation.               ' , & '                                                                                ' , & 'OPTION                                                                          ' , & ' --runner ''CMD''  quoted command used to launch the fpm(1) executables.          ' , & '               Available for both the \"run\" and \"test\" subcommands.             ' , & '                                                                                ' , & ' -- SUFFIX_OPTIONS  additional options to suffix the command CMD and executable ' , & '                    file names with.                                            ' , & 'EXAMPLES                                                                        ' , & '   Use cases for ''fpm run|test --runner \"CMD\"'' include employing                ' , & '   the following common GNU/Linux and Unix commands:                            ' , & '                                                                                ' , & ' INTERROGATE                                                                    ' , & '    + nm - list symbols from object files                                       ' , & '    + size - list section sizes and total size.                                 ' , & '    + ldd - print shared object dependencies                                    ' , & '    + ls - list directory contents                                              ' , & '    + stat - display file or file system status                                 ' , & '    + file - determine file type                                                ' , & ' PERFORMANCE AND DEBUGGING                                                      ' , & '    + gdb - The GNU Debugger                                                    ' , & '    + valgrind - a suite of tools for debugging and profiling                   ' , & '    + time - time a simple command or give resource usage                       ' , & '    + timeout - run a command with a time limit                                 ' , & ' COPY                                                                           ' , & '    + install - copy files and set attributes                                   ' , & '    + tar - an archiving utility                                                ' , & ' ALTER                                                                          ' , & '    + rm - remove files or directories                                          ' , & '    + chmod - change permissions of a file                                      ' , & '    + strip - remove unnecessary information from strippable files              ' , & '                                                                                ' , & ' For example                                                                    ' , & '                                                                                ' , & '  fpm test --runner gdb                                                         ' , & '  fpm run --runner \"tar cvfz $HOME/bundle.tgz\"                                  ' , & '  fpm run --runner ldd                                                          ' , & '  fpm run --runner strip                                                        ' , & '  fpm run --runner ''cp -t /usr/local/bin''                                       ' , & '                                                                                ' , & '  # options after executable name can be specified after the -- option          ' , & '  fpm --runner cp run -- /usr/local/bin/                                        ' , & '  # generates commands of the form \"cp $FILENAME /usr/local/bin/\"               ' , & '                                                                                ' , & '  # bash(1) alias example:                                                      ' , & '  alias fpm-install=\\                                                           ' , & '  \"fpm run --release --runner ''install -vbp -m 0711 -t ~/.local/bin''\"           ' , & '  fpm-install                                                           ' , & '' ] help_fpm = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & '   fpm(1) - A Fortran package manager and build system                 ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & '   fpm SUBCOMMAND [SUBCOMMAND_OPTIONS]                                 ' , & '                                                                       ' , & '   fpm --help|--version|--list                                         ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & '   fpm(1) is a package manager that helps you create Fortran projects  ' , & '   from source.                                                        ' , & '                                                                       ' , & '   Most significantly fpm(1) lets you draw upon other fpm(1) packages  ' , & '   in distributed git(1) repositories as if the packages were a basic  ' , & '   part of your default programming environment, as well as letting    ' , & '   you share your projects with others in a similar manner.            ' , & '                                                                       ' , & '   All output goes into the directory \"build/\" which can generally be  ' , & '   removed and rebuilt if required. Note that if external packages are ' , & '   being used you need network connectivity to rebuild from scratch.   ' , & '                                                                       ' , & 'SUBCOMMANDS                                                            ' , & '  Valid fpm(1) subcommands are:                                        ' , & '                                                                       ' , & '  + build Compile the packages into the \"build/\" directory.            ' , & '  + new   Create a new Fortran package directory with sample files.    ' , & '  + update  Update the project dependencies.                           ' , & '  + run   Run the local package binaries. defaults to all binaries for ' , & '          that release.                                                ' , & '  + test  Run the tests.                                               ' , & '  + help  Alternate method for displaying subcommand help.             ' , & '  + list  Display brief descriptions of all subcommands.               ' , & '  + install Install project                                            ' , & '                                                                       ' , & '  Their syntax is                                                      ' , & '                                                                       ' , & '     build [--release] [--list] [--compiler COMPILER_NAME]             ' , & '     new NAME [--lib|--src] [--app] [--test] [--backfill]              ' , & '     update [NAME(s)] [--fetch-only] [--clean]                         ' , & '     run|test [[--target] NAME(s)] [--release] [--list]                ' , & '              [--runner \"CMD\"] [--compiler COMPILER_NAME] [-- ARGS]    ' , & '     help [NAME(s)]                                                    ' , & '     list [--list]                                                     ' , & '     install [--release] [--no-rebuild] [--prefix PATH] [options]      ' , & '                                                                       ' , & 'SUBCOMMAND OPTIONS                                                     ' , & '  --release  Builds or runs in release mode (versus debug mode). fpm(1)' , & '             Defaults to using common compiler debug flags and building' , & '             in \"build/*_debug/\". When this flag is present build      ' , & '             output goes into \"build/*_release/\" and common compiler   ' , & '             optimization flags are used.                              ' , & '  --list     List candidates instead of building or running them. On   ' , & '             the fpm(1) command this shows a brief list of subcommands.' , & '  --runner CMD   Provides a command to prefix program execution paths. ' , & '  --compiler COMPILER_NAME  Compiler name. The environment variable    ' , & '                            FPM_COMPILER sets the default.             ' , & '  -- ARGS    Arguments to pass to executables.                         ' , & '                                                                       ' , & 'VALID FOR ALL SUBCOMMANDS                                              ' , & '  --help     Show help text and exit                                   ' , & '  --verbose  Display additional information when available             ' , & '  --version  Show version information and exit.                        ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & '   sample commands:                                                    ' , & '                                                                       ' , & '    fpm new mypackage --app --test                                     ' , & '    fpm build                                                          ' , & '    fpm test                                                           ' , & '    fpm run                                                            ' , & '    fpm new --help                                                     ' , & '    fpm run myprogram --release -- -x 10 -y 20 --title \"my title\"      ' , & '    fpm install --prefix ~/.local                                      ' , & '                                                                       ' , & 'SEE ALSO                                                               ' , & '                                                                       ' , & ' + The fpm(1) home page is at https://github.com/fortran-lang/fpm               ' , & ' + Registered fpm(1) packages are at https://fortran-lang.org/packages          ' , & ' + The fpm(1) TOML file format is described at                                  ' , & '   https://github.com/fortran-lang/fpm/blob/master/manifest-reference.md        ' , & '' ] help_list = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' list(1) - list summary of fpm(1) subcommands                          ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm list [-list]                                                      ' , & '                                                                       ' , & ' fpm list --help|--version                                             ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Display a short description for each fpm(1) subcommand.               ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --list     display a list of command options as well. This is the     ' , & '            same output as generated by \"fpm --list\".                  ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' display a short list of fpm(1) subcommands                            ' , & '                                                                       ' , & '  fpm list                                                             ' , & '  fpm --list                                                           ' , & '' ] help_run = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' run(1) - the fpm(1) subcommand to run project applications            ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm run [[--target] NAME(s)][--release][--compiler COMPILER_NAME]     ' , & '         [--runner \"CMD\"] [--example] [--list][-- ARGS]                ' , & '                                                                       ' , & ' fpm run --help|--version                                              ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Run applications you have built in your fpm(1) project.               ' , & ' By default applications specified in as \"executable\" in your package  ' , & ' manifest are used, alternatively also demonstration programs under    ' , & ' \"example\" can be used with this subcommand.                           ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --target NAME(s)  optional list of specific names to execute.         ' , & '                   The default is to run all the applications in app/  ' , & '                   or the programs listed in the \"fpm.toml\" file.      ' , & ' --example  run example programs instead of applications               ' , & ' --release  selects the optimized build instead of the debug           ' , & '            build.                                                     ' , & ' --compiler COMPILER_NAME  Specify a compiler name. The default is     ' , & '                           \"gfortran\" unless set by the environment    ' , & '                           variable FPM_COMPILER.                      ' , & ' --runner CMD  A command to prefix the program execution paths with.   ' , & '               see \"fpm help runner\" for further details.              ' , & ' --list     list candidates instead of building or running them        ' , & ' -- ARGS    optional arguments to pass to the program(s).              ' , & '            The same arguments are passed to all names                 ' , & '            specified.                                                 ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' fpm(1) \"run\" project applications                                     ' , & '                                                                       ' , & '  # run default programs in /app or as specified in \"fpm.toml\"         ' , & '  fpm run                                                              ' , & '                                                                       ' , & '  # run default programs in /app or as specified in \"fpm.toml\"         ' , & '  # using the compiler command \"f90\".                                  ' , & '  fpm run --compiler f90                                               ' , & '                                                                       ' , & '  # run example and demonstration programs instead of the default      ' , & '  # application programs (specified in \"fpm.toml\")                     ' , & '  fpm run --example                                                    ' , & '                                                                       ' , & '  # run a specific program and pass arguments to the command           ' , & '  fpm run mytest -- -x 10 -y 20 --title \"my title line\"                ' , & '                                                                       ' , & '  # run production version of two applications                         ' , & '  fpm run --target prg1,prg2 --release                                 ' , & '                                                                       ' , & '  # install executables in directory (assuming install(1) exists)      ' , & '  fpm run --runner ''install -b -m 0711 -p -t /usr/local/bin''         ' , & '' ] help_build = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' build(1) - the fpm(1) subcommand to build a project                   ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm build [--release][--compiler COMPILER_NAME] [-list]               ' , & '                                                                       ' , & ' fpm build --help|--version                                            ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' The \"fpm build\" command                                               ' , & '    o Fetches any dependencies                                         ' , & '    o Scans your sources                                               ' , & '    o Builds them in the proper order                                  ' , & '                                                                       ' , & ' The Fortran source files are assumed by default to be in              ' , & '    o src/     for modules and procedure source                        ' , & '    o app/     main program(s) for applications                        ' , & '    o test/    main program(s) and support files for project tests     ' , & ' Changed or new files found are rebuilt. The results are placed in     ' , & ' the build/ directory.                                                 ' , & '                                                                       ' , & ' Non-default pathnames and remote dependencies are used if             ' , & ' specified in the \"fpm.toml\" file.                                     ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --release    build in build/*_release instead of build/*_debug with   ' , & '              high optimization instead of full debug options.         ' , & ' --compiler   COMPILER_NAME  Specify a compiler name. The default is   ' , & '                           \"gfortran\" unless set by the environment    ' , & '                           variable FPM_COMPILER.                      ' , & ' --list       list candidates instead of building or running them      ' , & ' --show-model show the model and exit (do not build)                   ' , & ' --help       print this help and exit                                 ' , & ' --version    print program version information and exit               ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' Sample commands:                                                      ' , & '                                                                       ' , & '  fpm build           # build with debug options                       ' , & '  fpm build --release # build with high optimization                   ' , & '' ] help_help = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & '   help(1) - the fpm(1) subcommand to display help                     ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & '   fpm help [fpm] [new] [build] [run] [test] [help] [version] [manual] ' , & '   [runner]                                                            ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & '   The \"fpm help\" command is an alternative to the --help parameter    ' , & '   on the fpm(1) command and its subcommands.                          ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & '   NAME(s)    A list of topic names to display. All the subcommands    ' , & '              have their own page (new, build, run, test, ...).        ' , & '                                                                       ' , & '              The special name \"manual\" displays all the fpm(1)        ' , & '              built-in documentation.                                  ' , & '                                                                       ' , & '              The default is to display help for the fpm(1) command    ' , & '              itself.                                                  ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & '   Sample usage:                                                       ' , & '                                                                       ' , & '     fpm help           # general fpm(1) command help                  ' , & '     fpm help version   # show program version                         ' , & '     fpm help new       # display help for \"new\" subcommand            ' , & '     fpm help manual    # All fpm(1) built-in documentation            ' , & '                                                                       ' , & '' ] help_new = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' new(1) - the fpm(1) subcommand to initialize a new project            ' , & 'SYNOPSIS                                                               ' , & ' fpm new NAME [--lib|--src] [--app] [--test] [--backfill]              ' , & '                                                                       ' , & ' fpm new --help|--version                                              ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' \"fpm new\" creates and populates a new programming project directory.  ' , & ' It                                                                    ' , & '   o creates a directory with the specified name                       ' , & '   o runs the command \"git init\" in that directory                     ' , & '   o populates the directory with the default project directories      ' , & '   o adds sample Fortran source files                                  ' , & '   o adds a \".gitignore\" file for ignoring the build/ directory        ' , & '     (where fpm-generated output will be placed)                       ' , & '                                                                       ' , & ' The basic default file structure is                                   ' , & '                                                                       ' , & '     NAME/                                                             ' , & '       fpm.toml                                                        ' , & '       .gitignore                                                      ' , & '       src/                                                            ' , & '           NAME.f90                                                    ' , & '       app/                                                            ' , & '           main.f90                                                    ' , & '       test/                                                           ' , & '           main.f90                                                    ' , & '                                                                       ' , & ' Remember to update the information in the sample \"fpm.toml\"           ' , & ' file with your name and e-mail address.                               ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' NAME   the name of the project directory to create. The name          ' , & '        must be a valid Fortran name composed of 1 to 63               ' , & '        ASCII alphanumeric characters and underscores,                 ' , & '        starting with a letter.                                        ' , & '                                                                       ' , & ' The default is to create all of the src/, app/, and test/             ' , & ' directories. If any of the following options are specified            ' , & ' then only selected subdirectories are generated:                      ' , & '                                                                       ' , & ' --lib,--src  create directory src/ and a placeholder module           ' , & '              named \"NAME.f90\" for use with subcommand \"build\".        ' , & ' --app        create directory app/ and a placeholder main             ' , & '              program for use with subcommand \"run\".                   ' , & ' --test       create directory test/ and a placeholder program         ' , & '              for use with the subcommand \"test\". Note that sans       ' , & '              \"--lib\" it really does not have anything to test.        ' , & '                                                                       ' , & ' So the default is equivalent to \"fpm NAME --lib --app --test\".        ' , & '                                                                       ' , & ' --backfill   By default the directory must not exist. If this         ' , & '              option is present the directory may pre-exist and        ' , & '              only subdirectories and files that do not                ' , & '              already exist will be created. For example, if you       ' , & '              previously entered \"fpm new myname --lib\" entering       ' , & '              \"fpm new myname --backfill\" will create the missing      ' , & '              app/ and test/ directories and programs.                 ' , & '                                                                       ' , & ' --help       print this help and exit                                 ' , & ' --version    print program version information and exit               ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & ' Sample use                                                            ' , & '                                                                       ' , & '   fpm new myproject  # create new project directory and seed it       ' , & '   cd myproject       # Enter the new directory                        ' , & '   # and run commands such as                                          ' , & '   fpm build                                                           ' , & '   fpm run            # run example application program                ' , & '   fpm test           # run example test program                       ' , & '' ] help_test = [ character ( len = 80 ) :: & 'NAME                                                                   ' , & ' test(1) - the fpm(1) subcommand to run project tests                  ' , & '                                                                       ' , & 'SYNOPSIS                                                               ' , & ' fpm test [[--target] NAME(s)][--release][--compiler COMPILER_NAME ]   ' , & '          [--runner \"CMD\"] [--list][-- ARGS]                           ' , & '                                                                       ' , & ' fpm test --help|--version                                             ' , & '                                                                       ' , & 'DESCRIPTION                                                            ' , & ' Run applications you have built to test your project.                 ' , & '                                                                       ' , & 'OPTIONS                                                                ' , & ' --target NAME(s)  optional list of specific test names to execute.    ' , & '                   The default is to run all the tests in test/        ' , & '                   or the tests listed in the \"fpm.toml\" file.         ' , & ' --release  selects the optimized build instead of the debug           ' , & '            build.                                                     ' , & ' --compiler COMPILER_NAME  Specify a compiler name. The default is     ' , & '                           \"gfortran\" unless set by the environment    ' , & '                           variable FPM_COMPILER.                      ' , & ' --runner CMD  A command to prefix the program execution paths with.   ' , & '               see \"fpm help runner\" for further details.              ' , & ' --list     list candidates instead of building or running them        ' , & ' -- ARGS    optional arguments to pass to the test program(s).         ' , & '            The same arguments are passed to all test names            ' , & '            specified.                                                 ' , & '                                                                       ' , & 'EXAMPLES                                                               ' , & 'run tests                                                              ' , & '                                                                       ' , & ' # run default tests in /test or as specified in \"fpm.toml\"            ' , & ' fpm test                                                              ' , & '                                                                       ' , & ' # run using compiler command \"f90\"                                    ' , & ' fpm test --compiler f90                                               ' , & '                                                                       ' , & ' # run a specific test and pass arguments to the command               ' , & ' fpm test mytest -- -x 10 -y 20 --title \"my title line\"                ' , & '                                                                       ' , & ' fpm test tst1 tst2 --release # run production version of two tests    ' , & '' ] help_update = [ character ( len = 80 ) :: & 'NAME' , & ' update(1) - manage project dependencies' , & '' , & 'SYNOPSIS' , & ' fpm update [--fetch-only] [--clean] [--verbose] [NAME(s)]' , & '' , & 'DESCRIPTION' , & ' Manage and update project dependencies. If no dependency names are' , & ' provided all the dependencies are updated automatically.' , & '' , & 'OPTIONS' , & ' --fetch-only  Only fetch dependencies, do not update existing projects' , & ' --clean       Do not use previous dependency cache' , & ' --verbose     Show additional printout' , & '' , & 'SEE ALSO' , & ' The fpm(1) home page at https://github.com/fortran-lang/fpm' , & '' ] help_install = [ character ( len = 80 ) :: & 'NAME' , & ' install(1) - install fpm projects' , & '' , & 'SYNOPSIS' , & ' fpm install [--release] [--list] [--no-rebuild] [--prefix DIR]' , & '             [--bindir DIR] [--libdir DIR] [--includedir DIR]' , & '             [--verbose]' , & '' , & 'DESCRIPTION' , & ' Subcommand to install fpm projects. Running install will export the' , & ' current project to the selected prefix, this will by default install all' , & ' executables (test and examples are excluded) which are part of the projects.' , & ' Libraries and module files are only installed for projects requiring the' , & ' installation of those components in the package manifest.' , & '' , & 'OPTIONS' , & ' --list            list all installable targets for this project,' , & '                   but do not install any of them' , & ' --release         selects the optimized build instead of the debug build' , & ' --no-rebuild      do not rebuild project before installation' , & ' --prefix DIR      path to installation directory (requires write access),' , & '                   the default prefix on Unix systems is $HOME/.local' , & '                   and %APPDATA%\\local on Windows' , & ' --bindir DIR      subdirectory to place executables in (default: bin)' , & ' --libdir DIR      subdirectory to place libraries and archives in' , & '                   (default: lib)' , & ' --includedir DIR  subdirectory to place headers and module files in' , & '                   (default: include)' , & ' --verbose         print more information' , & '' , & 'EXAMPLES' , & ' 1. Install release version of project:' , & '' , & '    fpm install --release' , & '' , & ' 2. Install the project without rebuilding the executables:' , & '' , & '    fpm install --no-rebuild' , & '' , & ' 3. Install executables to a custom prefix into the exe directory:' , & '' , & '    fpm install --prefix $PWD --bindir exe' , & '' ] end subroutine set_help subroutine get_char_arg ( var , arg ) character ( len = :), allocatable , intent ( out ) :: var character ( len =* ), intent ( in ) :: arg var = sget ( arg ) if ( len_trim ( var ) == 0 ) deallocate ( var ) end subroutine get_char_arg end module fpm_command_line","tags":"","loc":"sourcefile/fpm_command_line.f90.html"},{"title":"fpm_source_parsing.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_source_parsing Source Code fpm_source_parsing.f90 Source Code !># Parsing of package source files !> !> This module exposes two functions, `[[parse_f_source]]` and `[[parse_c_source]]`, !> which perform a rudimentary parsing of fortran and c source files !> in order to extract information required for module dependency tracking. !> !> Both functions additionally calculate and store a file digest (hash) which !> is used by the backend ([[fpm_backend]]) to skip compilation of unmodified sources. !> !> Both functions return an instance of the [[srcfile_t]] type. !> !> For more information, please read the documentation for each function: !> !> - `[[parse_f_source]]` !> - `[[parse_c_source]]` !> module fpm_source_parsing use fpm_error , only : error_t , file_parse_error , fatal_error use fpm_strings , only : string_t , string_cat , split , lower , str_ends_with , fnv_1a use fpm_model , only : srcfile_t , & FPM_UNIT_UNKNOWN , FPM_UNIT_PROGRAM , FPM_UNIT_MODULE , & FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , & FPM_UNIT_CSOURCE , FPM_UNIT_CHEADER , FPM_SCOPE_UNKNOWN , & FPM_SCOPE_LIB , FPM_SCOPE_DEP , FPM_SCOPE_APP , FPM_SCOPE_TEST use fpm_filesystem , only : read_lines implicit none private public :: parse_f_source , parse_c_source character ( 15 ), parameter :: INTRINSIC_MODULE_NAMES ( * ) = & [ 'iso_c_binding  ' , & 'iso_fortran_env' , & 'ieee_arithmetic' , & 'ieee_exceptions' , & 'ieee_features  ' ] contains !> Parsing of free-form fortran source files !> !> The following statements are recognised and parsed: !> !> - `Module`/`submodule`/`program` declaration !> - Module `use` statement !> - `include` statement !> !> @note Intrinsic modules used by sources are not listed in !> the `modules_used` field of source objects. !> !> @note Submodules are treated as normal modules which `use` their !> corresponding parent modules. !> !>### Parsing limitations !> !> __Statements must not continued onto another line !>  except for an `only:` list in the `use` statement.__ !> !> This is supported: !> !>```fortran !> use my_module, only: & !>      my_var, my_function, my_subroutine !>``` !> !> This is __NOT supported:__ !> !>```fortran !> use & !>    my_module !>``` !> function parse_f_source ( f_filename , error ) result ( f_source ) character ( * ), intent ( in ) :: f_filename type ( srcfile_t ) :: f_source type ( error_t ), allocatable , intent ( out ) :: error integer :: stat integer :: fh , n_use , n_include , n_mod , i , j , ic , pass type ( string_t ), allocatable :: file_lines (:) character (:), allocatable :: temp_string , mod_name f_source % file_name = f_filename open ( newunit = fh , file = f_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) ! Ignore empty files, returned as FPM_UNIT_UNKNOW if ( len_trim ( string_cat ( file_lines , ' ' )) < 1 ) return f_source % digest = fnv_1a ( file_lines ) do pass = 1 , 2 n_use = 0 n_include = 0 n_mod = 0 file_loop : do i = 1 , size ( file_lines ) ! Skip lines that are continued: not statements if ( i > 1 ) then ic = index ( file_lines ( i - 1 )% s , '!' ) if ( ic < 1 ) then ic = len ( file_lines ( i - 1 )% s ) end if temp_string = trim ( file_lines ( i - 1 )% s ( 1 : ic )) if ( len ( temp_string ) > 0 . and . index ( temp_string , '&' ) == len ( temp_string )) then cycle end if end if ! Process 'USE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'use ' ) == 1 . or . & index ( adjustl ( lower ( file_lines ( i )% s )), 'use::' ) == 1 ) then if ( index ( file_lines ( i )% s , '::' ) > 0 ) then temp_string = split_n ( file_lines ( i )% s , delims = ':' , n = 2 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '::' )) return end if mod_name = split_n ( temp_string , delims = ' ,' , n = 1 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) else mod_name = split_n ( file_lines ( i )% s , n = 2 , delims = ' ,' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) end if if (. not . validate_name ( mod_name )) then cycle end if if ( any ([( index ( mod_name , trim ( INTRINSIC_MODULE_NAMES ( j ))) > 0 , & j = 1 , size ( INTRINSIC_MODULE_NAMES ))])) then cycle end if n_use = n_use + 1 if ( pass == 2 ) then f_source % modules_used ( n_use )% s = mod_name end if end if ! Process 'INCLUDE' statements ic = index ( adjustl ( lower ( file_lines ( i )% s )), 'include' ) if ( ic == 1 ) then ic = index ( lower ( file_lines ( i )% s ), 'include' ) if ( index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), '\"' ) == 1 . or . & index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), \"'\" ) == 1 ) then n_include = n_include + 1 if ( pass == 2 ) then f_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = \"'\" // '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find include file name' , i , & file_lines ( i )% s ) return end if end if end if end if ! Extract name of module if is module if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'module ' ) == 1 ) then mod_name = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find module name' , i , & file_lines ( i )% s ) return end if if ( mod_name == 'procedure' . or . & mod_name == 'subroutine' . or . & mod_name == 'function' . or . & scan ( mod_name , '=(' ) > 0 ) then ! Ignore these cases: ! module procedure * ! module function * ! module subroutine * ! module =* ! module (i) cycle end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for module' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 if ( pass == 2 ) then f_source % modules_provided ( n_mod ) = string_t ( mod_name ) end if f_source % unit_type = FPM_UNIT_MODULE end if ! Extract name of submodule if is submodule if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'submodule' ) == 1 ) then mod_name = split_n ( file_lines ( i )% s , n = 3 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule name' , i , & file_lines ( i )% s ) return end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 temp_string = split_n ( file_lines ( i )% s , n = 2 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule ancestry' , i , & file_lines ( i )% s ) return end if f_source % unit_type = FPM_UNIT_SUBMODULE n_use = n_use + 1 if ( pass == 2 ) then if ( index ( temp_string , ':' ) > 0 ) then temp_string = temp_string ( index ( temp_string , ':' ) + 1 :) end if if (. not . validate_name ( temp_string )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule parent' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , temp_string )) return end if f_source % modules_used ( n_use )% s = lower ( temp_string ) f_source % modules_provided ( n_mod )% s = lower ( mod_name ) end if end if ! Detect if contains a program !  (no modules allowed after program def) if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'program ' ) == 1 ) then temp_string = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat == 0 ) then if ( scan ( temp_string , '=(' ) > 0 ) then ! Ignore: ! program =* ! program (i) =* cycle end if end if f_source % unit_type = FPM_UNIT_PROGRAM end if end do file_loop ! Default to subprogram unit type if ( f_source % unit_type == FPM_UNIT_UNKNOWN ) then f_source % unit_type = FPM_UNIT_SUBPROGRAM end if if ( pass == 1 ) then allocate ( f_source % modules_used ( n_use )) allocate ( f_source % include_dependencies ( n_include )) allocate ( f_source % modules_provided ( n_mod )) end if end do contains function validate_name ( name ) result ( valid ) character ( * ), intent ( in ) :: name logical :: valid integer :: i if ( len_trim ( name ) < 1 ) then valid = . false . return end if if ( lower ( name ( 1 : 1 )) < 'a' . or . & lower ( name ( 1 : 1 )) > 'z' ) then valid = . false . return end if do i = 1 , len ( name ) if (. not .( & ( name ( i : i ) >= '0' . and . name ( i : i ) <= '9' ). or . & ( lower ( name ( i : i )) >= 'a' . and . lower ( name ( i : i )) <= 'z' ). or . & name ( i : i ) == '_' ) ) then valid = . false . return end if end do valid = . true . return end function validate_name end function parse_f_source !> Parsing of c source files !> !> The following statements are recognised and parsed: !> !> - `#include` preprocessor statement !> function parse_c_source ( c_filename , error ) result ( c_source ) character ( * ), intent ( in ) :: c_filename type ( srcfile_t ) :: c_source type ( error_t ), allocatable , intent ( out ) :: error integer :: fh , n_include , i , pass , stat type ( string_t ), allocatable :: file_lines (:) c_source % file_name = c_filename if ( str_ends_with ( lower ( c_filename ), \".c\" )) then c_source % unit_type = FPM_UNIT_CSOURCE elseif ( str_ends_with ( lower ( c_filename ), \".h\" )) then c_source % unit_type = FPM_UNIT_CHEADER end if allocate ( c_source % modules_used ( 0 )) allocate ( c_source % modules_provided ( 0 )) open ( newunit = fh , file = c_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) ! Ignore empty files, returned as FPM_UNIT_UNKNOW if ( len_trim ( string_cat ( file_lines , ' ' )) < 1 ) then c_source % unit_type = FPM_UNIT_UNKNOWN return end if c_source % digest = fnv_1a ( file_lines ) do pass = 1 , 2 n_include = 0 file_loop : do i = 1 , size ( file_lines ) ! Process 'INCLUDE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), '#include' ) == 1 . and . & index ( file_lines ( i )% s , '\"' ) > 0 ) then n_include = n_include + 1 if ( pass == 2 ) then c_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , c_filename , & 'unable to get c include file' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '\"' )) return end if end if end if end do file_loop if ( pass == 1 ) then allocate ( c_source % include_dependencies ( n_include )) end if end do end function parse_c_source !> Split a string on one or more delimeters !>  and return the nth substring if it exists !> !> n=0  will return the last item !> n=-1 will return the penultimate item etc. !> !> stat = 1 on return if the index !>  is not found !> function split_n ( string , delims , n , stat ) result ( substring ) character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: delims integer , intent ( in ) :: n integer , intent ( out ) :: stat character (:), allocatable :: substring integer :: i character (:), allocatable :: string_parts (:) call split ( string , string_parts , delims ) if ( n < 1 ) then i = size ( string_parts ) + n if ( i < 1 ) then stat = 1 return end if else i = n end if if ( i > size ( string_parts )) then stat = 1 return end if substring = trim ( adjustl ( string_parts ( i ))) stat = 0 end function split_n end module fpm_source_parsing","tags":"","loc":"sourcefile/fpm_source_parsing.f90.html"},{"title":"fpm_sources.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_sources Source Code fpm_sources.f90 Source Code !># Discovery of sources !> !> This module implements subroutines for building a list of !> `[[srcfile_t]]` objects by looking for source files in the filesystem. !> module fpm_sources use fpm_error , only : error_t use fpm_model , only : srcfile_t , FPM_UNIT_PROGRAM use fpm_filesystem , only : basename , canon_path , dirname , join_path , list_files use fpm_strings , only : lower , str_ends_with , string_t , operator (. in .) use fpm_source_parsing , only : parse_f_source , parse_c_source use fpm_manifest_executable , only : executable_config_t implicit none private public :: add_sources_from_dir , add_executable_sources character ( 4 ), parameter :: fortran_suffixes ( 2 ) = [ \".f90\" , & \".f  \" ] contains !> Wrapper to source parsing routines. !> Selects parsing routine based on source file name extension function parse_source ( source_file_path , error ) result ( source ) character ( * ), intent ( in ) :: source_file_path type ( error_t ), allocatable , intent ( out ) :: error type ( srcfile_t ) :: source if ( str_ends_with ( lower ( source_file_path ), fortran_suffixes )) then source = parse_f_source ( source_file_path , error ) if ( source % unit_type == FPM_UNIT_PROGRAM ) then source % exe_name = basename ( source_file_path , suffix = . false .) end if else if ( str_ends_with ( lower ( source_file_path ), [ \".c\" , \".h\" ])) then source = parse_c_source ( source_file_path , error ) end if if ( allocated ( error )) then return end if end function parse_source !> Add to `sources` by looking for source files in `directory` subroutine add_sources_from_dir ( sources , directory , scope , with_executables , recurse , error ) !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) !> Directory in which to search for source files character ( * ), intent ( in ) :: directory !> Scope to apply to the discovered sources, see [[fpm_model]] for enumeration integer , intent ( in ) :: scope !> Executable sources (fortran `program`s) are ignored unless `with_executables=.true.` logical , intent ( in ), optional :: with_executables !> Whether to recursively search subdirectories, default is `.true.` logical , intent ( in ), optional :: recurse !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i logical , allocatable :: is_source (:), exclude_source (:) type ( string_t ), allocatable :: file_names (:) type ( string_t ), allocatable :: src_file_names (:) type ( string_t ), allocatable :: existing_src_files (:) type ( srcfile_t ), allocatable :: dir_sources (:) ! Scan directory for sources call list_files ( directory , file_names , recurse = merge ( recurse ,. true ., present ( recurse ))) if ( allocated ( sources )) then allocate ( existing_src_files ( size ( sources ))) do i = 1 , size ( sources ) existing_src_files ( i )% s = canon_path ( sources ( i )% file_name ) end do else allocate ( existing_src_files ( 0 )) end if is_source = [(. not .( canon_path ( file_names ( i )% s ) . in . existing_src_files ) . and . & ( str_ends_with ( lower ( file_names ( i )% s ), fortran_suffixes ) . or . & str_ends_with ( lower ( file_names ( i )% s ),[ \".c\" , \".h\" ]) ), i = 1 , size ( file_names ))] src_file_names = pack ( file_names , is_source ) allocate ( dir_sources ( size ( src_file_names ))) allocate ( exclude_source ( size ( src_file_names ))) do i = 1 , size ( src_file_names ) dir_sources ( i ) = parse_source ( src_file_names ( i )% s , error ) if ( allocated ( error )) return dir_sources ( i )% unit_scope = scope ! Exclude executables unless specified otherwise exclude_source ( i ) = ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM ) if ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM . and . & & present ( with_executables )) then if ( with_executables ) then exclude_source ( i ) = . false . end if end if end do if (. not . allocated ( sources )) then sources = pack ( dir_sources ,. not . exclude_source ) else sources = [ sources , pack ( dir_sources ,. not . exclude_source )] end if end subroutine add_sources_from_dir !> Add to `sources` using the executable and test entries in the manifest and !> applies any executable-specific overrides such as `executable%name`. !> Adds all sources (including modules) from each `executable%source_dir` subroutine add_executable_sources ( sources , executables , scope , auto_discover , error ) !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) !> List of `[[executable_config_t]]` entries from manifest class ( executable_config_t ), intent ( in ) :: executables (:) !> Scope to apply to the discovered sources: either `FPM_SCOPE_APP` or `FPM_SCOPE_TEST`, see [[fpm_model]] integer , intent ( in ) :: scope !> If `.false.` only executables and tests specified in the manifest are added to `sources` logical , intent ( in ) :: auto_discover !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j type ( string_t ), allocatable :: exe_dirs (:) type ( srcfile_t ) :: exe_source call get_executable_source_dirs ( exe_dirs , executables ) do i = 1 , size ( exe_dirs ) call add_sources_from_dir ( sources , exe_dirs ( i )% s , scope , & with_executables = auto_discover , recurse = . false ., error = error ) if ( allocated ( error )) then return end if end do exe_loop : do i = 1 , size ( executables ) ! Check if executable already discovered automatically !  and apply any overrides do j = 1 , size ( sources ) if ( basename ( sources ( j )% file_name , suffix = . true .) == executables ( i )% main . and .& canon_path ( dirname ( sources ( j )% file_name )) == & canon_path ( executables ( i )% source_dir ) ) then sources ( j )% exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if cycle exe_loop end if end do ! Add if not already discovered (auto_discovery off) exe_source = parse_source ( join_path ( executables ( i )% source_dir , executables ( i )% main ), error ) exe_source % exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if exe_source % unit_scope = scope if ( allocated ( error )) return if (. not . allocated ( sources )) then sources = [ exe_source ] else sources = [ sources , exe_source ] end if end do exe_loop end subroutine add_executable_sources !> Build a list of unique source directories !>  from executables specified in manifest subroutine get_executable_source_dirs ( exe_dirs , executables ) type ( string_t ), allocatable , intent ( inout ) :: exe_dirs (:) class ( executable_config_t ), intent ( in ) :: executables (:) type ( string_t ) :: dirs_temp ( size ( executables )) integer :: i , n n = 0 do i = 1 , size ( executables ) if (. not .( executables ( i )% source_dir . in . dirs_temp )) then n = n + 1 dirs_temp ( n )% s = executables ( i )% source_dir end if end do if (. not . allocated ( exe_dirs )) then exe_dirs = dirs_temp ( 1 : n ) else exe_dirs = [ exe_dirs , dirs_temp ( 1 : n )] end if end subroutine get_executable_source_dirs end module fpm_sources","tags":"","loc":"sourcefile/fpm_sources.f90.html"},{"title":"fpm_model.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_model Source Code fpm_model.f90 Source Code !># The fpm package model !> !> Defines the fpm model data types which encapsulate all information !> required to correctly build a package and its dependencies. !> !> The process (see `[[build_model(subroutine)]]`) for generating a valid `[[fpm_model]]` is as follows: !> !> 1. Source files are discovered ([[fpm_sources]]) and parsed ([[fpm_source_parsing]]) !> 2. A list of build targets is generated (`[[targets_from_sources]]`) from the sources !> 3. Inter-target dependencies are resolved (`[[resolve_module_dependencies]]`) based on modules used and provided !> 4. Object link lists are generated for link targets (executables and libraries) (`[[resolve_target_linking]]`) !> !> Once a valid `[[fpm_model]]` has been constructed, it may be passed to `[[fpm_backend:build_package]]` to !> build the package. !> !>### Enumerations !> !> __Source type:__ `FPM_UNIT_*` !> Describes the type of source file — determines build target generation !> !> __Source scope:__ `FPM_SCOPE_*` !> Describes the scoping rules for using modules — controls module dependency resolution !> !> __Target type:__ `FPM_TARGET_*` !> Describes the type of build target — determines backend build rules !> module fpm_model use iso_fortran_env , only : int64 use fpm_strings , only : string_t , str use fpm_dependency , only : dependency_tree_t implicit none private public :: fpm_model_t , srcfile_t , build_target_t , build_target_ptr , & show_model public :: FPM_UNIT_UNKNOWN , FPM_UNIT_PROGRAM , FPM_UNIT_MODULE , & FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE , & FPM_UNIT_CHEADER , FPM_SCOPE_UNKNOWN , FPM_SCOPE_LIB , & FPM_SCOPE_DEP , FPM_SCOPE_APP , FPM_SCOPE_EXAMPLE , FPM_SCOPE_TEST , & FPM_TARGET_UNKNOWN , FPM_TARGET_EXECUTABLE , FPM_TARGET_ARCHIVE , & FPM_TARGET_OBJECT !> Source type unknown integer , parameter :: FPM_UNIT_UNKNOWN = - 1 !> Source type is fortran program integer , parameter :: FPM_UNIT_PROGRAM = 1 !> Source type is fortran module integer , parameter :: FPM_UNIT_MODULE = 2 !> Source type is fortran submodule integer , parameter :: FPM_UNIT_SUBMODULE = 3 !> Source type is fortran subprogram integer , parameter :: FPM_UNIT_SUBPROGRAM = 4 !> Source type is c source file integer , parameter :: FPM_UNIT_CSOURCE = 5 !> Source type is c header file integer , parameter :: FPM_UNIT_CHEADER = 6 !> Source has no module-use scope integer , parameter :: FPM_SCOPE_UNKNOWN = - 1 !> Module-use scope is library/dependency modules only integer , parameter :: FPM_SCOPE_LIB = 1 !> Module-use scope is library/dependency modules only integer , parameter :: FPM_SCOPE_DEP = 2 !> Module-use scope is library/dependency and app modules integer , parameter :: FPM_SCOPE_APP = 3 !> Module-use scope is library/dependency and test modules integer , parameter :: FPM_SCOPE_TEST = 4 integer , parameter :: FPM_SCOPE_EXAMPLE = 5 !> Target type is unknown (ignored) integer , parameter :: FPM_TARGET_UNKNOWN = - 1 !> Target type is executable integer , parameter :: FPM_TARGET_EXECUTABLE = 1 !> Target type is library archive integer , parameter :: FPM_TARGET_ARCHIVE = 2 !> Target type is compiled object integer , parameter :: FPM_TARGET_OBJECT = 3 !> Type for describing a source file type srcfile_t !> File path relative to cwd character (:), allocatable :: file_name !> Name of executable for FPM_UNIT_PROGRAM character (:), allocatable :: exe_name !> Target module-use scope integer :: unit_scope = FPM_SCOPE_UNKNOWN !> Modules provided by this source file (lowerstring) type ( string_t ), allocatable :: modules_provided (:) !> Type of source unit integer :: unit_type = FPM_UNIT_UNKNOWN !>  Modules USEd by this source file (lowerstring) type ( string_t ), allocatable :: modules_used (:) !> Files INCLUDEd by this source file type ( string_t ), allocatable :: include_dependencies (:) !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Current hash integer ( int64 ) :: digest end type srcfile_t !> Wrapper type for constructing arrays of `[[build_target_t]]` pointers type build_target_ptr type ( build_target_t ), pointer :: ptr => null () end type build_target_ptr !> Type describing a generated build target type build_target_t !> File path of build target object relative to cwd character (:), allocatable :: output_file !> Primary source for this build target type ( srcfile_t ), allocatable :: source !> Resolved build dependencies type ( build_target_ptr ), allocatable :: dependencies (:) !> Target type integer :: target_type = FPM_TARGET_UNKNOWN !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Objects needed to link this target type ( string_t ), allocatable :: link_objects (:) !> Flag set when first visited to check for circular dependencies logical :: touched = . false . !> Flag set if build target is sorted for building logical :: sorted = . false . !> Flag set if build target will be skipped (not built) logical :: skip = . false . !> Targets in the same schedule group are guaranteed to be independent integer :: schedule = - 1 !> Previous source file hash integer ( int64 ), allocatable :: digest_cached end type build_target_t !> Type describing everything required to build a package !> and its dependencies. type :: fpm_model_t !> Name of package character (:), allocatable :: package_name !> Array of sources type ( srcfile_t ), allocatable :: sources (:) !> Array of targets with module-dependencies resolved type ( build_target_ptr ), allocatable :: targets (:) !> Command line name to invoke fortran compiler character (:), allocatable :: fortran_compiler !> Command line flags passed to fortran for compilation character (:), allocatable :: fortran_compile_flags !> Command line flags pass for linking character (:), allocatable :: link_flags !> Output file for library archive character (:), allocatable :: library_file !> Base directory for build character (:), allocatable :: output_directory !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Project dependencies type ( dependency_tree_t ) :: deps end type fpm_model_t contains function info_build_target ( t ) result ( s ) type ( build_target_t ), intent ( in ) :: t character (:), allocatable :: s integer :: i !type build_target_t s = \"build_target_t(\" !    character(:), allocatable :: output_file s = s // 'output_file=\"' // t % output_file // '\"' !    type(srcfile_t), allocatable :: source if ( allocated ( t % source )) then s = s // \", source=\" // info_srcfile_short ( t % source ) else s = s // \", source=()\" end if !    type(build_target_ptr), allocatable :: dependencies(:) s = s // \", dependencies=[\" if ( allocated ( t % dependencies )) then do i = 1 , size ( t % dependencies ) s = s // info_build_target_short ( t % dependencies ( i )% ptr ) if ( i < size ( t % dependencies )) s = s // \", \" end do end if s = s // \"]\" !    integer :: target_type = FPM_TARGET_UNKNOWN s = s // \", target_type=\" select case ( t % target_type ) case ( FPM_TARGET_UNKNOWN ) s = s // \"FPM_TARGET_UNKNOWN\" case ( FPM_TARGET_EXECUTABLE ) s = s // \"FPM_TARGET_EXECUTABLE\" case ( FPM_TARGET_ARCHIVE ) s = s // \"FPM_TARGET_ARCHIVE\" case ( FPM_TARGET_OBJECT ) s = s // \"FPM_TARGET_OBJECT\" case default s = s // \"INVALID\" end select !    type(string_t), allocatable :: link_libraries(:) s = s // \", link_libraries=[\" if ( allocated ( t % link_libraries )) then do i = 1 , size ( t % link_libraries ) s = s // '\"' // t % link_libraries ( i )% s // '\"' if ( i < size ( t % link_libraries )) s = s // \", \" end do end if s = s // \"]\" !    type(string_t), allocatable :: link_objects(:) s = s // \", link_objects=[\" if ( allocated ( t % link_objects )) then do i = 1 , size ( t % link_objects ) s = s // '\"' // t % link_objects ( i )% s // '\"' if ( i < size ( t % link_objects )) s = s // \", \" end do end if s = s // \"]\" !    logical :: touched = .false. s = s // \", touched=\" // str ( t % touched ) !    logical :: sorted = .false. s = s // \", sorted=\" // str ( t % sorted ) !    logical :: skip = .false. s = s // \", skip=\" // str ( t % skip ) !    integer :: schedule = -1 s = s // \", schedule=\" // str ( t % schedule ) !    integer(int64), allocatable :: digest_cached if ( allocated ( t % digest_cached )) then s = s // \", digest_cached=\" // str ( t % digest_cached ) else s = s // \", digest_cached=()\" end if !end type build_target_t s = s // \")\" end function function info_build_target_short ( t ) result ( s ) ! Prints a shortened representation of build_target_t type ( build_target_t ), intent ( in ) :: t character (:), allocatable :: s integer :: i s = \"build_target_t(\" s = s // 'output_file=\"' // t % output_file // '\"' s = s // \", ...)\" end function function info_srcfile ( source ) result ( s ) type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: s integer :: i !type srcfile_t s = \"srcfile_t(\" !    character(:), allocatable :: file_name s = s // 'file_name=\"' // source % file_name // '\"' !    character(:), allocatable :: exe_name s = s // ', exe_name=\"' // source % exe_name // '\"' !    integer :: unit_scope = FPM_SCOPE_UNKNOWN s = s // \", unit_scope=\" select case ( source % unit_scope ) case ( FPM_SCOPE_UNKNOWN ) s = s // \"FPM_SCOPE_UNKNOWN\" case ( FPM_SCOPE_LIB ) s = s // \"FPM_SCOPE_LIB\" case ( FPM_SCOPE_DEP ) s = s // \"FPM_SCOPE_DEP\" case ( FPM_SCOPE_APP ) s = s // \"FPM_SCOPE_APP\" case ( FPM_SCOPE_TEST ) s = s // \"FPM_SCOPE_TEST\" case ( FPM_SCOPE_EXAMPLE ) s = s // \"FPM_SCOPE_EXAMPLE\" case default s = s // \"INVALID\" end select !    type(string_t), allocatable :: modules_provided(:) s = s // \", modules_provided=[\" do i = 1 , size ( source % modules_provided ) s = s // '\"' // source % modules_provided ( i )% s // '\"' if ( i < size ( source % modules_provided )) s = s // \", \" end do s = s // \"]\" !    integer :: unit_type = FPM_UNIT_UNKNOWN s = s // \", unit_type=\" select case ( source % unit_type ) case ( FPM_UNIT_UNKNOWN ) s = s // \"FPM_UNIT_UNKNOWN\" case ( FPM_UNIT_PROGRAM ) s = s // \"FPM_UNIT_PROGRAM\" case ( FPM_UNIT_MODULE ) s = s // \"FPM_UNIT_MODULE\" case ( FPM_UNIT_SUBMODULE ) s = s // \"FPM_UNIT_SUBMODULE\" case ( FPM_UNIT_SUBPROGRAM ) s = s // \"FPM_UNIT_SUBPROGRAM\" case ( FPM_UNIT_CSOURCE ) s = s // \"FPM_UNIT_CSOURCE\" case ( FPM_UNIT_CHEADER ) s = s // \"FPM_UNIT_CHEADER\" case default s = s // \"INVALID\" end select !    type(string_t), allocatable :: modules_used(:) s = s // \", modules_used=[\" do i = 1 , size ( source % modules_used ) s = s // '\"' // source % modules_used ( i )% s // '\"' if ( i < size ( source % modules_used )) s = s // \", \" end do s = s // \"]\" !    type(string_t), allocatable :: include_dependencies(:) s = s // \", include_dependencies=[\" do i = 1 , size ( source % include_dependencies ) s = s // '\"' // source % include_dependencies ( i )% s // '\"' if ( i < size ( source % include_dependencies )) s = s // \", \" end do s = s // \"]\" !    type(string_t), allocatable :: link_libraries(:) s = s // \", link_libraries=[\" do i = 1 , size ( source % link_libraries ) s = s // '\"' // source % link_libraries ( i )% s // '\"' if ( i < size ( source % link_libraries )) s = s // \", \" end do s = s // \"]\" !    integer(int64) :: digest s = s // \", digest=\" // str ( source % digest ) !end type srcfile_t s = s // \")\" end function function info_srcfile_short ( source ) result ( s ) ! Prints a shortened version of srcfile_t type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: s integer :: i s = \"srcfile_t(\" s = s // 'file_name=\"' // source % file_name // '\"' s = s // \", ...)\" end function function info_model ( model ) result ( s ) type ( fpm_model_t ), intent ( in ) :: model character (:), allocatable :: s integer :: i !type :: fpm_model_t s = \"fpm_model_t(\" !    character(:), allocatable :: package_name s = s // 'package_name=\"' // model % package_name // '\"' !    type(srcfile_t), allocatable :: sources(:) s = s // \", sources=[\" do i = 1 , size ( model % sources ) s = s // info_srcfile ( model % sources ( i )) if ( i < size ( model % sources )) s = s // \", \" end do s = s // \"]\" !    type(build_target_ptr), allocatable :: targets(:) s = s // \", targets=[\" do i = 1 , size ( model % targets ) s = s // info_build_target ( model % targets ( i )% ptr ) if ( i < size ( model % targets )) s = s // \", \" end do s = s // \"]\" !    character(:), allocatable :: fortran_compiler s = s // ', fortran_compiler=\"' // model % fortran_compiler // '\"' !    character(:), allocatable :: fortran_compile_flags s = s // ', fortran_compile_flags=\"' // model % fortran_compile_flags // '\"' !    character(:), allocatable :: link_flags s = s // ', link_flags=\"' // model % link_flags // '\"' !    character(:), allocatable :: library_file s = s // ', library_file=\"' // model % library_file // '\"' !    character(:), allocatable :: output_directory s = s // ', output_directory=\"' // model % output_directory // '\"' !    type(string_t), allocatable :: link_libraries(:) s = s // \", link_libraries=[\" do i = 1 , size ( model % link_libraries ) s = s // '\"' // model % link_libraries ( i )% s // '\"' if ( i < size ( model % link_libraries )) s = s // \", \" end do s = s // \"]\" !    type(dependency_tree_t) :: deps ! TODO: print `dependency_tree_t` properly, which should become part of the !       model, not imported from another file s = s // \", deps=dependency_tree_t(...)\" !end type fpm_model_t s = s // \")\" end function subroutine show_model ( model ) ! Prints a human readable representation of the Model type ( fpm_model_t ), intent ( in ) :: model print * , info_model ( model ) end subroutine end module fpm_model","tags":"","loc":"sourcefile/fpm_model.f90.html"},{"title":"fpm_targets.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_targets Source Code fpm_targets.f90 Source Code !># Build target handling !> !> This module handles the construction of the build target list !> from the sources list (`[[targets_from_sources]]`), the !> resolution of module-dependencies between build targets !> (`[[resolve_module_dependencies]]`), and the enumeration of !> objects required for link targets (`[[resolve_target_linking]]`). !> !> A build target (`[[build_target_t]]`) is a file to be generated !> by the backend (compilation and linking). !> !> @note The current implementation is ignorant to the existence of !> module files (`.mod`,`.smod`). Dependencies arising from modules !> are based on the corresponding object files (`.o`) only. !> !> For more information, please read the documentation for the procedures: !> !> - `[[targets_from_sources]]` !> - `[[resolve_module_dependencies]]` !> module fpm_targets use fpm_error , only : error_t , fatal_error use fpm_model use fpm_environment , only : get_os_type , OS_WINDOWS use fpm_filesystem , only : dirname , join_path , canon_path use fpm_strings , only : string_t , operator (. in .) implicit none private public targets_from_sources , resolve_module_dependencies public resolve_target_linking , add_target , add_dependency contains !> Constructs a list of build targets from a list of source files !> !>### Source-target mapping !> !> One compiled object target (`FPM_TARGET_OBJECT`) is generated for each !> non-executable source file (`FPM_UNIT_MODULE`,`FPM_UNIT_SUBMODULE`, !>  `FPM_UNIT_SUBPROGRAM`,`FPM_UNIT_CSOURCE`). !> !> If any source file has scope `FPM_SCOPE_LIB` (*i.e.* there are library sources) !> then the first target in the target list will be a library archive target !> (`FPM_TARGET_ARCHIVE`). The archive target will have a dependency on every !> compiled object target corresponding to a library source file. !> !> One compiled object target (`FPM_TARGET_OBJECT`) and one executable target (`FPM_TARGET_EXECUTABLE`) is !> generated for each exectuable source file (`FPM_UNIT_PROGRAM`). The exectuble target !> always has a dependency on the corresponding compiled object target. If there !> is a library, then the executable target has an additional dependency on the library !> archive target. !> !> @note Inter-object dependencies based on modules used and provided are generated separately !> in `[[resolve_module_dependencies]]` after all targets have been enumerated. subroutine targets_from_sources ( model , sources ) !> The package model within which to construct the target list type ( fpm_model_t ), intent ( inout ), target :: model !> The list of sources from which to construct the target list type ( srcfile_t ), intent ( in ) :: sources (:) integer :: i character (:), allocatable :: xsuffix , exe_dir type ( build_target_t ), pointer :: dep logical :: with_lib if ( get_os_type () == OS_WINDOWS ) then xsuffix = '.exe' else xsuffix = '' end if with_lib = any ([( sources ( i )% unit_scope == FPM_SCOPE_LIB , i = 1 , size ( sources ))]) if ( with_lib ) call add_target ( model % targets , type = FPM_TARGET_ARCHIVE ,& output_file = join_path ( model % output_directory ,& model % package_name , 'lib' // model % package_name // '.a' )) do i = 1 , size ( sources ) select case ( sources ( i )% unit_type ) case ( FPM_UNIT_MODULE , FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE ) call add_target ( model % targets , source = sources ( i ), & type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i ))) if ( with_lib . and . sources ( i )% unit_scope == FPM_SCOPE_LIB ) then ! Archive depends on object call add_dependency ( model % targets ( 1 )% ptr , model % targets ( size ( model % targets ))% ptr ) end if case ( FPM_UNIT_PROGRAM ) call add_target ( model % targets , type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i )), & source = sources ( i ) & ) if ( sources ( i )% unit_scope == FPM_SCOPE_APP ) then exe_dir = 'app' else if ( sources ( i )% unit_scope == FPM_SCOPE_EXAMPLE ) then exe_dir = 'example' else exe_dir = 'test' end if call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , exe_dir , & sources ( i )% exe_name // xsuffix )) ! Executable depends on object call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( size ( model % targets ) - 1 )% ptr ) if ( with_lib ) then ! Executable depends on library call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( 1 )% ptr ) end if end select end do contains function get_object_name ( source ) result ( object_file ) ! Generate object target path from source name and model params ! ! type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: object_file integer :: i character ( 1 ), parameter :: filesep = '/' character (:), allocatable :: dir object_file = canon_path ( source % file_name ) ! Convert any remaining directory separators to underscores i = index ( object_file , filesep ) do while ( i > 0 ) object_file ( i : i ) = '_' i = index ( object_file , filesep ) end do object_file = join_path ( model % output_directory , model % package_name , object_file ) // '.o' end function get_object_name end subroutine targets_from_sources !> Allocate a new target and append to target list subroutine add_target ( targets , type , output_file , source , link_libraries ) type ( build_target_ptr ), allocatable , intent ( inout ) :: targets (:) integer , intent ( in ) :: type character ( * ), intent ( in ) :: output_file type ( srcfile_t ), intent ( in ), optional :: source type ( string_t ), intent ( in ), optional :: link_libraries (:) integer :: i type ( build_target_ptr ), allocatable :: temp (:) type ( build_target_t ), pointer :: new_target if (. not . allocated ( targets )) allocate ( targets ( 0 )) ! Check for duplicate outputs do i = 1 , size ( targets ) if ( targets ( i )% ptr % output_file == output_file ) then write ( * , * ) 'Error while building target list: duplicate output object \"' ,& output_file , '\"' if ( present ( source )) write ( * , * ) ' Source file: \"' , source % file_name , '\"' stop 1 end if end do allocate ( new_target ) new_target % target_type = type new_target % output_file = output_file if ( present ( source )) new_target % source = source if ( present ( link_libraries )) new_target % link_libraries = link_libraries allocate ( new_target % dependencies ( 0 )) targets = [ targets , build_target_ptr ( new_target )] end subroutine add_target !> Add pointer to dependeny in target%dependencies subroutine add_dependency ( target , dependency ) type ( build_target_t ), intent ( inout ) :: target type ( build_target_t ) , intent ( in ), target :: dependency target % dependencies = [ target % dependencies , build_target_ptr ( dependency )] end subroutine add_dependency !> Add dependencies to source-based targets (`FPM_TARGET_OBJECT`) !> based on any modules used by the corresponding source file. !> !>### Source file scoping !> !> Source files are assigned a scope of either `FPM_SCOPE_LIB`, !> `FPM_SCOPE_APP` or `FPM_SCOPE_TEST`. The scope controls which !> modules may be used by the source file: !> !> - Library sources (`FPM_SCOPE_LIB`) may only use modules !>   also with library scope. This includes library modules !>   from dependencies. !> !> - Executable sources (`FPM_SCOPE_APP`,`FPM_SCOPE_TEST`) may use !>   library modules (including dependencies) as well as any modules !>   corresponding to source files __in the same directory__ as the !>   executable source. !> !> @warning If a module used by a source file cannot be resolved to !> a source file in the package of the correct scope, then a __fatal error__ !> is returned by the procedure and model construction fails. !> subroutine resolve_module_dependencies ( targets , error ) type ( build_target_ptr ), intent ( inout ), target :: targets (:) type ( error_t ), allocatable , intent ( out ) :: error type ( build_target_ptr ) :: dep integer :: i , j do i = 1 , size ( targets ) if (. not . allocated ( targets ( i )% ptr % source )) cycle do j = 1 , size ( targets ( i )% ptr % source % modules_used ) if ( targets ( i )% ptr % source % modules_used ( j )% s . in . targets ( i )% ptr % source % modules_provided ) then ! Dependency satisfied in same file, skip cycle end if if ( any ( targets ( i )% ptr % source % unit_scope == & [ FPM_SCOPE_APP , FPM_SCOPE_EXAMPLE , FPM_SCOPE_TEST ])) then dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s , & include_dir = dirname ( targets ( i )% ptr % source % file_name )) else dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s ) end if if (. not . associated ( dep % ptr )) then call fatal_error ( error , & 'Unable to find source for module dependency: \"' // & targets ( i )% ptr % source % modules_used ( j )% s // & '\" used by \"' // targets ( i )% ptr % source % file_name // '\"' ) return end if call add_dependency ( targets ( i )% ptr , dep % ptr ) end do end do end subroutine resolve_module_dependencies function find_module_dependency ( targets , module_name , include_dir ) result ( target_ptr ) ! Find a module dependency in the library or a dependency library ! ! 'include_dir' specifies an allowable non-library search directory !   (Used for executable dependencies) ! type ( build_target_ptr ), intent ( in ), target :: targets (:) character ( * ), intent ( in ) :: module_name character ( * ), intent ( in ), optional :: include_dir type ( build_target_t ), pointer :: target_ptr integer :: k , l target_ptr => NULL () do k = 1 , size ( targets ) if (. not . allocated ( targets ( k )% ptr % source )) cycle do l = 1 , size ( targets ( k )% ptr % source % modules_provided ) if ( module_name == targets ( k )% ptr % source % modules_provided ( l )% s ) then select case ( targets ( k )% ptr % source % unit_scope ) case ( FPM_SCOPE_LIB , FPM_SCOPE_DEP ) target_ptr => targets ( k )% ptr exit case default if ( present ( include_dir )) then if ( dirname ( targets ( k )% ptr % source % file_name ) == include_dir ) then target_ptr => targets ( k )% ptr exit end if end if end select end if end do end do end function find_module_dependency !> For libraries and executables, build a list of objects required for linking !> !> stored in `target%link_objects` !> subroutine resolve_target_linking ( targets ) type ( build_target_ptr ), intent ( inout ), target :: targets (:) integer :: i do i = 1 , size ( targets ) associate ( target => targets ( i )% ptr ) allocate ( target % link_objects ( 0 )) if ( target % target_type == FPM_TARGET_ARCHIVE ) then call get_link_objects ( target % link_objects , target , is_exe = . false .) else if ( target % target_type == FPM_TARGET_EXECUTABLE ) then call get_link_objects ( target % link_objects , target , is_exe = . true .) end if end associate end do contains !> Wrapper to build link object list !> !>  For libraries: just list dependency objects of lib target !> !>  For executables: need to recursively discover non-library !>   dependency objects. (i.e. modules in same dir as program) !> recursive subroutine get_link_objects ( link_objects , target , is_exe ) type ( string_t ), intent ( inout ), allocatable :: link_objects (:) type ( build_target_t ), intent ( in ) :: target logical , intent ( in ) :: is_exe integer :: i type ( string_t ) :: temp_str if (. not . allocated ( target % dependencies )) return do i = 1 , size ( target % dependencies ) associate ( dep => target % dependencies ( i )% ptr ) if (. not . allocated ( dep % source )) cycle ! Skip library dependencies for executable targets !  since the library archive will always be linked if ( is_exe . and .( dep % source % unit_scope == FPM_SCOPE_LIB )) cycle ! Skip if dependency object already listed if ( dep % output_file . in . link_objects ) cycle ! Add dependency object file to link object list temp_str % s = dep % output_file link_objects = [ link_objects , temp_str ] ! For executable objects, also need to include non-library !  dependencies from dependencies (recurse) if ( is_exe ) call get_link_objects ( link_objects , dep , is_exe = . true .) end associate end do end subroutine get_link_objects end subroutine resolve_target_linking end module fpm_targets","tags":"","loc":"sourcefile/fpm_targets.f90.html"},{"title":"fpm_compiler.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_compiler Source Code fpm_compiler.f90 Source Code module fpm_compiler use fpm_model , only : fpm_model_t use fpm_filesystem , only : join_path public add_compile_flag_defaults contains subroutine add_compile_flag_defaults ( build_name , compiler , model ) ! Choose compile flags based on cli settings & manifest inputs character ( len =* ), intent ( in ) :: build_name , compiler type ( fpm_model_t ), intent ( inout ) :: model ! could just be a function to return a string instead of passing model ! but likely to change other components like matching C compiler character ( len = :), allocatable :: fflags ! optional flags that might be overridden by user character ( len = :), allocatable :: modpath character ( len = :), allocatable :: mandatory ! flags required for fpm to function properly; ! ie. add module path and module include directory as appropriate ! special reserved names \"debug\" and \"release\" are for supported compilers with no user-specified compile or load flags ! vendor            Fortran   C         Module output   Module include OpenMP    Free for OSS !                   compiler  compiler  directory       directory ! Gnu               gfortran   gcc     -J              -I            -fopenmp   X ! Intel             ifort      icc     -module         -I            -qopenmp   X ! Intel(Windows)    ifort      icc     /module:path    /I            /Qopenmp   X ! Intel oneAPI      ifx        icx     -module         -I            -qopenmp   X ! PGI               pgfortran  pgcc    -module         -I            -mp        X ! NVIDIA            nvfortran  nvc     -module         -I            -mp        X ! LLVM flang        flang      clang   -module         -I            -mp        X ! LFortran          lfortran   ---     ?               ?             ?          X ! Lahey/Futjitsu    lfc        ?       -M              -I            -openmp    ? ! NAG               nagfor     ?       -mdir           -I            -openmp    x ! Cray              crayftn    craycc  -J              -I            -homp      ? ! IBM               xlf90      ?       -qmoddir        -I            -qsmp      X ! Oracle/Sun        ?          ?       -moddir=        -M            -xopenmp   ? ! Silverfrost FTN95 ftn95      ?       ?               /MOD_PATH     ?          ? ! Elbrus            ?          lcc     -J              -I            -fopenmp   ? ! Hewlett Packard   ?          ?       ?               ?             ?          discontinued ! Watcom            ?          ?       ?               ?             ?          discontinued ! PathScale         ?          ?       -module         -I            -mp        discontinued ! G95               ?          ?       -fmod=          -I            -fopenmp   discontinued ! Open64            ?          ?       -module         -I            -mp        discontinued ! Unisys            ?          ?       ?               ?             ?          discontinued modpath = join_path ( model % output_directory , model % package_name ) fflags = '' mandatory = '' select case ( build_name // '_' // compiler ) case ( 'release_caf' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -funroll-loops& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_caf' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -fbacktrace& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_gfortran' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -funroll-loops& & -fcoarray=single& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_gfortran' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -fbacktrace& & -fcoarray=single& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_f95' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -ffast-math& & -funroll-loops& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_f95' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -Wno-maybe-uninitialized -Wno-uninitialized& & -fbacktrace& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_nvfortran' ) fflags = '& & -Mbackslash& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_nvfortran' ) fflags = '& & -Minform=inform& & -Mbackslash& & -g& & -Mbounds& & -Mchkptr& & -Mchkstk& & -traceback& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_ifort' ) fflags = '& & -fp-model precise& & -pc 64& & -align all& & -error-limit 1& & -reentrancy threaded& & -nogen-interfaces& & -assume byterecl& & -assume nounderscore& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_ifort' ) fflags = '& & -warn all& & -check:all:noarg_temp_created& & -error-limit 1& & -O0& & -g& & -assume byterecl& & -traceback& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_ifx' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_ifx' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_pgfortran' , 'release_pgf90' , 'release_pgf95' ) ! Portland Group F90/F95 compilers fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_pgfortran' , 'debug_pgf90' , 'debug_pgf95' ) ! Portland Group F90/F95 compilers fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_flang' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_flang' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_lfc' ) fflags = ' ' mandatory = ' -M ' // modpath // ' -I ' // modpath case ( 'debug_lfc' ) fflags = ' ' mandatory = ' -M ' // modpath // ' -I ' // modpath case ( 'release_nagfor' ) fflags = ' & & -O4& & -coarray=single& & -PIC& &' mandatory = ' -mdir ' // modpath // ' -I ' // modpath ! case ( 'debug_nagfor' ) fflags = '& & -g& & -C=all& & -O0& & -gline& & -coarray=single& & -PIC& &' mandatory = ' -mdir ' // modpath // ' -I ' // modpath ! case ( 'release_crayftn' ) fflags = ' ' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_crayftn' ) fflags = ' ' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_xlf90' ) fflags = ' ' mandatory = ' -qmoddir ' // modpath // ' -I ' // modpath case ( 'debug_xlf90' ) fflags = ' ' mandatory = ' -qmoddir ' // modpath // ' -I ' // modpath case default fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath write ( * , * ) '<WARNING> unknown compiler (' , compiler , ')' write ( * , * ) '          and build name (' , build_name , ')' write ( * , * ) '          combination.' write ( * , * ) '          known compilers are gfortran, nvfortran, ifort' end select model % fortran_compile_flags = fflags // ' ' // mandatory end subroutine add_compile_flag_defaults end module fpm_compiler","tags":"","loc":"sourcefile/fpm_compiler.f90.html"},{"title":"fpm.f90 – Fortran-lang/fpm","text":"Contents Modules fpm Source Code fpm.f90 Source Code module fpm use fpm_strings , only : string_t , operator (. in .) use fpm_backend , only : build_package use fpm_command_line , only : fpm_build_settings , fpm_new_settings , & fpm_run_settings , fpm_install_settings , fpm_test_settings use fpm_dependency , only : new_dependency_tree use fpm_environment , only : run use fpm_filesystem , only : is_dir , join_path , number_of_rows , list_files , exists , basename use fpm_model , only : fpm_model_t , srcfile_t , build_target_t , & FPM_SCOPE_UNKNOWN , FPM_SCOPE_LIB , FPM_SCOPE_DEP , & FPM_SCOPE_APP , FPM_SCOPE_EXAMPLE , FPM_SCOPE_TEST , & FPM_TARGET_EXECUTABLE , FPM_TARGET_ARCHIVE , show_model use fpm_compiler , only : add_compile_flag_defaults use fpm_sources , only : add_executable_sources , add_sources_from_dir use fpm_targets , only : targets_from_sources , resolve_module_dependencies , & resolve_target_linking use fpm_manifest , only : get_package_data , package_config_t use fpm_error , only : error_t , fatal_error use fpm_manifest_test , only : test_config_t use , intrinsic :: iso_fortran_env , only : stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use fpm_manifest_dependency , only : dependency_config_t implicit none private public :: cmd_build , cmd_run public :: build_model contains subroutine build_model ( model , settings , package , error ) ! Constructs a valid fpm model from command line settings and toml manifest ! type ( fpm_model_t ), intent ( out ) :: model type ( fpm_build_settings ), intent ( in ) :: settings type ( package_config_t ), intent ( in ) :: package type ( error_t ), allocatable , intent ( out ) :: error type ( string_t ), allocatable :: package_list (:) integer :: i type ( package_config_t ) :: dependency character ( len = :), allocatable :: manifest , lib_dir if ( settings % verbose ) then write ( * , * ) '<INFO>BUILD_NAME:' , settings % build_name write ( * , * ) '<INFO>COMPILER:  ' , settings % compiler endif model % package_name = package % name if ( allocated ( package % build % link )) then model % link_libraries = package % build % link else allocate ( model % link_libraries ( 0 )) end if call new_dependency_tree ( model % deps , cache = join_path ( \"build\" , \"cache.toml\" )) call model % deps % add ( package , error ) if ( allocated ( error )) return allocate ( package_list ( 1 )) package_list ( 1 )% s = package % name if ( settings % compiler . eq . '' ) then model % fortran_compiler = 'gfortran' else model % fortran_compiler = settings % compiler endif model % output_directory = join_path ( 'build' , basename ( model % fortran_compiler ) // '_' // settings % build_name ) call add_compile_flag_defaults ( settings % build_name , basename ( model % fortran_compiler ), model ) model % link_flags = '' ! Add sources from executable directories if ( is_dir ( 'app' ) . and . package % build % auto_executables ) then call add_sources_from_dir ( model % sources , 'app' , FPM_SCOPE_APP , & with_executables = . true ., error = error ) if ( allocated ( error )) then return end if end if if ( is_dir ( 'example' ) . and . package % build % auto_examples ) then call add_sources_from_dir ( model % sources , 'example' , FPM_SCOPE_EXAMPLE , & with_executables = . true ., error = error ) if ( allocated ( error )) then return end if end if if ( is_dir ( 'test' ) . and . package % build % auto_tests ) then call add_sources_from_dir ( model % sources , 'test' , FPM_SCOPE_TEST , & with_executables = . true ., error = error ) if ( allocated ( error )) then return endif end if if ( allocated ( package % executable )) then call add_executable_sources ( model % sources , package % executable , FPM_SCOPE_APP , & auto_discover = package % build % auto_executables , & error = error ) if ( allocated ( error )) then return end if end if if ( allocated ( package % example )) then call add_executable_sources ( model % sources , package % example , FPM_SCOPE_EXAMPLE , & auto_discover = package % build % auto_examples , & error = error ) if ( allocated ( error )) then return end if end if if ( allocated ( package % test )) then call add_executable_sources ( model % sources , package % test , FPM_SCOPE_TEST , & auto_discover = package % build % auto_tests , & error = error ) if ( allocated ( error )) then return endif endif do i = 1 , model % deps % ndep associate ( dep => model % deps % dep ( i )) manifest = join_path ( dep % proj_dir , \"fpm.toml\" ) call get_package_data ( dependency , manifest , error , & apply_defaults = . true .) if ( allocated ( error )) exit if ( allocated ( dependency % library )) then lib_dir = join_path ( dep % proj_dir , dependency % library % source_dir ) call add_sources_from_dir ( model % sources , lib_dir , FPM_SCOPE_LIB , & error = error ) if ( allocated ( error )) exit end if if ( allocated ( dependency % build % link )) then model % link_libraries = [ model % link_libraries , dependency % build % link ] end if end associate end do if ( allocated ( error )) return call targets_from_sources ( model , model % sources ) do i = 1 , size ( model % link_libraries ) model % link_flags = model % link_flags // \" -l\" // model % link_libraries ( i )% s end do if ( model % targets ( 1 )% ptr % target_type == FPM_TARGET_ARCHIVE ) then model % library_file = model % targets ( 1 )% ptr % output_file end if call resolve_module_dependencies ( model % targets , error ) call resolve_target_linking ( model % targets ) end subroutine build_model subroutine cmd_build ( settings ) type ( fpm_build_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( error_t ), allocatable :: error integer :: i call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if if ( settings % list ) then do i = 1 , size ( model % targets ) write ( stderr , * ) model % targets ( i )% ptr % output_file enddo else if ( settings % show_model ) then call show_model ( model ) else call build_package ( model ) endif end subroutine subroutine cmd_run ( settings , test ) class ( fpm_run_settings ), intent ( in ) :: settings logical , intent ( in ) :: test integer , parameter :: LINE_WIDTH = 80 integer :: i , j , col_width , nCol logical :: found ( size ( settings % name )) type ( error_t ), allocatable :: error type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( string_t ) :: exe_cmd type ( string_t ), allocatable :: executables (:) type ( build_target_t ), pointer :: exe_target type ( srcfile_t ), pointer :: exe_source integer :: run_scope call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings % fpm_build_settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if if ( test ) then run_scope = FPM_SCOPE_TEST else run_scope = merge ( FPM_SCOPE_EXAMPLE , FPM_SCOPE_APP , settings % example ) end if ! Enumerate executable targets to run col_width = - 1 found (:) = . false . allocate ( executables ( 0 )) do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == run_scope ) then col_width = max ( col_width , len ( basename ( exe_target % output_file )) + 2 ) if ( size ( settings % name ) == 0 ) then exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] else do j = 1 , size ( settings % name ) if ( trim ( settings % name ( j )) == exe_source % exe_name ) then found ( j ) = . true . exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] end if end do end if end if end if end do ! Check if any apps/tests were found if ( col_width < 0 ) then if ( test ) then write ( stderr , * ) 'No tests to run' else write ( stderr , * ) 'No executables to run' end if stop end if ! Check all names are valid if ( any (. not . found )) then write ( stderr , '(A)' , advance = \"no\" ) 'fpm::run<ERROR> specified names ' do j = 1 , size ( settings % name ) if (. not . found ( j )) write ( stderr , '(A)' , advance = \"no\" ) '\"' // trim ( settings % name ( j )) // '\" ' end do write ( stderr , '(A)' ) 'not found.' write ( stderr , * ) j = 1 nCol = LINE_WIDTH / col_width write ( stderr , * ) 'Available names:' do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == run_scope ) then write ( stderr , '(A)' , advance = ( merge ( \"yes\" , \"no \" , modulo ( j , nCol ) == 0 ))) & & [ character ( len = col_width ) :: basename ( exe_target % output_file )] j = j + 1 end if end if end do write ( stderr , * ) stop 1 end if call build_package ( model ) do i = 1 , size ( executables ) if ( settings % list ) then write ( stderr , * ) executables ( i )% s else if ( exists ( executables ( i )% s )) then if ( settings % runner . ne . ' ' ) then call run ( settings % runner // ' ' // executables ( i )% s // \" \" // settings % args ) else call run ( executables ( i )% s // \" \" // settings % args ) endif else write ( stderr , * ) 'fpm::run<ERROR>' , executables ( i )% s , ' not found' stop 1 end if end if end do end subroutine cmd_run end module fpm","tags":"","loc":"sourcefile/fpm.f90.html"},{"title":"fpm_environment.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_environment Source Code fpm_environment.f90 Source Code module fpm_environment implicit none private public :: get_os_type public :: os_is_unix public :: run public :: get_env integer , parameter , public :: OS_UNKNOWN = 0 integer , parameter , public :: OS_LINUX = 1 integer , parameter , public :: OS_MACOS = 2 integer , parameter , public :: OS_WINDOWS = 3 integer , parameter , public :: OS_CYGWIN = 4 integer , parameter , public :: OS_SOLARIS = 5 integer , parameter , public :: OS_FREEBSD = 6 contains integer function get_os_type () result ( r ) !! Determine the OS type !! !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN, !! OS_SOLARIS, OS_FREEBSD. !! !! At first, the environment variable `OS` is checked, which is usually !! found on Windows. Then, `OSTYPE` is read in and compared with common !! names. If this fails too, check the existence of files that can be !! found on specific system types only. !! !! Returns OS_UNKNOWN if the operating system cannot be determined. character ( len = 32 ) :: val integer :: length , rc logical :: file_exists r = OS_UNKNOWN ! Check environment variable `OS`. call get_environment_variable ( 'OS' , val , length , rc ) if ( rc == 0 . and . length > 0 . and . index ( val , 'Windows_NT' ) > 0 ) then r = OS_WINDOWS return end if ! Check environment variable `OSTYPE`. call get_environment_variable ( 'OSTYPE' , val , length , rc ) if ( rc == 0 . and . length > 0 ) then ! Linux if ( index ( val , 'linux' ) > 0 ) then r = OS_LINUX return end if ! macOS if ( index ( val , 'darwin' ) > 0 ) then r = OS_MACOS return end if ! Windows, MSYS, MinGW, Git Bash if ( index ( val , 'win' ) > 0 . or . index ( val , 'msys' ) > 0 ) then r = OS_WINDOWS return end if ! Cygwin if ( index ( val , 'cygwin' ) > 0 ) then r = OS_CYGWIN return end if ! Solaris, OpenIndiana, ... if ( index ( val , 'SunOS' ) > 0 . or . index ( val , 'solaris' ) > 0 ) then r = OS_SOLARIS return end if ! FreeBSD if ( index ( val , 'FreeBSD' ) > 0 . or . index ( val , 'freebsd' ) > 0 ) then r = OS_FREEBSD return end if end if ! Linux inquire ( file = '/etc/os-release' , exist = file_exists ) if ( file_exists ) then r = OS_LINUX return end if ! macOS inquire ( file = '/usr/bin/sw_vers' , exist = file_exists ) if ( file_exists ) then r = OS_MACOS return end if ! FreeBSD inquire ( file = '/bin/freebsd-version' , exist = file_exists ) if ( file_exists ) then r = OS_FREEBSD return end if end function get_os_type logical function os_is_unix ( os ) result ( unix ) integer , intent ( in ), optional :: os integer :: build_os if ( present ( os )) then build_os = os else build_os = get_os_type () end if unix = os /= OS_WINDOWS end function os_is_unix subroutine run ( cmd ) character ( len =* ), intent ( in ) :: cmd integer :: stat print * , '+ ' , cmd call execute_command_line ( cmd , exitstat = stat ) if ( stat /= 0 ) then print * , 'Command failed' error stop end if end subroutine run function get_env ( NAME , DEFAULT ) result ( VALUE ) implicit none character ( len =* ), intent ( in ) :: NAME character ( len =* ), intent ( in ), optional :: DEFAULT character ( len = :), allocatable :: VALUE integer :: howbig integer :: stat integer :: length ! get length required to hold value length = 0 if ( NAME . ne . '' ) then call get_environment_variable ( NAME , length = howbig , status = stat , trim_name = . true .) select case ( stat ) case ( 1 ) !*!print *, NAME, \" is not defined in the environment. Strange...\" VALUE = '' case ( 2 ) !*!print *, \"This processor doesn't support environment variables. Boooh!\" VALUE = '' case default ! make string to hold value of sufficient size allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) ! get value call get_environment_variable ( NAME , VALUE , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else VALUE = '' endif if ( VALUE . eq . '' . and . present ( DEFAULT )) VALUE = DEFAULT end function get_env end module fpm_environment","tags":"","loc":"sourcefile/fpm_environment.f90.html"},{"title":"fpm_strings.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_strings Source Code fpm_strings.f90 Source Code module fpm_strings use iso_fortran_env , only : int64 implicit none private public :: f_string , lower , split , str_ends_with , string_t public :: string_array_contains , string_cat , operator (. in .), fnv_1a public :: resize , str type string_t character ( len = :), allocatable :: s end type interface resize module procedure :: resize_string end interface interface operator (. in .) module procedure string_array_contains end interface interface fnv_1a procedure :: fnv_1a_char procedure :: fnv_1a_string_t end interface fnv_1a interface str_ends_with procedure :: str_ends_with_str procedure :: str_ends_with_any end interface str_ends_with interface str module procedure str_int , str_int64 , str_logical end interface contains pure logical function str_ends_with_str ( s , e ) result ( r ) character ( * ), intent ( in ) :: s , e integer :: n1 , n2 n1 = len ( s ) - len ( e ) + 1 n2 = len ( s ) if ( n1 < 1 ) then r = . false . else r = ( s ( n1 : n2 ) == e ) end if end function str_ends_with_str pure logical function str_ends_with_any ( s , e ) result ( r ) character ( * ), intent ( in ) :: s character ( * ), intent ( in ) :: e (:) integer :: i r = . true . do i = 1 , size ( e ) if ( str_ends_with ( s , trim ( e ( i )))) return end do r = . false . end function str_ends_with_any function f_string ( c_string ) use iso_c_binding character ( len = 1 ), intent ( in ) :: c_string (:) character (:), allocatable :: f_string integer :: i , n i = 0 do while ( c_string ( i + 1 ) /= C_NULL_CHAR ) i = i + 1 end do n = i allocate ( character ( n ) :: f_string ) do i = 1 , n f_string ( i : i ) = c_string ( i ) end do end function f_string !> Hash a character(*) string of default kind pure function fnv_1a_char ( input , seed ) result ( hash ) character ( * ), intent ( in ) :: input integer ( int64 ), intent ( in ), optional :: seed integer ( int64 ) :: hash integer :: i integer ( int64 ), parameter :: FNV_OFFSET_32 = 2166136261_int64 integer ( int64 ), parameter :: FNV_PRIME_32 = 16777619_int64 if ( present ( seed )) then hash = seed else hash = FNV_OFFSET_32 end if do i = 1 , len ( input ) hash = ieor ( hash , iachar ( input ( i : i ), int64 )) * FNV_PRIME_32 end do end function fnv_1a_char !> Hash a string_t array of default kind pure function fnv_1a_string_t ( input , seed ) result ( hash ) type ( string_t ), intent ( in ) :: input (:) integer ( int64 ), intent ( in ), optional :: seed integer ( int64 ) :: hash integer :: i hash = fnv_1a ( input ( 1 )% s , seed ) do i = 2 , size ( input ) hash = fnv_1a ( input ( i )% s , hash ) end do end function fnv_1a_string_t elemental pure function lower ( str , begin , end ) result ( string ) ! Changes a string to lowercase over specified range ! Author: John S. Urban ! License: Public Domain character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower logical function string_array_contains ( search_string , array ) ! Check if array of string_t contains a particular string ! character ( * ), intent ( in ) :: search_string type ( string_t ), intent ( in ) :: array (:) integer :: i string_array_contains = any ([( array ( i )% s == search_string , & i = 1 , size ( array ))]) end function string_array_contains !> Concatenate an array of type(string_t) into !>  a single character function string_cat ( strings , delim ) result ( cat ) type ( string_t ), intent ( in ) :: strings (:) character ( * ), intent ( in ), optional :: delim character (:), allocatable :: cat integer :: i , n character (:), allocatable :: delim_str if ( size ( strings ) < 1 ) then cat = '' return end if if ( present ( delim )) then delim_str = delim else delim_str = '' end if cat = strings ( 1 )% s do i = 2 , size ( strings ) cat = cat // delim_str // strings ( i )% s end do end function string_cat subroutine split ( input_line , array , delimiters , order , nulls ) ! parse string on delimiter characters and store tokens into an allocatable array\" ! Author: John S. Urban ! License: Public Domain !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found select case ( ilen ) case ( 0 ) ! command was totally blank case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE end select select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split subroutine resize_string ( list , n ) !> Instance of the array to be resized type ( string_t ), allocatable , intent ( inout ) :: list (:) !> Dimension of the final array size integer , intent ( in ), optional :: n type ( string_t ), allocatable :: tmp (:) integer :: this_size , new_size , i integer , parameter :: initial_size = 16 if ( allocated ( list )) then this_size = size ( list , 1 ) call move_alloc ( list , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( list ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( list , 1 )) do i = 1 , this_size call move_alloc ( tmp ( i )% s , list ( i )% s ) end do deallocate ( tmp ) end if end subroutine resize_string pure integer function str_int_len ( i ) result ( sz ) ! Returns the length of the string representation of 'i' integer , intent ( in ) :: i integer , parameter :: MAX_STR = 100 character ( MAX_STR ) :: s ! If 's' is too short (MAX_STR too small), Fortran will abort with: ! \"Fortran runtime error: End of record\" write ( s , '(i0)' ) i sz = len_trim ( s ) end function pure function str_int ( i ) result ( s ) ! Converts integer \"i\" to string integer , intent ( in ) :: i character ( len = str_int_len ( i )) :: s write ( s , '(i0)' ) i end function pure integer function str_int64_len ( i ) result ( sz ) ! Returns the length of the string representation of 'i' integer ( int64 ), intent ( in ) :: i integer , parameter :: MAX_STR = 100 character ( MAX_STR ) :: s ! If 's' is too short (MAX_STR too small), Fortran will abort with: ! \"Fortran runtime error: End of record\" write ( s , '(i0)' ) i sz = len_trim ( s ) end function pure function str_int64 ( i ) result ( s ) ! Converts integer \"i\" to string integer ( int64 ), intent ( in ) :: i character ( len = str_int64_len ( i )) :: s write ( s , '(i0)' ) i end function pure integer function str_logical_len ( l ) result ( sz ) ! Returns the length of the string representation of 'l' logical , intent ( in ) :: l if ( l ) then sz = 6 else sz = 7 end if end function pure function str_logical ( l ) result ( s ) ! Converts logical \"l\" to string logical , intent ( in ) :: l character ( len = str_logical_len ( l )) :: s if ( l ) then s = \".true.\" else s = \".false.\" end if end function end module fpm_strings","tags":"","loc":"sourcefile/fpm_strings.f90.html"},{"title":"fpm_backend.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_backend Source Code fpm_backend.f90 Source Code !># Build backend !> Uses a valid `[[fpm_model]]` instance to schedule and execute the !> compilation and linking of package targets. !> !> The package build process (`[[build_package]]`) comprises three steps: !> !> 1. __Target sorting:__ topological sort of the target dependency graph (`[[sort_target]]`) !> 2. __Target scheduling:__ group targets into schedule regions based on the sorting (`[[schedule_targets]]`) !> 3. __Target building:__ generate targets by compilation or linking !> !> @note If compiled with OpenMP, targets will be build in parallel where possible. !> !>### Incremental compilation !> The backend process supports *incremental* compilation whereby targets are not !> re-compiled if their corresponding dependencies have not been modified. !> !> - Source-based targets (*i.e.* objects) are not re-compiled if the corresponding source !>   file is unmodified AND all of the target dependencies are not marked for re-compilation !> !> - Link targets (*i.e.* executables and libraries) are not re-compiled if the !>   target output file already exists AND all of the target dependencies are not marked for !>   re-compilation !> !> Source file modification is determined by a file digest (hash) which is calculated during !> the source parsing phase ([[fpm_source_parsing]]) and cached to disk after a target is !> successfully generated. !> module fpm_backend use fpm_environment , only : run use fpm_filesystem , only : dirname , join_path , exists , mkdir use fpm_model , only : fpm_model_t , build_target_t , build_target_ptr , & FPM_TARGET_OBJECT , FPM_TARGET_ARCHIVE , FPM_TARGET_EXECUTABLE use fpm_strings , only : string_cat implicit none private public :: build_package , sort_target , schedule_targets contains !> Top-level routine to build package described by `model` subroutine build_package ( model ) type ( fpm_model_t ), intent ( inout ) :: model integer :: i , j type ( build_target_ptr ), allocatable :: queue (:) integer , allocatable :: schedule_ptr (:) ! Need to make output directory for include (mod) files if (. not . exists ( join_path ( model % output_directory , model % package_name ))) then call mkdir ( join_path ( model % output_directory , model % package_name )) end if ! Perform depth-first topological sort of targets do i = 1 , size ( model % targets ) call sort_target ( model % targets ( i )% ptr ) end do ! Construct build schedule queue call schedule_targets ( queue , schedule_ptr , model % targets ) ! Loop over parallel schedule regions do i = 1 , size ( schedule_ptr ) - 1 ! Build targets in schedule region i !$omp parallel do default(shared) do j = schedule_ptr ( i ),( schedule_ptr ( i + 1 ) - 1 ) call build_target ( model , queue ( j )% ptr ) end do end do end subroutine build_package !> Topologically sort a target for scheduling by !>  recursing over its dependencies. !> !> Checks disk-cached source hashes to determine if objects are !>  up-to-date. Up-to-date sources are tagged as skipped. !> !> On completion, `target` should either be marked as !> sorted (`target%sorted=.true.`) or skipped (`target%skip=.true.`) !> !> If `target` is marked as sorted, `target%schedule` should be an !> integer greater than zero indicating the region for scheduling !> recursive subroutine sort_target ( target ) type ( build_target_t ), intent ( inout ), target :: target integer :: i , j , fh , stat type ( build_target_t ), pointer :: exe_obj ! Check if target has already been processed (as a dependency) if ( target % sorted . or . target % skip ) then return end if ! Check for a circular dependency ! (If target has been touched but not processed) if ( target % touched ) then write ( * , * ) '(!) Circular dependency found with: ' , target % output_file stop else target % touched = . true . ! Set touched flag end if ! Load cached source file digest if present if (. not . allocated ( target % digest_cached ) . and . & exists ( target % output_file ) . and . & exists ( target % output_file // '.digest' )) then allocate ( target % digest_cached ) open ( newunit = fh , file = target % output_file // '.digest' , status = 'old' ) read ( fh , * , iostat = stat ) target % digest_cached close ( fh ) if ( stat /= 0 ) then ! Cached digest is not recognized deallocate ( target % digest_cached ) end if end if if ( allocated ( target % source )) then ! Skip if target is source-based and source file is unmodified if ( allocated ( target % digest_cached )) then if ( target % digest_cached == target % source % digest ) target % skip = . true . end if elseif ( exists ( target % output_file )) then ! Skip if target is not source-based and already exists target % skip = . true . end if ! Loop over target dependencies target % schedule = 1 do i = 1 , size ( target % dependencies ) ! Sort dependency call sort_target ( target % dependencies ( i )% ptr ) if (. not . target % dependencies ( i )% ptr % skip ) then ! Can't skip target if any dependency is not skipped target % skip = . false . ! Set target schedule after all of its dependencies target % schedule = max ( target % schedule , target % dependencies ( i )% ptr % schedule + 1 ) end if end do ! Mark flag as processed: either sorted or skipped target % sorted = . not . target % skip end subroutine sort_target !> Construct a build schedule from the sorted targets. !> !> The schedule is broken into regions, described by `schedule_ptr`, !>  where targets in each region can be compiled in parallel. !> subroutine schedule_targets ( queue , schedule_ptr , targets ) type ( build_target_ptr ), allocatable , intent ( out ) :: queue (:) integer , allocatable :: schedule_ptr (:) type ( build_target_ptr ), intent ( in ) :: targets (:) integer :: i , j integer :: n_schedule , n_sorted n_schedule = 0 ! Number of schedule regions n_sorted = 0 ! Total number of targets to build do i = 1 , size ( targets ) if ( targets ( i )% ptr % sorted ) then n_sorted = n_sorted + 1 end if n_schedule = max ( n_schedule , targets ( i )% ptr % schedule ) end do allocate ( queue ( n_sorted )) allocate ( schedule_ptr ( n_schedule + 1 )) ! Construct the target queue and schedule region pointer n_sorted = 1 schedule_ptr ( n_sorted ) = 1 do i = 1 , n_schedule do j = 1 , size ( targets ) if ( targets ( j )% ptr % sorted ) then if ( targets ( j )% ptr % schedule == i ) then queue ( n_sorted )% ptr => targets ( j )% ptr n_sorted = n_sorted + 1 end if end if end do schedule_ptr ( i + 1 ) = n_sorted end do end subroutine schedule_targets !> Call compile/link command for a single target. !> !> If successful, also caches the source file digest to disk. !> subroutine build_target ( model , target ) type ( fpm_model_t ), intent ( in ) :: model type ( build_target_t ), intent ( in ), target :: target integer :: ilib , fh character (:), allocatable :: link_flags if (. not . exists ( dirname ( target % output_file ))) then call mkdir ( dirname ( target % output_file )) end if select case ( target % target_type ) case ( FPM_TARGET_OBJECT ) call run ( model % fortran_compiler // \" -c \" // target % source % file_name // model % fortran_compile_flags & // \" -o \" // target % output_file ) case ( FPM_TARGET_EXECUTABLE ) link_flags = string_cat ( target % link_objects , \" \" ) if ( allocated ( model % library_file )) then link_flags = link_flags // \" \" // model % library_file // \" \" // model % link_flags else link_flags = link_flags // \" \" // model % link_flags end if if ( allocated ( target % link_libraries )) then if ( size ( target % link_libraries ) > 0 ) then link_flags = link_flags // \" -l\" // string_cat ( target % link_libraries , \" -l\" ) end if end if call run ( model % fortran_compiler // \" \" // model % fortran_compile_flags & // \" \" // link_flags // \" -o \" // target % output_file ) case ( FPM_TARGET_ARCHIVE ) call run ( \"ar -rs \" // target % output_file // \" \" // string_cat ( target % link_objects , \" \" )) end select if ( allocated ( target % source )) then open ( newunit = fh , file = target % output_file // '.digest' , status = 'unknown' ) write ( fh , * ) target % source % digest close ( fh ) end if end subroutine build_target end module fpm_backend","tags":"","loc":"sourcefile/fpm_backend.f90.html"},{"title":"git.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_git Source Code git.f90 Source Code !> Implementation for interacting with git repositories. module fpm_git use fpm_error , only : error_t , fatal_error use fpm_filesystem , only : get_temp_filename , getline implicit none public :: git_target_t public :: git_target_default , git_target_branch , git_target_tag , & & git_target_revision public :: git_revision !> Possible git target type :: enum_descriptor !> Default target integer :: default = 200 !> Branch in git repository integer :: branch = 201 !> Tag in git repository integer :: tag = 202 !> Commit hash integer :: revision = 203 end type enum_descriptor !> Actual enumerator for descriptors type ( enum_descriptor ), parameter :: git_descriptor = enum_descriptor () !> Description of an git target type :: git_target_t !> Kind of the git target integer , private :: descriptor = git_descriptor % default !> Target URL of the git repository character ( len = :), allocatable :: url !> Additional descriptor of the git object character ( len = :), allocatable :: object contains !> Fetch and checkout in local directory procedure :: checkout !> Show information on instance procedure :: info end type git_target_t contains !> Default target function git_target_default ( url ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % default self % url = url end function git_target_default !> Target a branch in the git repository function git_target_branch ( url , branch ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Name of the branch of interest character ( len =* ), intent ( in ) :: branch !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % branch self % url = url self % object = branch end function git_target_branch !> Target a specific git revision function git_target_revision ( url , sha1 ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Commit hash of interest character ( len =* ), intent ( in ) :: sha1 !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % revision self % url = url self % object = sha1 end function git_target_revision !> Target a git tag function git_target_tag ( url , tag ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Tag name of interest character ( len =* ), intent ( in ) :: tag !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % tag self % url = url self % object = tag end function git_target_tag subroutine checkout ( self , local_path , error ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Error type ( error_t ), allocatable , intent ( out ) :: error integer :: stat character ( len = :), allocatable :: object if ( allocated ( self % object )) then object = self % object else object = 'HEAD' end if call execute_command_line ( \"git init \" // local_path , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while initiating git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" fetch --depth=1 \" // & self % url // \" \" // object , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while fetching git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" checkout -qf FETCH_HEAD\" , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while checking out git repository for remote dependency' ) return end if end subroutine checkout subroutine git_revision ( local_path , object , error ) !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Git object reference character ( len = :), allocatable , intent ( out ) :: object !> Error type ( error_t ), allocatable , intent ( out ) :: error integer :: stat , unit , istart , iend character ( len = :), allocatable :: temp_file , line , iomsg character ( len =* ), parameter :: hexdigits = '0123456789abcdef' allocate ( temp_file , source = get_temp_filename ()) line = \"git -C \" // local_path // \" log -n 1 > \" // temp_file call execute_command_line ( line , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Error while retrieving commit information\" ) return end if open ( file = temp_file , newunit = unit ) call getline ( unit , line , stat , iomsg ) if ( stat /= 0 ) then call fatal_error ( error , iomsg ) return end if close ( unit , status = \"delete\" ) ! Tokenize: ! commit 0123456789abcdef (HEAD, ...) istart = scan ( line , ' ' ) + 1 iend = verify ( line ( istart :), hexdigits ) + istart - 1 if ( iend < istart ) iend = len ( line ) object = line ( istart : iend ) end subroutine git_revision !> Show information on git target subroutine info ( self , unit , verbosity ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Git target\" if ( allocated ( self % url )) then write ( unit , fmt ) \"- URL\" , self % url end if if ( allocated ( self % object )) then select case ( self % descriptor ) case default write ( unit , fmt ) \"- object\" , self % object case ( git_descriptor % tag ) write ( unit , fmt ) \"- tag\" , self % object case ( git_descriptor % branch ) write ( unit , fmt ) \"- branch\" , self % object case ( git_descriptor % revision ) write ( unit , fmt ) \"- sha1\" , self % object end select end if end subroutine info end module fpm_git","tags":"","loc":"sourcefile/git.f90.html"},{"title":"error.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_error Source Code error.f90 Source Code !> Implementation of basic error handling. module fpm_error implicit none private public :: error_t public :: fatal_error , syntax_error , file_not_found_error public :: file_parse_error !> Data type defining an error type :: error_t !> Error message character ( len = :), allocatable :: message end type error_t !> Alias syntax errors to fatal errors for now interface syntax_error module procedure :: fatal_error end interface syntax_error contains !> Generic fatal runtime error subroutine fatal_error ( error , message ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Error message character ( len =* ), intent ( in ) :: message allocate ( error ) error % message = message end subroutine fatal_error !> Error created when a file is missing or not found subroutine file_not_found_error ( error , file_name ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of the missing file character ( len =* ), intent ( in ) :: file_name allocate ( error ) error % message = \"'\" // file_name // \"' could not be found, check if the file exists\" end subroutine file_not_found_error !> Error created when file parsing fails subroutine file_parse_error ( error , file_name , message , line_num , & line_string , line_col ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of file character ( len =* ), intent ( in ) :: file_name !> Parse error message character ( len =* ), intent ( in ) :: message !> Line number of parse error integer , intent ( in ), optional :: line_num !> Line context string character ( len =* ), intent ( in ), optional :: line_string !> Line context column integer , intent ( in ), optional :: line_col character ( 50 ) :: temp_string allocate ( error ) error % message = 'Parse error: ' // message // new_line ( 'a' ) error % message = error % message // file_name if ( present ( line_num )) then write ( temp_string , '(I0)' ) line_num error % message = error % message // ':' // trim ( temp_string ) end if if ( present ( line_col )) then if ( line_col > 0 ) then write ( temp_string , '(I0)' ) line_col error % message = error % message // ':' // trim ( temp_string ) end if end if if ( present ( line_string )) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // line_string if ( present ( line_col )) then if ( line_col > 0 ) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // repeat ( ' ' , line_col - 1 ) // '&#94;' end if end if end if end subroutine file_parse_error end module fpm_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"toml.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_toml Source Code toml.f90 Source Code !># Interface to TOML processing library !> !> This module acts as a proxy to the `toml-f` public Fortran API and allows !> to selectively expose components from the library to `fpm`. !> The interaction with `toml-f` data types outside of this module should be !> limited to tables, arrays and key-lists, most of the necessary interactions !> are implemented in the building interface with the `get_value` and `set_value` !> procedures. !> !> This module allows to implement features necessary for `fpm`, which are !> not yet available in upstream `toml-f`. !> !> For more details on the library used see the !> [TOML-Fortran](https://toml-f.github.io/toml-f) developer pages. module fpm_toml use fpm_error , only : error_t , fatal_error , file_not_found_error use fpm_strings , only : string_t use tomlf , only : toml_table , toml_array , toml_key , toml_stat , get_value , & & set_value , toml_parse , toml_error , new_table , add_table , add_array , & & toml_serializer , len implicit none private public :: read_package_file public :: toml_table , toml_array , toml_key , toml_stat , get_value , set_value public :: new_table , add_table , add_array , len public :: toml_error , toml_serializer , toml_parse interface get_value module procedure :: get_child_value_string_list end interface get_value contains !> Process the configuration file to a TOML data structure subroutine read_package_file ( table , manifest , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the package configuration file character ( len =* ), intent ( in ) :: manifest !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = manifest , exist = exist ) if (. not . exist ) then call file_not_found_error ( error , manifest ) return end if open ( file = manifest , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_package_file subroutine get_child_value_string_list ( table , key , list , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Key to read from character ( len =* ), intent ( in ) :: key !> List of strings to read type ( string_t ), allocatable , intent ( out ) :: list (:) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat , ilist , nlist type ( toml_array ), pointer :: children character ( len = :), allocatable :: str call get_value ( table , key , children , requested = . false .) if ( associated ( children )) then nlist = len ( children ) allocate ( list ( nlist )) do ilist = 1 , nlist call get_value ( children , ilist , str , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Entry in \" // key // \" field cannot be read\" ) exit end if call move_alloc ( str , list ( ilist )% s ) end do if ( allocated ( error )) return else call get_value ( table , key , str , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Entry in \" // key // \" field cannot be read\" ) return end if if ( allocated ( str )) then allocate ( list ( 1 )) call move_alloc ( str , list ( 1 )% s ) end if end if end subroutine get_child_value_string_list end module fpm_toml","tags":"","loc":"sourcefile/toml.f90.html"},{"title":"manifest.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest Source Code manifest.f90 Source Code !> Package configuration data. !> !> This module provides the necessary procedure to translate a TOML document !> to the corresponding Fortran type, while verifying it with respect to !> its schema. !> !> Additionally, the required data types for users of this module are reexported !> to hide the actual implementation details. module fpm_manifest use fpm_manifest_build , only : build_config_t use fpm_manifest_example , only : example_config_t use fpm_manifest_executable , only : executable_config_t use fpm_manifest_dependency , only : dependency_config_t use fpm_manifest_library , only : library_config_t use fpm_manifest_package , only : package_config_t , new_package use fpm_error , only : error_t , fatal_error , file_not_found_error use fpm_toml , only : toml_table , read_package_file use fpm_manifest_test , only : test_config_t use fpm_filesystem , only : join_path , exists , dirname implicit none private public :: get_package_data , default_executable , default_library , default_test public :: default_example public :: package_config_t , dependency_config_t contains !> Populate library in case we find the default src directory subroutine default_library ( self ) !> Instance of the library meta data type ( library_config_t ), intent ( out ) :: self self % source_dir = \"src\" end subroutine default_library !> Populate executable in case we find the default app directory subroutine default_executable ( self , name ) !> Instance of the executable meta data type ( executable_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"app\" self % main = \"main.f90\" end subroutine default_executable !> Populate test in case we find the default example/ directory subroutine default_example ( self , name ) !> Instance of the executable meta data type ( example_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name // \"-demo\" self % source_dir = \"example\" self % main = \"main.f90\" end subroutine default_example !> Populate test in case we find the default test/ directory subroutine default_test ( self , name ) !> Instance of the executable meta data type ( test_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name // \"-test\" self % source_dir = \"test\" self % main = \"main.f90\" end subroutine default_test !> Obtain package meta data from a configuation file subroutine get_package_data ( package , file , error , apply_defaults ) !> Parsed package meta data type ( package_config_t ), intent ( out ) :: package !> Name of the package configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error !> Apply package defaults (uses file system operations) logical , intent ( in ), optional :: apply_defaults type ( toml_table ), allocatable :: table character ( len = :), allocatable :: root call read_package_file ( table , file , error ) if ( allocated ( error )) return if (. not . allocated ( table )) then call fatal_error ( error , \"Unclassified error while reading: '\" // file // \"'\" ) return end if call new_package ( package , table , error ) if ( allocated ( error )) return if ( present ( apply_defaults )) then if ( apply_defaults ) then root = dirname ( file ) if ( len_trim ( root ) == 0 ) root = \".\" call package_defaults ( package , root , error ) if ( allocated ( error )) return end if end if end subroutine get_package_data !> Apply package defaults subroutine package_defaults ( package , root , error ) !> Parsed package meta data type ( package_config_t ), intent ( inout ) :: package !> Current working directory character ( len =* ), intent ( in ) :: root !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error ! Populate library in case we find the default src directory if (. not . allocated ( package % library ) . and . & & exists ( join_path ( root , \"src\" ))) then allocate ( package % library ) call default_library ( package % library ) end if ! Populate executable in case we find the default app if (. not . allocated ( package % executable ) . and . & & exists ( join_path ( root , \"app\" , \"main.f90\" ))) then allocate ( package % executable ( 1 )) call default_executable ( package % executable ( 1 ), package % name ) end if ! Populate example in case we find the default example directory if (. not . allocated ( package % example ) . and . & exists ( join_path ( \"example\" , \"main.f90\" ))) then allocate ( package % example ( 1 )) call default_example ( package % example ( 1 ), package % name ) endif ! Populate test in case we find the default test directory if (. not . allocated ( package % test ) . and . & & exists ( join_path ( root , \"test\" , \"main.f90\" ))) then allocate ( package % test ( 1 )) call default_test ( package % test ( 1 ), package % name ) endif if (. not .( allocated ( package % library ) & & . or . allocated ( package % executable ) & & . or . allocated ( package % example ) & & . or . allocated ( package % test ))) then call fatal_error ( error , \"Neither library nor executable found, there is nothing to do\" ) return end if end subroutine package_defaults end module fpm_manifest","tags":"","loc":"sourcefile/manifest.f90.html"},{"title":"installer.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_installer Source Code installer.f90 Source Code !> Implementation of an installer object. !> !> The installer provides a way to install objects to their respective directories !> in the installation prefix, a generic install command allows to install !> to any directory within the prefix. module fpm_installer use , intrinsic :: iso_fortran_env , only : output_unit use fpm_environment , only : get_os_type , os_is_unix use fpm_error , only : error_t , fatal_error use fpm_filesystem , only : join_path , mkdir , exists , unix_path , windows_path , & env_variable implicit none private public :: installer_t , new_installer !> Declaration of the installer type type :: installer_t !> Path to installation directory character ( len = :), allocatable :: prefix !> Binary dir relative to the installation prefix character ( len = :), allocatable :: bindir !> Library directory relative to the installation prefix character ( len = :), allocatable :: libdir !> Include directory relative to the installation prefix character ( len = :), allocatable :: includedir !> Output unit for informative printout integer :: unit = output_unit !> Verbosity of the installer integer :: verbosity = 1 !> Command to copy objects into the installation prefix character ( len = :), allocatable :: copy !> Cached operating system integer :: os contains !> Install an executable in its correct subdirectory procedure :: install_executable !> Install a library in its correct subdirectory procedure :: install_library !> Install a header/module in its correct subdirectory procedure :: install_header !> Install a generic file into a subdirectory in the installation prefix procedure :: install !> Run an installation command, type-bound for unit testing purposes procedure :: run !> Create a new directory in the prefix, type-bound for unit testing purposes procedure :: make_dir end type installer_t !> Default name of the binary subdirectory character ( len =* ), parameter :: default_bindir = \"bin\" !> Default name of the library subdirectory character ( len =* ), parameter :: default_libdir = \"lib\" !> Default name of the include subdirectory character ( len =* ), parameter :: default_includedir = \"include\" !> Default name of the installation prefix on Unix platforms character ( len =* ), parameter :: default_prefix_unix = \"/usr/local\" !> Default name of the installation prefix on Windows platforms character ( len =* ), parameter :: default_prefix_win = \"C:\\\" !> Copy command on Unix platforms character(len=*), parameter :: default_copy_unix = \" cp \" !> Copy command on Windows platforms character(len=*), parameter :: default_copy_win = \" copy \" contains !> Create a new instance of an installer subroutine new_installer(self, prefix, bindir, libdir, includedir, verbosity, & copy) !> Instance of the installer type(installer_t), intent(out) :: self !> Path to installation directory character(len=*), intent(in), optional :: prefix !> Binary dir relative to the installation prefix character(len=*), intent(in), optional :: bindir !> Library directory relative to the installation prefix character(len=*), intent(in), optional :: libdir !> Include directory relative to the installation prefix character(len=*), intent(in), optional :: includedir !> Verbosity of the installer integer, intent(in), optional :: verbosity !> Copy command character(len=*), intent(in), optional :: copy self%os = get_os_type() if (present(copy)) then self%copy = copy else if (os_is_unix(self%os)) then self%copy = default_copy_unix else self%copy = default_copy_win end if end if if (present(includedir)) then self%includedir = includedir else self%includedir = default_includedir end if if (present(prefix)) then self%prefix = prefix else call set_default_prefix(self%prefix, self%os) end if if (present(bindir)) then self%bindir = bindir else self%bindir = default_bindir end if if (present(libdir)) then self%libdir = libdir else self%libdir = default_libdir end if if (present(verbosity)) then self%verbosity = verbosity else self%verbosity = 1 end if end subroutine new_installer !> Set the default prefix for the installation subroutine set_default_prefix(prefix, os) !> Installation prefix character(len=:), allocatable :: prefix !> Platform identifier integer, intent(in), optional :: os character(len=:), allocatable :: home if (os_is_unix(os)) then call env_variable(home, \" HOME \") if (allocated(home)) then prefix = join_path(home, \" . local \") else prefix = default_prefix_unix end if else call env_variable(home, \" APPDATA \") if (allocated(home)) then prefix = join_path(home, \" local \") else prefix = default_prefix_win end if end if end subroutine set_default_prefix !> Install an executable in its correct subdirectory subroutine install_executable(self, executable, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Path to the executable character(len=*), intent(in) :: executable !> Error handling type(error_t), allocatable, intent(out) :: error integer :: ll if (.not.os_is_unix(self%os)) then ll = len(executable) if (executable(max(1, ll-3):ll) /= \" . exe \") then call self%install(executable//\" . exe \", self%bindir, error) return end if end if call self%install(executable, self%bindir, error) end subroutine install_executable !> Install a library in its correct subdirectory subroutine install_library(self, library, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Path to the library character(len=*), intent(in) :: library !> Error handling type(error_t), allocatable, intent(out) :: error call self%install(library, self%libdir, error) end subroutine install_library !> Install a header/module in its correct subdirectory subroutine install_header(self, header, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Path to the header character(len=*), intent(in) :: header !> Error handling type(error_t), allocatable, intent(out) :: error call self%install(header, self%includedir, error) end subroutine install_header !> Install a generic file into a subdirectory in the installation prefix subroutine install(self, source, destination, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Path to the original file character(len=*), intent(in) :: source !> Path to the destination inside the prefix character(len=*), intent(in) :: destination !> Error handling type(error_t), allocatable, intent(out) :: error character(len=:), allocatable :: install_dest install_dest = join_path(self%prefix, destination) if (os_is_unix(self%os)) then install_dest = unix_path(install_dest) else install_dest = windows_path(install_dest) end if call self%make_dir(install_dest, error) if (allocated(error)) return if (self%verbosity > 0) then if (exists(install_dest)) then write(self%unit, '(\" # Update : \", 1x, a, 1x, \" -> \", 1x, a)') & source, install_dest else write(self%unit, '(\" # Install : \", 1x, a, 1x, \" -> \", 1x, a)') & source, install_dest end if end if call self%run(self%copy//' \" '//source//' \" \" '//install_dest//' \"', error) if (allocated(error)) return end subroutine install !> Create a new directory in the prefix subroutine make_dir(self, dir, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Directory to be created character(len=*), intent(in) :: dir !> Error handling type(error_t), allocatable, intent(out) :: error if (.not.exists(dir)) then if (self%verbosity > 1) then write(self%unit, '(\" # Dir : \", 1x, a)') dir end if call mkdir(dir) end if end subroutine make_dir !> Run an installation command subroutine run(self, command, error) !> Instance of the installer class(installer_t), intent(inout) :: self !> Command to be launched character(len=*), intent(in) :: command !> Error handling type(error_t), allocatable, intent(out) :: error integer :: stat if (self%verbosity > 1) then write(self%unit, '(\" # Run : \", 1x, a)') command end if call execute_command_line(command, exitstat=stat) if (stat /= 0) then call fatal_error(error, \" Failed in command : '\"//command//\"' \" ) return end if end subroutine run end module fpm_installer","tags":"","loc":"sourcefile/installer.f90.html"},{"title":"versioning.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_versioning Source Code versioning.f90 Source Code !> Implementation of versioning data for comparing packages module fpm_versioning use fpm_error , only : error_t , syntax_error implicit none private public :: version_t , new_version , char type :: version_t private !> Version numbers found integer , allocatable :: num (:) contains generic :: operator ( == ) => equals procedure , private :: equals generic :: operator ( /= ) => not_equals procedure , private :: not_equals generic :: operator ( > ) => greater procedure , private :: greater generic :: operator ( < ) => less procedure , private :: less generic :: operator ( >= ) => greater_equals procedure , private :: greater_equals generic :: operator ( <= ) => less_equals procedure , private :: less_equals !> Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic :: operator (. match .) => match procedure , private :: match !> Create a printable string from a version data type procedure :: to_string end type version_t !> Arbitrary internal limit of the version parser integer , parameter :: max_limit = 3 interface char module procedure :: as_string end interface char interface new_version module procedure :: new_version_from_string module procedure :: new_version_from_int end interface new_version contains !> Create a new version from a string subroutine new_version_from_int ( self , num ) !> Instance of the versioning data type ( version_t ), intent ( out ) :: self !> Subversion numbers to define version data integer , intent ( in ) :: num (:) self % num = num end subroutine new_version_from_int !> Create a new version from a string subroutine new_version_from_string ( self , string , error ) !> Instance of the versioning data type ( version_t ), intent ( out ) :: self !> String describing the version information character ( len =* ), intent ( in ) :: string !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character :: tok integer :: ii , istart , iend , stat , nn integer :: num ( max_limit ) logical :: is_number nn = 0 iend = 0 istart = 0 is_number = . false . do while ( iend < len ( string )) call next ( string , istart , iend , is_number , error ) if ( allocated ( error )) exit if ( is_number ) then if ( nn >= max_limit ) then call token_error ( error , string , istart , iend , & & \"Too many subversions found\" ) exit end if nn = nn + 1 read ( string ( istart : iend ), * , iostat = stat ) num ( nn ) if ( stat /= 0 ) then call token_error ( error , string , istart , iend , & & \"Failed to parse version number\" ) exit end if end if end do if ( allocated ( error )) return if (. not . is_number ) then call token_error ( error , string , istart , iend , & & \"Expected version number, but no characters are left\" ) return end if call new_version ( self , num (: nn )) end subroutine new_version_from_string !> Tokenize a version string subroutine next ( string , istart , iend , is_number , error ) !> String describing the version information character ( len =* ), intent ( in ) :: string !> Start of last token, start of next token on exit integer , intent ( inout ) :: istart !> End of last token on entry, end of next token on exit integer , intent ( inout ) :: iend !> Token produced is a number logical , intent ( inout ) :: is_number !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii , nn logical :: was_number character :: tok , last was_number = is_number nn = len ( string ) if ( iend >= nn ) then istart = nn iend = nn return end if ii = min ( iend + 1 , nn ) tok = string ( ii : ii ) is_number = tok /= '.' if ( is_number . eqv . was_number ) then call token_error ( error , string , istart , ii , & & \"Unexpected token found\" ) return end if if (. not . is_number ) then is_number = . false . istart = ii iend = ii return end if istart = ii do ii = min ( iend + 1 , nn ), nn tok = string ( ii : ii ) select case ( tok ) case default call token_error ( error , string , istart , ii , & & \"Invalid character in version number\" ) exit case ( '.' ) exit case ( '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' ) iend = ii cycle end select end do end subroutine next !> Create an error on an invalid token, provide some visual context as well subroutine token_error ( error , string , istart , iend , message ) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error !> String describing the version information character ( len =* ), intent ( in ) :: string !> Start of last token, start of next token on exit integer , intent ( in ) :: istart !> End of last token on entry, end of next token on exit integer , intent ( in ) :: iend !> Error message character ( len =* ), intent ( in ) :: message character ( len =* ), parameter :: nl = new_line ( 'a' ) allocate ( error ) error % message = message // nl // \"  | \" // string // nl // & & \"  |\" // repeat ( '-' , istart ) // repeat ( '&#94;' , iend - istart + 1 ) end subroutine token_error subroutine to_string ( self , string ) !> Version number class ( version_t ), intent ( in ) :: self !> Character representation of the version character ( len = :), allocatable , intent ( out ) :: string integer , parameter :: buffersize = 64 character ( len = buffersize ) :: buffer integer :: ii do ii = 1 , size ( self % num ) if ( allocated ( string )) then write ( buffer , '(\".\", i0)' ) self % num ( ii ) string = string // trim ( buffer ) else write ( buffer , '(i0)' ) self % num ( ii ) string = trim ( buffer ) end if end do if (. not . allocated ( string )) then string = '0' end if end subroutine to_string function as_string ( self ) result ( string ) !> Version number class ( version_t ), intent ( in ) :: self !> Character representation of the version character ( len = :), allocatable :: string call self % to_string ( string ) end function as_string !> Check to version numbers for equality elemental function equals ( lhs , rhs ) result ( is_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version match logical :: is_equal is_equal = . not .( lhs > rhs ) if ( is_equal ) then is_equal = . not .( rhs > lhs ) end if end function equals !> Check two versions for inequality elemental function not_equals ( lhs , rhs ) result ( not_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version mismatch logical :: not_equal not_equal = lhs > rhs if (. not . not_equal ) then not_equal = rhs > lhs end if end function not_equals !> Relative comparison of two versions elemental function greater ( lhs , rhs ) result ( is_greater ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is greater logical :: is_greater integer :: ii do ii = 1 , min ( size ( lhs % num ), size ( rhs % num )) is_greater = lhs % num ( ii ) > rhs % num ( ii ) if ( is_greater ) exit end do if ( is_greater ) return is_greater = size ( lhs % num ) > size ( rhs % num ) if ( is_greater ) then do ii = size ( rhs % num ) + 1 , size ( lhs % num ) is_greater = lhs % num ( ii ) > 0 if ( is_greater ) exit end do end if end function greater !> Relative comparison of two versions elemental function less ( lhs , rhs ) result ( is_less ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is less logical :: is_less is_less = rhs > lhs end function less !> Relative comparison of two versions elemental function greater_equals ( lhs , rhs ) result ( is_greater_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is greater or equal logical :: is_greater_equal is_greater_equal = . not . ( rhs > lhs ) end function greater_equals !> Relative comparison of two versions elemental function less_equals ( lhs , rhs ) result ( is_less_equal ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> First version is less or equal logical :: is_less_equal is_less_equal = . not . ( lhs > rhs ) end function less_equals !> Try to match first version against second version elemental function match ( lhs , rhs ) !> First version number class ( version_t ), intent ( in ) :: lhs !> Second version number class ( version_t ), intent ( in ) :: rhs !> Version match following semantic versioning rules logical :: match type ( version_t ) :: tmp match = . not .( rhs > lhs ) if ( match ) then tmp % num = rhs % num tmp % num ( size ( tmp % num )) = tmp % num ( size ( tmp % num )) + 1 match = tmp > lhs end if end function match end module fpm_versioning","tags":"","loc":"sourcefile/versioning.f90.html"},{"title":"dependency.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_dependency Source Code dependency.f90 Source Code !> # Dependency management !> !> ## Fetching dependencies and creating a dependency tree !> !> Dependencies on the top-level can be specified from: !> !> - `package%dependencies` !> - `package%dev_dependencies` !> - `package%executable(:)%dependencies` !> - `package%test(:)%dependencies` !> !> Each dependency is fetched in some way and provides a path to its package !> manifest. !> The `package%dependencies` of the dependencies are resolved recursively. !> !> To initialize the dependency tree all dependencies are recursively fetched !> and stored in a flat data structure to avoid retrieving a package twice. !> The data structure used to store this information should describe the current !> status of the dependency tree. Important information are: !> !> - name of the package !> - version of the package !> - path to the package root !> !> Additionally, for version controlled dependencies the following should be !> stored along with the package: !> !> - the upstream url !> - the current checked out revision !> !> Fetching a remote (version controlled) dependency turns it for our purpose !> into a local path dependency which is handled by the same means. !> !> ## Updating dependencies !> !> For a given dependency tree all top-level dependencies can be updated. !> We have two cases to consider, a remote dependency and a local dependency, !> again, remote dependencies turn into local dependencies by fetching. !> Therefore we will update remote dependencies by simply refetching them. !> !> For remote dependencies we have to refetch if the revision in the manifest !> changes or the upstream HEAD has changed (for branches _and_ tags). !> !> @Note For our purpose a tag is just a fancy branch name. Tags can be delete and !>       modified afterwards, therefore they do not differ too much from branches !>       from our perspective. !> !> For the latter case we only know if we actually fetch from the upstream URL. !> !> In case of local (and fetched remote) dependencies we have to read the package !> manifest and compare its dependencies against our dependency tree, any change !> requires updating the respective dependencies as well. !> !> ## Handling dependency compatibilties !> !> Currenly ignored. First come, first serve. module fpm_dependency use , intrinsic :: iso_fortran_env , only : output_unit use fpm_environment , only : get_os_type , OS_WINDOWS use fpm_error , only : error_t , fatal_error use fpm_filesystem , only : exists , join_path , mkdir , canon_path , windows_path use fpm_git , only : git_target_revision , git_target_default , git_revision use fpm_manifest , only : package_config_t , dependency_config_t , & get_package_data use fpm_strings , only : string_t , operator (. in .) use fpm_toml , only : toml_table , toml_key , toml_error , toml_serializer , & toml_parse , get_value , set_value , add_table use fpm_versioning , only : version_t , new_version , char implicit none private public :: dependency_tree_t , new_dependency_tree public :: dependency_node_t , new_dependency_node public :: resize !> Overloaded reallocation interface interface resize module procedure :: resize_dependency_node end interface resize !> Dependency node in the projects dependency tree type , extends ( dependency_config_t ) :: dependency_node_t !> Actual version of this dependency type ( version_t ), allocatable :: version !> Installation prefix of this dependencies character ( len = :), allocatable :: proj_dir !> Checked out revision of the version control system character ( len = :), allocatable :: revision !> Dependency is handled logical :: done = . false . !> Dependency should be updated logical :: update = . false . contains !> Update dependency from project manifest procedure :: register end type dependency_node_t !> Respresentation of a projects dependencies !> !> The dependencies are stored in a simple array for now, this can be replaced !> with a binary-search tree or a hash table in the future. type :: dependency_tree_t !> Unit for IO integer :: unit = output_unit !> Verbosity of printout integer :: verbosity = 1 !> Installation prefix for dependencies character ( len = :), allocatable :: dep_dir !> Number of currently registered dependencies integer :: ndep = 0 !> Flattend list of all dependencies type ( dependency_node_t ), allocatable :: dep (:) !> Cache file character ( len = :), allocatable :: cache contains !> Overload procedure to add new dependencies to the tree generic :: add => add_project , add_project_dependencies , add_dependencies , & add_dependency !> Main entry point to add a project procedure , private :: add_project !> Add a project and its dependencies to the dependency tree procedure , private :: add_project_dependencies !> Add a list of dependencies to the dependency tree procedure , private :: add_dependencies !> Add a single dependency to the dependency tree procedure , private :: add_dependency !> Resolve dependencies generic :: resolve => resolve_dependencies , resolve_dependency !> Resolve dependencies procedure , private :: resolve_dependencies !> Resolve dependencies procedure , private :: resolve_dependency !> Find a dependency in the tree generic :: find => find_dependency , find_name !> Find a dependency from an dependency configuration procedure , private :: find_dependency !> Find a dependency by its name procedure , private :: find_name !> Depedendncy resolution finished procedure :: finished !> Reading of dependency tree generic :: load => load_from_file , load_from_unit , load_from_toml !> Read dependency tree from file procedure , private :: load_from_file !> Read dependency tree from formatted unit procedure , private :: load_from_unit !> Read dependency tree from TOML data structure procedure , private :: load_from_toml !> Writing of dependency tree generic :: dump => dump_to_file , dump_to_unit , dump_to_toml !> Write dependency tree to file procedure , private :: dump_to_file !> Write dependency tree to formatted unit procedure , private :: dump_to_unit !> Write dependency tree to TOML data structure procedure , private :: dump_to_toml !> Update dependency tree generic :: update => update_dependency !> Update a list of dependencies procedure , private :: update_dependency end type dependency_tree_t !> Common output format for writing to the command line character ( len =* ), parameter :: out_fmt = '(\"#\", *(1x, g0))' contains !> Create a new dependency tree subroutine new_dependency_tree ( self , verbosity , cache ) !> Instance of the dependency tree type ( dependency_tree_t ), intent ( out ) :: self !> Verbosity of printout integer , intent ( in ), optional :: verbosity !> Name of the cache file character ( len =* ), intent ( in ), optional :: cache call resize ( self % dep ) self % dep_dir = join_path ( \"build\" , \"dependencies\" ) if ( present ( verbosity )) then self % verbosity = verbosity end if if ( present ( cache )) then self % cache = cache end if end subroutine new_dependency_tree !> Create a new dependency node from a configuration pure subroutine new_dependency_node ( self , dependency , version , proj_dir , update ) !> Instance of the dependency node type ( dependency_node_t ), intent ( out ) :: self !> Dependency configuration data type ( dependency_config_t ), intent ( in ) :: dependency !> Version of the dependency type ( version_t ), intent ( in ), optional :: version !> Installation prefix of the dependency character ( len =* ), intent ( in ), optional :: proj_dir !> Dependency should be updated logical , intent ( in ), optional :: update self % dependency_config_t = dependency if ( present ( version )) then self % version = version end if if ( present ( proj_dir )) then self % proj_dir = proj_dir end if if ( present ( update )) then self % update = update end if end subroutine new_dependency_node !> Add project dependencies, each depth level after each other. !> !> We implement this algorithm in an interative rather than a recursive fashion !> as a choice of design. subroutine add_project ( self , package , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Project configuration to add type ( package_config_t ), intent ( in ) :: package !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( dependency_config_t ) :: dependency character ( len = :), allocatable :: root logical :: main if ( allocated ( self % cache )) then call self % load ( self % cache , error ) if ( allocated ( error )) return end if if (. not . exists ( self % dep_dir )) then call mkdir ( self % dep_dir ) end if root = \".\" ! Create this project as the first dependency node (depth 0) dependency % name = package % name dependency % path = root call self % add ( dependency , error ) if ( allocated ( error )) return ! Resolve the root project call self % resolve ( root , error ) if ( allocated ( error )) return ! Add the root project dependencies (depth 1) call self % add ( package , root , . true ., error ) if ( allocated ( error )) return ! Now decent into the dependency tree, level for level do while (. not . self % finished ()) call self % resolve ( root , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return if ( allocated ( self % cache )) then call self % dump ( self % cache , error ) if ( allocated ( error )) return end if end subroutine add_project !> Add a project and its dependencies to the dependency tree recursive subroutine add_project_dependencies ( self , package , root , main , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Project configuration to add type ( package_config_t ), intent ( in ) :: package !> Current project root directory character ( len =* ), intent ( in ) :: root !> Is the main project logical , intent ( in ) :: main !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii if ( allocated ( package % dependency )) then call self % add ( package % dependency , error ) if ( allocated ( error )) return end if if ( main ) then if ( allocated ( package % dev_dependency )) then call self % add ( package % dev_dependency , error ) if ( allocated ( error )) return end if if ( allocated ( package % executable )) then do ii = 1 , size ( package % executable ) if ( allocated ( package % executable ( ii )% dependency )) then call self % add ( package % executable ( ii )% dependency , error ) if ( allocated ( error )) exit end if end do if ( allocated ( error )) return end if if ( allocated ( package % example )) then do ii = 1 , size ( package % example ) if ( allocated ( package % example ( ii )% dependency )) then call self % add ( package % example ( ii )% dependency , error ) if ( allocated ( error )) exit end if end do if ( allocated ( error )) return end if if ( allocated ( package % test )) then do ii = 1 , size ( package % test ) if ( allocated ( package % test ( ii )% dependency )) then call self % add ( package % test ( ii )% dependency , error ) if ( allocated ( error )) exit end if end do if ( allocated ( error )) return end if end if end subroutine add_project_dependencies !> Add a list of dependencies to the dependency tree subroutine add_dependencies ( self , dependency , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Dependency configuration to add type ( dependency_config_t ), intent ( in ) :: dependency (:) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii , ndep ndep = size ( self % dep ) if ( ndep < size ( dependency ) + self % ndep ) then call resize ( self % dep , ndep + ndep / 2 + size ( dependency )) end if do ii = 1 , size ( dependency ) call self % add ( dependency ( ii ), error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end subroutine add_dependencies !> Add a single dependency to the dependency tree pure subroutine add_dependency ( self , dependency , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Dependency configuration to add type ( dependency_config_t ), intent ( in ) :: dependency !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: id id = self % find ( dependency ) if ( id == 0 ) then self % ndep = self % ndep + 1 call new_dependency_node ( self % dep ( self % ndep ), dependency ) end if end subroutine add_dependency !> Update dependency tree subroutine update_dependency ( self , name , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Name of the dependency to update character ( len =* ), intent ( in ) :: name !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: id type ( package_config_t ) :: package character ( len = :), allocatable :: manifest , proj_dir , revision , root id = self % find ( name ) root = \".\" if ( id <= 0 ) then call fatal_error ( error , \"Cannot update dependency '\" // name // \"'\" ) return end if associate ( dep => self % dep ( id )) if ( allocated ( dep % git ) . and . dep % update ) then if ( self % verbosity > 1 ) then write ( self % unit , out_fmt ) \"Update:\" , dep % name end if proj_dir = join_path ( self % dep_dir , dep % name ) call dep % git % checkout ( proj_dir , error ) if ( allocated ( error )) return ! Unset dependency and remove updatable attribute dep % done = . false . dep % update = . false . ! Now decent into the dependency tree, level for level do while (. not . self % finished ()) call self % resolve ( root , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end if end associate end subroutine update_dependency !> Resolve all dependencies in the tree subroutine resolve_dependencies ( self , root , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Current installation prefix character ( len =* ), intent ( in ) :: root !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii do ii = 1 , self % ndep call self % resolve ( self % dep ( ii ), root , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return end subroutine resolve_dependencies !> Resolve a single dependency node subroutine resolve_dependency ( self , dependency , root , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Dependency configuration to add type ( dependency_node_t ), intent ( inout ) :: dependency !> Current installation prefix character ( len =* ), intent ( in ) :: root !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( package_config_t ) :: package character ( len = :), allocatable :: manifest , proj_dir , revision logical :: fetch if ( dependency % done ) return fetch = . false . if ( allocated ( dependency % proj_dir )) then proj_dir = dependency % proj_dir else if ( allocated ( dependency % path )) then proj_dir = join_path ( root , dependency % path ) else if ( allocated ( dependency % git )) then proj_dir = join_path ( self % dep_dir , dependency % name ) fetch = . not . exists ( proj_dir ) if ( fetch ) then call dependency % git % checkout ( proj_dir , error ) if ( allocated ( error )) return end if end if end if if ( allocated ( dependency % git )) then call git_revision ( proj_dir , revision , error ) if ( allocated ( error )) return end if manifest = join_path ( proj_dir , \"fpm.toml\" ) call get_package_data ( package , manifest , error ) if ( allocated ( error )) return call dependency % register ( package , proj_dir , fetch , revision , error ) if ( allocated ( error )) return if ( self % verbosity > 1 ) then write ( self % unit , out_fmt ) & \"Dep:\" , dependency % name , \"version\" , char ( dependency % version ), & \"at\" , dependency % proj_dir end if call self % add ( package , proj_dir , . false ., error ) if ( allocated ( error )) return end subroutine resolve_dependency !> Find a dependency in the dependency tree pure function find_dependency ( self , dependency ) result ( pos ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( in ) :: self !> Dependency configuration to add class ( dependency_config_t ), intent ( in ) :: dependency !> Index of the dependency integer :: pos integer :: ii pos = self % find ( dependency % name ) end function find_dependency !> Find a dependency in the dependency tree pure function find_name ( self , name ) result ( pos ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( in ) :: self !> Dependency configuration to add character ( len =* ), intent ( in ) :: name !> Index of the dependency integer :: pos integer :: ii pos = 0 do ii = 1 , self % ndep if ( name == self % dep ( ii )% name ) then pos = ii exit end if end do end function find_name !> Check if we are done with the dependency resolution pure function finished ( self ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( in ) :: self !> All dependencies are updated logical :: finished integer :: ii finished = all ( self % dep (: self % ndep )% done ) end function finished !> Update dependency from project manifest subroutine register ( self , package , root , fetch , revision , error ) !> Instance of the dependency node class ( dependency_node_t ), intent ( inout ) :: self !> Package configuration data type ( package_config_t ), intent ( in ) :: package !> Project has been fetched logical , intent ( in ) :: fetch !> Root directory of the project character ( len =* ), intent ( in ) :: root !> Git revision of the project character ( len =* ), intent ( in ), optional :: revision !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: url logical :: update update = . false . if ( self % name /= package % name ) then call fatal_error ( error , \"Dependency name '\" // package % name // & & \"' found, but expected '\" // self % name // \"' instead\" ) end if self % version = package % version self % proj_dir = root if ( allocated ( self % git ). and . present ( revision )) then self % revision = revision if (. not . fetch ) then ! git object is HEAD always allows an update update = . not . allocated ( self % git % object ) if (. not . update ) then ! allow update in case the revision does not match the requested object update = revision /= self % git % object end if end if end if self % update = update self % done = . true . end subroutine register !> Read dependency tree from file subroutine load_from_file ( self , file , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> File name character ( len =* ), intent ( in ) :: file !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: unit logical :: exist inquire ( file = file , exist = exist ) if (. not . exist ) return open ( file = file , newunit = unit ) call self % load ( unit , error ) close ( unit ) end subroutine load_from_file !> Read dependency tree from file subroutine load_from_unit ( self , unit , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> File name integer , intent ( in ) :: unit !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error type ( toml_table ), allocatable :: table call toml_parse ( table , unit , parse_error ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if call self % load ( table , error ) if ( allocated ( error )) return end subroutine load_from_unit !> Read dependency tree from TOML data structure subroutine load_from_toml ( self , table , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ndep , ii logical :: unix character ( len = :), allocatable :: version , url , obj , rev , proj_dir type ( toml_key ), allocatable :: list (:) type ( toml_table ), pointer :: ptr type ( dependency_config_t ) :: dep call table % get_keys ( list ) ndep = size ( self % dep ) if ( ndep < size ( list ) + self % ndep ) then call resize ( self % dep , ndep + ndep / 2 + size ( list )) end if unix = get_os_type () /= OS_WINDOWS do ii = 1 , size ( list ) call get_value ( table , list ( ii )% key , ptr ) call get_value ( ptr , \"version\" , version ) call get_value ( ptr , \"proj-dir\" , proj_dir ) call get_value ( ptr , \"git\" , url ) call get_value ( ptr , \"obj\" , obj ) call get_value ( ptr , \"rev\" , rev ) if (. not . allocated ( proj_dir )) cycle self % ndep = self % ndep + 1 associate ( dep => self % dep ( self % ndep )) dep % name = list ( ii )% key if ( unix ) then dep % proj_dir = proj_dir else dep % proj_dir = windows_path ( proj_dir ) end if dep % done = . false . if ( allocated ( version )) then if (. not . allocated ( dep % version )) allocate ( dep % version ) call new_version ( dep % version , version , error ) if ( allocated ( error )) exit end if if ( allocated ( version )) then call new_version ( dep % version , version , error ) if ( allocated ( error )) exit end if if ( allocated ( url )) then if ( allocated ( obj )) then dep % git = git_target_revision ( url , obj ) else dep % git = git_target_default ( url ) end if if ( allocated ( rev )) then dep % revision = rev end if else dep % path = proj_dir end if end associate end do if ( allocated ( error )) return self % ndep = size ( list ) end subroutine load_from_toml !> Write dependency tree to file subroutine dump_to_file ( self , file , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> File name character ( len =* ), intent ( in ) :: file !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: unit open ( file = file , newunit = unit ) call self % dump ( unit , error ) close ( unit ) if ( allocated ( error )) return end subroutine dump_to_file !> Write dependency tree to file subroutine dump_to_unit ( self , unit , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Formatted unit integer , intent ( in ) :: unit !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ) :: table type ( toml_serializer ) :: ser table = toml_table () ser = toml_serializer ( unit ) call self % dump ( table , error ) call table % accept ( ser ) end subroutine dump_to_unit !> Write dependency tree to TOML datastructure subroutine dump_to_toml ( self , table , error ) !> Instance of the dependency tree class ( dependency_tree_t ), intent ( inout ) :: self !> Data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: ii type ( toml_table ), pointer :: ptr character ( len = :), allocatable :: proj_dir do ii = 1 , self % ndep associate ( dep => self % dep ( ii )) call add_table ( table , dep % name , ptr ) if (. not . associated ( ptr )) then call fatal_error ( error , \"Cannot create entry for \" // dep % name ) exit end if if ( allocated ( dep % version )) then call set_value ( ptr , \"version\" , char ( dep % version )) end if proj_dir = canon_path ( dep % proj_dir ) call set_value ( ptr , \"proj-dir\" , proj_dir ) if ( allocated ( dep % git )) then call set_value ( ptr , \"git\" , dep % git % url ) if ( allocated ( dep % git % object )) then call set_value ( ptr , \"obj\" , dep % git % object ) end if if ( allocated ( dep % revision )) then call set_value ( ptr , \"rev\" , dep % revision ) end if end if end associate end do if ( allocated ( error )) return end subroutine dump_to_toml !> Reallocate a list of dependencies pure subroutine resize_dependency_node ( var , n ) !> Instance of the array to be resized type ( dependency_node_t ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n type ( dependency_node_t ), allocatable :: tmp (:) integer :: this_size , new_size integer , parameter :: initial_size = 16 if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_dependency_node end module fpm_dependency","tags":"","loc":"sourcefile/dependency.f90.html"},{"title":"install.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_cmd_install Source Code install.f90 Source Code module fpm_cmd_install use , intrinsic :: iso_fortran_env , only : output_unit use fpm , only : build_model use fpm_backend , only : build_package use fpm_command_line , only : fpm_install_settings use fpm_error , only : error_t , fatal_error use fpm_filesystem , only : join_path , list_files use fpm_installer , only : installer_t , new_installer use fpm_manifest , only : package_config_t , get_package_data use fpm_model , only : fpm_model_t , build_target_t , FPM_TARGET_EXECUTABLE , & FPM_SCOPE_APP use fpm_strings , only : string_t , resize implicit none private public :: cmd_install contains !> Entry point for the fpm-install subcommand subroutine cmd_install ( settings ) !> Representation of the command line settings type ( fpm_install_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( error_t ), allocatable :: error type ( fpm_model_t ) :: model type ( installer_t ) :: installer character ( len = :), allocatable :: lib , exe , dir logical :: installable call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) call handle_error ( error ) call build_model ( model , settings % fpm_build_settings , package , error ) call handle_error ( error ) installable = ( allocated ( package % library ) . and . package % install % library ) & . or . allocated ( package % executable ) if (. not . installable ) then call fatal_error ( error , \"Project does not contain any installable targets\" ) call handle_error ( error ) end if if ( settings % list ) then call install_info ( output_unit , package , model ) return end if if (. not . settings % no_rebuild ) then call build_package ( model ) end if call new_installer ( installer , prefix = settings % prefix , & bindir = settings % bindir , libdir = settings % libdir , & includedir = settings % includedir , & verbosity = merge ( 2 , 1 , settings % verbose )) if ( allocated ( package % library ) . and . package % install % library ) then dir = join_path ( model % output_directory , model % package_name ) lib = \"lib\" // model % package_name // \".a\" call installer % install_library ( join_path ( dir , lib ), error ) call handle_error ( error ) call install_module_files ( installer , dir , error ) call handle_error ( error ) end if if ( allocated ( package % executable )) then call install_executables ( installer , model , error ) call handle_error ( error ) end if end subroutine cmd_install subroutine install_info ( unit , package , model ) integer , intent ( in ) :: unit type ( package_config_t ), intent ( in ) :: package type ( fpm_model_t ), intent ( in ) :: model integer :: ii , ntargets character ( len = :), allocatable :: lib type ( string_t ), allocatable :: install_target (:) call resize ( install_target ) ntargets = 0 if ( allocated ( package % library ) . and . package % install % library ) then ntargets = ntargets + 1 lib = join_path ( model % output_directory , model % package_name , & \"lib\" // model % package_name // \".a\" ) install_target ( ntargets )% s = lib end if do ii = 1 , size ( model % targets ) if ( is_executable_target ( model % targets ( ii )% ptr )) then if ( ntargets >= size ( install_target )) call resize ( install_target ) ntargets = ntargets + 1 install_target ( ntargets )% s = model % targets ( ii )% ptr % output_file end if end do write ( unit , '(\"#\", *(1x, g0))' ) & \"total number of installable targets:\" , ntargets do ii = 1 , ntargets write ( unit , '(\"-\", *(1x, g0))' ) install_target ( ii )% s end do end subroutine install_info subroutine install_module_files ( installer , dir , error ) type ( installer_t ), intent ( inout ) :: installer character ( len =* ), intent ( in ) :: dir type ( error_t ), allocatable , intent ( out ) :: error type ( string_t ), allocatable :: modules (:) integer :: ii call list_files ( dir , modules , recurse = . false .) do ii = 1 , size ( modules ) if ( is_module_file ( modules ( ii )% s )) then call installer % install_header ( modules ( ii )% s , error ) if ( allocated ( error )) exit end if end do if ( allocated ( error )) return end subroutine install_module_files subroutine install_executables ( installer , model , error ) type ( installer_t ), intent ( inout ) :: installer type ( fpm_model_t ), intent ( in ) :: model type ( error_t ), allocatable , intent ( out ) :: error integer :: ii do ii = 1 , size ( model % targets ) if ( is_executable_target ( model % targets ( ii )% ptr )) then call installer % install_executable ( model % targets ( ii )% ptr % output_file , error ) if ( allocated ( error )) exit end if end do if ( allocated ( error )) return end subroutine install_executables elemental function is_executable_target ( target_ptr ) result ( is_exe ) type ( build_target_t ), intent ( in ) :: target_ptr logical :: is_exe is_exe = target_ptr % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( target_ptr % dependencies ) if ( is_exe ) then is_exe = target_ptr % dependencies ( 1 )% ptr % source % unit_scope == FPM_SCOPE_APP end if end function is_executable_target elemental function is_module_file ( name ) result ( is_mod ) character ( len =* ), intent ( in ) :: name logical :: is_mod integer :: ll ll = len ( name ) is_mod = name ( max ( 1 , ll - 3 ): ll ) == \".mod\" end function is_module_file subroutine handle_error ( error ) type ( error_t ), intent ( in ), optional :: error if ( present ( error )) then print '(\"[Error]\", 1x, a)' , error % message error stop 1 end if end subroutine handle_error end module fpm_cmd_install","tags":"","loc":"sourcefile/install.f90.html"},{"title":"new.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_cmd_new Source Code new.f90 Source Code module fpm_cmd_new use fpm_command_line , only : fpm_new_settings use fpm_environment , only : run , OS_LINUX , OS_MACOS , OS_WINDOWS use fpm_filesystem , only : join_path , exists , basename , mkdir , is_dir use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none private public :: cmd_new contains subroutine cmd_new ( settings ) type ( fpm_new_settings ), intent ( in ) :: settings character ( len = :), allocatable :: bname ! baeename of NAME character ( len = :), allocatable :: message (:) character ( len = :), allocatable :: littlefile (:) character ( len = 8 ) :: date call date_and_time ( DATE = date ) if ( exists ( settings % name ) . and . . not . settings % backfill ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists.' write ( stderr , '(*(g0,1x))' )& & '        perhaps you wanted to add --backfill ?' return elseif ( is_dir ( settings % name ) . and . settings % backfill ) then write ( * , '(*(g0))' ) 'backfilling ' , settings % name elseif ( exists ( settings % name ) ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists and is not a directory.' return else ! make new directory call mkdir ( settings % name ) endif ! change to new directory as a test. System dependent potentially call run ( 'cd ' // settings % name ) ! NOTE: need some system routines to handle filenames like \".\" ! like realpath() or getcwd(). bname = basename ( settings % name ) ! create NAME/.gitignore file call warnwrite ( join_path ( settings % name , '.gitignore' ), [ 'build/*' ]) littlefile = [ character ( len = 80 ) :: '# ' // bname , 'My cool new project!' ] ! create NAME/README.md call warnwrite ( join_path ( settings % name , 'README.md' ), littlefile ) ! start building NAME/fpm.toml message = [ character ( len = 80 ) :: & & 'name = \"' // bname // '\"                     ' , & & 'version = \"0.1.0\"                        ' , & & 'license = \"license\"                      ' , & & 'author = \"Jane Doe\"                      ' , & & 'maintainer = \"jane.doe@example.com\"      ' , & & 'copyright = \"' // date ( 1 : 4 ) // ' Jane Doe\"   ' , & & '                                         ' , & & '' ] if ( settings % with_lib ) then call mkdir ( join_path ( settings % name , 'src' ) ) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[library]                            ' , & & 'source-dir=\"src\"                     ' , & & '' ] ! create placeholder module src/bname.f90 littlefile = [ character ( len = 80 ) :: & & 'module ' // bname , & & '  implicit none' , & & '  private' , & & '' , & & '  public :: say_hello' , & & 'contains' , & & '  subroutine say_hello' , & & '    print *, \"Hello, ' // bname // '!\"' , & & '  end subroutine say_hello' , & & 'end module ' // bname ] ! create NAME/src/NAME.f90 call warnwrite ( join_path ( settings % name , 'src' , bname // '.f90' ),& & littlefile ) endif if ( settings % with_test ) then ! create NAME/test or stop call mkdir ( join_path ( settings % name , 'test' )) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[[test]]                             ' , & & 'name=\"runTests\"                      ' , & & 'source-dir=\"test\"                    ' , & & 'main=\"main.f90\"                      ' , & & '' ] littlefile = [ character ( len = 80 ) :: & & 'program main' , & & 'implicit none' , & & '' , & & 'print *, \"Put some tests in here!\"' , & & 'end program main' ] ! create NAME/test/main.f90 call warnwrite ( join_path ( settings % name , 'test/main.f90' ), littlefile ) endif if ( settings % with_executable ) then ! create next section of fpm.toml call mkdir ( join_path ( settings % name , 'app' )) ! create NAME/app or stop message = [ character ( len = 80 ) :: message , & & '[[executable]]                       ' , & & 'name=\"' // bname // '\"                   ' , & & 'source-dir=\"app\"                     ' , & & 'main=\"main.f90\"                      ' , & & '' ] if ( exists ( bname // '/src/' )) then littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  use ' // bname // ', only: say_hello' , & & '  implicit none' , & & '' , & & '  call say_hello()' , & & 'end program main' ] else littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  implicit none' , & & '' , & & '  print *, \"hello from project ' // bname // '\"' , & & 'end program main' ] endif call warnwrite ( join_path ( settings % name , 'app/main.f90' ), littlefile ) endif ! now that built it write NAME/fpm.toml call warnwrite ( join_path ( settings % name , 'fpm.toml' ), message ) ! assumes git(1) is installed and in path call run ( 'git init ' // settings % name ) contains subroutine warnwrite ( fname , data ) character ( len =* ), intent ( in ) :: fname character ( len =* ), intent ( in ) :: data (:) if (. not . exists ( fname )) then call filewrite ( fname , data ) else write ( stderr , '(*(g0,1x))' ) 'INFO:   ' , fname ,& & 'already exists. Not overwriting' endif end subroutine warnwrite subroutine filewrite ( filename , filedata ) ! procedure to write filedata to file filename use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ) :: filedata (:) integer :: lun , i , ios character ( len = 256 ) :: message message = ' ' ios = 0 if ( filename . ne . ' ' ) then open ( file = filename , & & newunit = lun , & & form = 'formatted' , & ! FORM    = FORMATTED | UNFORMATTED & access = 'sequential' , & ! ACCESS  = SEQUENTIAL| DIRECT | STREAM & action = 'write' , & ! ACTION  = READ|WRITE| READWRITE & position = 'rewind' , & ! POSITION= ASIS      | REWIND | APPEND & status = 'new' , & ! STATUS  = NEW| REPLACE| OLD| SCRATCH| UNKNOWN & iostat = ios , & & iomsg = message ) else lun = stdout ios = 0 endif if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 1 endif ! write file do i = 1 , size ( filedata ) write ( lun , '(a)' , iostat = ios , iomsg = message ) trim ( filedata ( i )) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 4 endif enddo ! close file close ( unit = lun , iostat = ios , iomsg = message ) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' ) '*filewrite* error:' , trim ( message ) error stop 2 endif end subroutine filewrite end subroutine cmd_new end module fpm_cmd_new","tags":"","loc":"sourcefile/new.f90.html"},{"title":"update.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_cmd_update Source Code update.f90 Source Code module fpm_cmd_update use fpm_command_line , only : fpm_update_settings use fpm_dependency , only : dependency_tree_t , new_dependency_tree use fpm_error , only : error_t use fpm_filesystem , only : exists , mkdir , join_path , delete_file use fpm_manifest , only : package_config_t , get_package_data implicit none private public :: cmd_update contains !> Entry point for the update subcommand subroutine cmd_update ( settings ) !> Representation of the command line arguments type ( fpm_update_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( dependency_tree_t ) :: deps type ( error_t ), allocatable :: error integer :: ii character ( len = :), allocatable :: cache call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) call handle_error ( error ) if (. not . exists ( \"build\" )) then call mkdir ( \"build\" ) end if cache = join_path ( \"build\" , \"cache.toml\" ) if ( settings % clean ) then call delete_file ( cache ) end if call new_dependency_tree ( deps , cache = cache , & verbosity = merge ( 2 , 1 , settings % verbose )) call deps % add ( package , error ) call handle_error ( error ) if ( settings % fetch_only ) return if ( size ( settings % name ) == 0 ) then do ii = 1 , deps % ndep call deps % update ( deps % dep ( ii )% name , error ) call handle_error ( error ) end do else do ii = 1 , size ( settings % name ) call deps % update ( trim ( settings % name ( ii )), error ) call handle_error ( error ) end do end if end subroutine cmd_update !> Error handling for this command subroutine handle_error ( error ) !> Potential error type ( error_t ), intent ( in ), optional :: error if ( present ( error )) then print '(a)' , error % message error stop 1 end if end subroutine handle_error end module fpm_cmd_update","tags":"","loc":"sourcefile/update.f90.html"},{"title":"install.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_install Source Code install.f90 Source Code !> Implementation of the installation configuration. !> !> An install table can currently have the following fields !> !>```toml !>library = bool !>``` module fpm_manifest_install use fpm_error , only : error_t , fatal_error , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: install_config_t , new_install_config !> Configuration data for installation type :: install_config_t !> Install library with this project logical :: library contains !> Print information on this instance procedure :: info end type install_config_t contains !> Create a new installation configuration from a TOML data structure subroutine new_install_config ( self , table , error ) !> Instance of the install configuration type ( install_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"library\" , self % library , . false .) end subroutine new_install_config !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) integer :: ikey call table % get_keys ( list ) if ( size ( list ) < 1 ) return do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in install table\" ) exit case ( \"library\" ) continue end select end do if ( allocated ( error )) return end subroutine check !> Write information on install configuration instance subroutine info ( self , unit , verbosity ) !> Instance of the build configuration class ( install_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Install configuration\" write ( unit , fmt ) \" - library install\" , & & trim ( merge ( \"enabled \" , \"disabled\" , self % library )) end subroutine info end module fpm_manifest_install","tags":"","loc":"sourcefile/install.f90~2.html"},{"title":"example.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_example Source Code example.f90 Source Code !> Implementation of the meta data for an example. !> !> The example data structure is effectively a decorated version of an executable !> and shares most of its properties, except for the defaults and can be !> handled under most circumstances just like any other executable. !> !> A example table can currently have the following fields !> !>```toml !>[[ example ]] !>name = \"string\" !>source-dir = \"path\" !>main = \"file\" !>link = [\"lib\"] !>[example.dependencies] !>``` module fpm_manifest_example use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_manifest_executable , only : executable_config_t use fpm_error , only : error_t , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: example_config_t , new_example !> Configuation meta data for an example type , extends ( executable_config_t ) :: example_config_t contains !> Print information on this instance procedure :: info end type example_config_t contains !> Construct a new example configuration from a TOML data structure subroutine new_example ( self , table , error ) !> Instance of the example configuration type ( example_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve example name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"example\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_example !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Example section does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in example entry\" ) exit case ( \"name\" ) name_present = . true . case ( \"source-dir\" , \"main\" , \"dependencies\" , \"link\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Example name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the example configuration class ( example_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Example target\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % source_dir )) then if ( self % source_dir /= \"example\" . or . pr > 2 ) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if end if if ( allocated ( self % main )) then if ( self % main /= \"main.f90\" . or . pr > 2 ) then write ( unit , fmt ) \"- example source\" , self % main end if end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_example","tags":"","loc":"sourcefile/example.f90.html"},{"title":"package.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_package Source Code package.f90 Source Code !> Define the package data containing the meta data from the configuration file. !> !> The package data defines a Fortran type corresponding to the respective !> TOML document, after creating it from a package file no more interaction !> with the TOML document is required. !> !> Every configuration type provides it custom constructor (prefixed with `new_`) !> and knows how to deserialize itself from a TOML document. !> To ensure we find no untracked content in the package file all keywords are !> checked and possible entries have to be explicitly allowed in the `check` !> function. !> If entries are mutally exclusive or interdependent inside the current table !> the `check` function is required to enforce this schema on the data structure. !> !> The package file root allows the following keywords !> !>```toml !>name = \"string\" !>version = \"string\" !>license = \"string\" !>author = \"string\" !>maintainer = \"string\" !>copyright = \"string\" !>[library] !>[dependencies] !>[dev-dependencies] !>[build] !>[install] !>[[ executable ]] !>[[ example ]] !>[[ test ]] !>``` module fpm_manifest_package use fpm_manifest_build , only : build_config_t , new_build_config use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_manifest_example , only : example_config_t , new_example use fpm_manifest_executable , only : executable_config_t , new_executable use fpm_manifest_library , only : library_config_t , new_library use fpm_manifest_install , only : install_config_t , new_install_config use fpm_manifest_test , only : test_config_t , new_test use fpm_error , only : error_t , fatal_error , syntax_error use fpm_toml , only : toml_table , toml_array , toml_key , toml_stat , get_value , & & len use fpm_versioning , only : version_t , new_version implicit none private public :: package_config_t , new_package interface unique_programs module procedure :: unique_programs1 module procedure :: unique_programs2 end interface unique_programs !> Package meta data type :: package_config_t !> Name of the package character ( len = :), allocatable :: name !> Package version type ( version_t ) :: version !> Build configuration data type ( build_config_t ) :: build !> Installation configuration data type ( install_config_t ) :: install !> Library meta data type ( library_config_t ), allocatable :: library !> Executable meta data type ( executable_config_t ), allocatable :: executable (:) !> Dependency meta data type ( dependency_config_t ), allocatable :: dependency (:) !> Development dependency meta data type ( dependency_config_t ), allocatable :: dev_dependency (:) !> Example meta data type ( example_config_t ), allocatable :: example (:) !> Test meta data type ( test_config_t ), allocatable :: test (:) contains !> Print information on this instance procedure :: info end type package_config_t contains !> Construct a new package configuration from a TOML data structure subroutine new_package ( self , table , error ) !> Instance of the package configuration type ( package_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error ! Backspace (8), tabulator (9), newline (10), formfeed (12) and carriage ! return (13) are invalid in package names character ( len =* ), parameter :: invalid_chars = & achar ( 8 ) // achar ( 9 ) // achar ( 10 ) // achar ( 12 ) // achar ( 13 ) type ( toml_table ), pointer :: child , node type ( toml_array ), pointer :: children character ( len = :), allocatable :: version integer :: ii , nn , stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve package name\" ) return end if if ( len ( self % name ) <= 0 ) then call syntax_error ( error , \"Package name must be a non-empty string\" ) return end if ii = scan ( self % name , invalid_chars ) if ( ii > 0 ) then call syntax_error ( error , \"Package name contains invalid characters\" ) return end if call get_value ( table , \"build\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for build entry, must be a table\" ) return end if call new_build_config ( self % build , child , error ) if ( allocated ( error )) return call get_value ( table , \"install\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for install entry, must be a table\" ) return end if call new_install_config ( self % install , child , error ) if ( allocated ( error )) return call get_value ( table , \"version\" , version , \"0\" ) call new_version ( self % version , version , error ) if ( allocated ( error )) return call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"dev-dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dev_dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"library\" , child , requested = . false .) if ( associated ( child )) then allocate ( self % library ) call new_library ( self % library , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"executable\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % executable ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve executable from array entry\" ) exit end if call new_executable ( self % executable ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % executable , error ) if ( allocated ( error )) return end if call get_value ( table , \"example\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % example ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve example from array entry\" ) exit end if call new_example ( self % example ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % example , error ) if ( allocated ( error )) return if ( allocated ( self % executable )) then call unique_programs ( self % executable , self % example , error ) if ( allocated ( error )) return end if end if call get_value ( table , \"test\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % test ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve test from array entry\" ) exit end if call new_test ( self % test ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % test , error ) if ( allocated ( error )) return end if end subroutine new_package !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Package file is empty\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in package file\" ) exit case ( \"name\" ) name_present = . true . case ( \"version\" , \"license\" , \"author\" , \"maintainer\" , \"copyright\" , & & \"description\" , \"keywords\" , \"categories\" , \"homepage\" , \"build\" , & & \"dependencies\" , \"dev-dependencies\" , \"test\" , \"executable\" , & & \"example\" , \"library\" , \"install\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Package name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the package configuration class ( package_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Package\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if call self % build % info ( unit , pr - 1 ) call self % install % info ( unit , pr - 1 ) if ( allocated ( self % library )) then write ( unit , fmt ) \"- target\" , \"archive\" call self % library % info ( unit , pr - 1 ) end if if ( allocated ( self % executable )) then if ( size ( self % executable ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- executables\" , size ( self % executable ) end if do ii = 1 , size ( self % executable ) call self % executable ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % example )) then if ( size ( self % example ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- examples\" , size ( self % example ) end if do ii = 1 , size ( self % example ) call self % example ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % test )) then if ( size ( self % test ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- tests\" , size ( self % test ) end if do ii = 1 , size ( self % test ) call self % test ( ii )% info ( unit , pr - 1 ) end do end if if ( allocated ( self % dev_dependency )) then if ( size ( self % dev_dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- development deps.\" , size ( self % dev_dependency ) end if do ii = 1 , size ( self % dev_dependency ) call self % dev_dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info !> Check whether or not the names in a set of executables are unique subroutine unique_programs1 ( executable , error ) !> Array of executables class ( executable_config_t ), intent ( in ) :: executable (:) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j do i = 1 , size ( executable ) do j = 1 , i - 1 if ( executable ( i )% name == executable ( j )% name ) then call fatal_error ( error , \"The program named '\" // & executable ( j )% name // \"' is duplicated. \" // & \"Unique program names are required.\" ) exit end if end do end do if ( allocated ( error )) return end subroutine unique_programs1 !> Check whether or not the names in a set of executables are unique subroutine unique_programs2 ( executable_i , executable_j , error ) !> Array of executables class ( executable_config_t ), intent ( in ) :: executable_i (:) !> Array of executables class ( executable_config_t ), intent ( in ) :: executable_j (:) !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j do i = 1 , size ( executable_i ) do j = 1 , size ( executable_j ) if ( executable_i ( i )% name == executable_j ( j )% name ) then call fatal_error ( error , \"The program named '\" // & executable_j ( j )% name // \"' is duplicated. \" // & \"Unique program names are required.\" ) exit end if end do end do if ( allocated ( error )) return end subroutine unique_programs2 end module fpm_manifest_package","tags":"","loc":"sourcefile/package.f90.html"},{"title":"library.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_library Source Code library.f90 Source Code !> Implementation of the meta data for libraries. !> !> A library table can currently have the following fields !> !>```toml !>[library] !>source-dir = \"path\" !>build-script = \"file\" !>``` module fpm_manifest_library use fpm_error , only : error_t , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: library_config_t , new_library !> Configuration meta data for a library type :: library_config_t !> Source path prefix character ( len = :), allocatable :: source_dir !> Alternative build script to be invoked character ( len = :), allocatable :: build_script contains !> Print information on this instance procedure :: info end type library_config_t contains !> Construct a new library configuration from a TOML data structure subroutine new_library ( self , table , error ) !> Instance of the library configuration type ( library_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"source-dir\" , self % source_dir , \"src\" ) call get_value ( table , \"build-script\" , self % build_script ) end subroutine new_library !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) integer :: ikey call table % get_keys ( list ) ! table can be empty if ( size ( list ) < 1 ) return do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in library\" ) exit case ( \"source-dir\" , \"build-script\" ) continue end select end do end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the library configuration class ( library_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Library target\" if ( allocated ( self % source_dir )) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if if ( allocated ( self % build_script )) then write ( unit , fmt ) \"- custom build\" , self % build_script end if end subroutine info end module fpm_manifest_library","tags":"","loc":"sourcefile/library.f90.html"},{"title":"test.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_test Source Code test.f90 Source Code !> Implementation of the meta data for a test. !> !> The test data structure is effectively a decorated version of an executable !> and shares most of its properties, except for the defaults and can be !> handled under most circumstances just like any other executable. !> !> A test table can currently have the following fields !> !>```toml !>[[ test ]] !>name = \"string\" !>source-dir = \"path\" !>main = \"file\" !>link = [\"lib\"] !>[test.dependencies] !>``` module fpm_manifest_test use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_manifest_executable , only : executable_config_t use fpm_error , only : error_t , syntax_error use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: test_config_t , new_test !> Configuation meta data for an test type , extends ( executable_config_t ) :: test_config_t contains !> Print information on this instance procedure :: info end type test_config_t contains !> Construct a new test configuration from a TOML data structure subroutine new_test ( self , table , error ) !> Instance of the test configuration type ( test_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve test name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"test\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_test !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Test section does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in test entry\" ) exit case ( \"name\" ) name_present = . true . case ( \"source-dir\" , \"main\" , \"dependencies\" , \"link\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Test name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the test configuration class ( test_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Test target\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % source_dir )) then if ( self % source_dir /= \"test\" . or . pr > 2 ) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if end if if ( allocated ( self % main )) then if ( self % main /= \"main.f90\" . or . pr > 2 ) then write ( unit , fmt ) \"- test source\" , self % main end if end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_test","tags":"","loc":"sourcefile/test.f90.html"},{"title":"executable.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_executable Source Code executable.f90 Source Code !> Implementation of the meta data for an executables. !> !> An executable table can currently have the following fields !> !>```toml !>[[ executable ]] !>name = \"string\" !>source-dir = \"path\" !>main = \"file\" !>link = [\"lib\"] !>[executable.dependencies] !>``` module fpm_manifest_executable use fpm_manifest_dependency , only : dependency_config_t , new_dependencies use fpm_error , only : error_t , syntax_error use fpm_strings , only : string_t use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: executable_config_t , new_executable !> Configuation meta data for an executable type :: executable_config_t !> Name of the resulting executable character ( len = :), allocatable :: name !> Source directory for collecting the executable character ( len = :), allocatable :: source_dir !> Name of the source file declaring the main program character ( len = :), allocatable :: main !> Dependency meta data for this executable type ( dependency_config_t ), allocatable :: dependency (:) !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type executable_config_t contains !> Construct a new executable configuration from a TOML data structure subroutine new_executable ( self , table , error ) !> Instance of the executable configuration type ( executable_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve executable name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"app\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_executable !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) logical :: name_present integer :: ikey name_present = . false . call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Executable section does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed as executable entry\" ) exit case ( \"name\" ) name_present = . true . case ( \"source-dir\" , \"main\" , \"dependencies\" , \"link\" ) continue end select end do if ( allocated ( error )) return if (. not . name_present ) then call syntax_error ( error , \"Executable name is not provided, please add a name entry\" ) end if end subroutine check !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the executable configuration class ( executable_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ii character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' , & & fmti = '(\"#\", 1x, a, t30, i0)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Executable target\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % source_dir )) then if ( self % source_dir /= \"app\" . or . pr > 2 ) then write ( unit , fmt ) \"- source directory\" , self % source_dir end if end if if ( allocated ( self % main )) then if ( self % main /= \"main.f90\" . or . pr > 2 ) then write ( unit , fmt ) \"- program source\" , self % main end if end if if ( allocated ( self % dependency )) then if ( size ( self % dependency ) > 1 . or . pr > 2 ) then write ( unit , fmti ) \"- dependencies\" , size ( self % dependency ) end if do ii = 1 , size ( self % dependency ) call self % dependency ( ii )% info ( unit , pr - 1 ) end do end if end subroutine info end module fpm_manifest_executable","tags":"","loc":"sourcefile/executable.f90.html"},{"title":"dependency.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_dependency Source Code dependency.f90 Source Code !> Implementation of the meta data for dependencies. !> !> A dependency table can currently have the following fields !> !>```toml !>[dependencies] !>\"dep1\" = { git = \"url\" } !>\"dep2\" = { git = \"url\", branch = \"name\" } !>\"dep3\" = { git = \"url\", tag = \"name\" } !>\"dep4\" = { git = \"url\", rev = \"sha1\" } !>\"dep0\" = { path = \"path\" } !>``` !> !> To reduce the amount of boilerplate code this module provides two constructors !> for dependency types, one basic for an actual dependency (inline) table !> and another to collect all dependency objects from a dependencies table, !> which is handling the allocation of the objects and is forwarding the !> individual dependency tables to their respective constructors. !> The usual entry point should be the constructor for the super table. !> !> This objects contains a target to retrieve required `fpm` projects to !> build the target declaring the dependency. !> Resolving a dependency will result in obtaining a new package configuration !> data for the respective project. module fpm_manifest_dependency use fpm_error , only : error_t , syntax_error use fpm_git , only : git_target_t , git_target_tag , git_target_branch , & & git_target_revision , git_target_default use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: dependency_config_t , new_dependency , new_dependencies !> Configuration meta data for a dependency type :: dependency_config_t !> Name of the dependency character ( len = :), allocatable :: name !> Local target character ( len = :), allocatable :: path !> Git descriptor type ( git_target_t ), allocatable :: git contains !> Print information on this instance procedure :: info end type dependency_config_t contains !> Construct a new dependency configuration from a TOML data structure subroutine new_dependency ( self , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: url , obj call check ( table , error ) if ( allocated ( error )) return call table % get_key ( self % name ) call get_value ( table , \"path\" , url ) if ( allocated ( url )) then call move_alloc ( url , self % path ) else call get_value ( table , \"git\" , url ) call get_value ( table , \"tag\" , obj ) if ( allocated ( obj )) then self % git = git_target_tag ( url , obj ) end if if (. not . allocated ( self % git )) then call get_value ( table , \"branch\" , obj ) if ( allocated ( obj )) then self % git = git_target_branch ( url , obj ) end if end if if (. not . allocated ( self % git )) then call get_value ( table , \"rev\" , obj ) if ( allocated ( obj )) then self % git = git_target_revision ( url , obj ) end if end if if (. not . allocated ( self % git )) then self % git = git_target_default ( url ) end if end if end subroutine new_dependency !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: name type ( toml_key ), allocatable :: list (:) logical :: url_present , git_target_present , has_path integer :: ikey has_path = . false . url_present = . false . git_target_present = . false . call table % get_key ( name ) call table % get_keys ( list ) if ( size ( list ) < 1 ) then call syntax_error ( error , \"Dependency \" // name // \" does not provide sufficient entries\" ) return end if do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in dependency \" // name ) exit case ( \"git\" , \"path\" ) if ( url_present ) then call syntax_error ( error , \"Dependency \" // name // \" cannot have both git and path entries\" ) exit end if url_present = . true . has_path = list ( ikey )% key == 'path' case ( \"branch\" , \"rev\" , \"tag\" ) if ( git_target_present ) then call syntax_error ( error , \"Dependency \" // name // \" can only have one of branch, rev or tag present\" ) exit end if git_target_present = . true . end select end do if ( allocated ( error )) return if (. not . url_present ) then call syntax_error ( error , \"Dependency \" // name // \" does not provide a method to actually retrieve itself\" ) return end if if ( has_path . and . git_target_present ) then call syntax_error ( error , \"Dependency \" // name // \" uses a local path, therefore no git identifiers are allowed\" ) end if end subroutine check !> Construct new dependency array from a TOML data structure subroutine new_dependencies ( deps , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), allocatable , intent ( out ) :: deps (:) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: node type ( toml_key ), allocatable :: list (:) integer :: idep , stat call table % get_keys ( list ) ! An empty table is okay if ( size ( list ) < 1 ) return allocate ( deps ( size ( list ))) do idep = 1 , size ( list ) call get_value ( table , list ( idep )% key , node , stat = stat ) if ( stat /= toml_stat % success ) then call syntax_error ( error , \"Dependency \" // list ( idep )% key // \" must be a table entry\" ) exit end if call new_dependency ( deps ( idep ), node , error ) if ( allocated ( error )) exit end do end subroutine new_dependencies !> Write information on instance subroutine info ( self , unit , verbosity ) !> Instance of the dependency configuration class ( dependency_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if write ( unit , fmt ) \"Dependency\" if ( allocated ( self % name )) then write ( unit , fmt ) \"- name\" , self % name end if if ( allocated ( self % git )) then write ( unit , fmt ) \"- kind\" , \"git\" call self % git % info ( unit , pr - 1 ) end if if ( allocated ( self % path )) then write ( unit , fmt ) \"- kind\" , \"local\" write ( unit , fmt ) \"- path\" , self % path end if end subroutine info end module fpm_manifest_dependency","tags":"","loc":"sourcefile/dependency.f90~2.html"},{"title":"build.f90 – Fortran-lang/fpm","text":"Contents Modules fpm_manifest_build Source Code build.f90 Source Code !> Implementation of the build configuration data. !> !> A build table can currently have the following fields !> !>```toml !>[build] !>auto-executables = bool !>auto-examples = bool !>auto-tests = bool !>link = [\"lib\"] !>``` module fpm_manifest_build use fpm_error , only : error_t , syntax_error , fatal_error use fpm_strings , only : string_t use fpm_toml , only : toml_table , toml_key , toml_stat , get_value implicit none private public :: build_config_t , new_build_config !> Configuration data for build type :: build_config_t !> Automatic discovery of executables logical :: auto_executables !> Automatic discovery of examples logical :: auto_examples !> Automatic discovery of tests logical :: auto_tests !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type build_config_t contains !> Construct a new build configuration from a TOML data structure subroutine new_build_config ( self , table , error ) !> Instance of the build configuration type ( build_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"auto-executables\" , self % auto_executables , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-executables' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-tests\" , self % auto_tests , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-tests' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-examples\" , self % auto_examples , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-examples' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_build_config !> Check local schema for allowed entries subroutine check ( table , error ) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_key ), allocatable :: list (:) integer :: ikey call table % get_keys ( list ) ! table can be empty if ( size ( list ) < 1 ) return do ikey = 1 , size ( list ) select case ( list ( ikey )% key ) case ( \"auto-executables\" , \"auto-examples\" , \"auto-tests\" , \"link\" ) continue case default call syntax_error ( error , \"Key \" // list ( ikey )% key // \" is not allowed in [build]\" ) exit end select end do end subroutine check !> Write information on build configuration instance subroutine info ( self , unit , verbosity ) !> Instance of the build configuration class ( build_config_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr , ilink character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Build configuration\" write ( unit , fmt ) \" - auto-discovery (apps) \" , merge ( \"enabled \" , \"disabled\" , self % auto_executables ) write ( unit , fmt ) \" - auto-discovery (examples) \" , merge ( \"enabled \" , \"disabled\" , self % auto_examples ) write ( unit , fmt ) \" - auto-discovery (tests) \" , merge ( \"enabled \" , \"disabled\" , self % auto_tests ) if ( allocated ( self % link )) then write ( unit , fmt ) \" - link against\" do ilink = 1 , size ( self % link ) write ( unit , fmt ) \"   - \" // self % link ( ilink )% s end do end if end subroutine info end module fpm_manifest_build","tags":"","loc":"sourcefile/build.f90.html"},{"title":"fpm_build_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_build_settings Contents Variables build_name compiler list show_model verbose Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: list = .false. logical, public :: show_model = .false. logical, public :: verbose = .true.","tags":"","loc":"type/fpm_build_settings.html"},{"title":"fpm_cmd_settings – Fortran-lang/fpm ","text":"type, public, abstract :: fpm_cmd_settings Contents Variables verbose Components Type Visibility Attributes Name Initial logical, public :: verbose = .true.","tags":"","loc":"type/fpm_cmd_settings.html"},{"title":"fpm_install_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_build_settings ) :: fpm_install_settings Contents Variables bindir build_name compiler includedir libdir list no_rebuild prefix show_model verbose Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bindir character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler character(len=:), public, allocatable :: includedir character(len=:), public, allocatable :: libdir logical, public :: list = .false. logical, public :: no_rebuild character(len=:), public, allocatable :: prefix logical, public :: show_model = .false. logical, public :: verbose = .true.","tags":"","loc":"type/fpm_install_settings.html"},{"title":"fpm_new_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_new_settings Contents Variables backfill name verbose with_executable with_lib with_test Components Type Visibility Attributes Name Initial logical, public :: backfill = .true. character(len=:), public, allocatable :: name logical, public :: verbose = .true. logical, public :: with_executable = .false. logical, public :: with_lib = .true. logical, public :: with_test = .false.","tags":"","loc":"type/fpm_new_settings.html"},{"title":"fpm_run_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_build_settings ) :: fpm_run_settings Contents Variables args build_name compiler example list name runner show_model verbose Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: example logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) character(len=:), public, allocatable :: runner logical, public :: show_model = .false. logical, public :: verbose = .true.","tags":"","loc":"type/fpm_run_settings.html"},{"title":"fpm_test_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_run_settings ) :: fpm_test_settings Contents Variables args build_name compiler example list name runner show_model verbose Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: example logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) character(len=:), public, allocatable :: runner logical, public :: show_model = .false. logical, public :: verbose = .true.","tags":"","loc":"type/fpm_test_settings.html"},{"title":"fpm_update_settings – Fortran-lang/fpm ","text":"type, public, extends( fpm_cmd_settings ) :: fpm_update_settings Settings for interacting and updating with project dependencies Contents Variables clean fetch_only name verbose Components Type Visibility Attributes Name Initial logical, public :: clean logical, public :: fetch_only character(len=ibug), public, allocatable :: name (:) logical, public :: verbose = .true.","tags":"","loc":"type/fpm_update_settings.html"},{"title":"build_target_ptr – Fortran-lang/fpm ","text":"type, public :: build_target_ptr Wrapper type for constructing arrays of build_target_t pointers Contents Variables ptr Source Code build_target_ptr Components Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: ptr => null() Source Code type build_target_ptr type ( build_target_t ), pointer :: ptr => null () end type build_target_ptr","tags":"","loc":"type/build_target_ptr.html"},{"title":"build_target_t – Fortran-lang/fpm ","text":"type, public :: build_target_t Type describing a generated build target Contents Variables dependencies digest_cached link_libraries link_objects output_file schedule skip sorted source target_type touched Source Code build_target_t Components Type Visibility Attributes Name Initial type( build_target_ptr ), public, allocatable :: dependencies (:) Resolved build dependencies integer(kind=int64), public, allocatable :: digest_cached Previous source file hash type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against type( string_t ), public, allocatable :: link_objects (:) Objects needed to link this target character(len=:), public, allocatable :: output_file File path of build target object relative to cwd integer, public :: schedule = -1 Targets in the same schedule group are guaranteed to be independent logical, public :: skip = .false. Flag set if build target will be skipped (not built) logical, public :: sorted = .false. Flag set if build target is sorted for building type( srcfile_t ), public, allocatable :: source Primary source for this build target integer, public :: target_type = FPM_TARGET_UNKNOWN Target type logical, public :: touched = .false. Flag set when first visited to check for circular dependencies Source Code type build_target_t !> File path of build target object relative to cwd character (:), allocatable :: output_file !> Primary source for this build target type ( srcfile_t ), allocatable :: source !> Resolved build dependencies type ( build_target_ptr ), allocatable :: dependencies (:) !> Target type integer :: target_type = FPM_TARGET_UNKNOWN !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Objects needed to link this target type ( string_t ), allocatable :: link_objects (:) !> Flag set when first visited to check for circular dependencies logical :: touched = . false . !> Flag set if build target is sorted for building logical :: sorted = . false . !> Flag set if build target will be skipped (not built) logical :: skip = . false . !> Targets in the same schedule group are guaranteed to be independent integer :: schedule = - 1 !> Previous source file hash integer ( int64 ), allocatable :: digest_cached end type build_target_t","tags":"","loc":"type/build_target_t.html"},{"title":"fpm_model_t – Fortran-lang/fpm ","text":"type, public :: fpm_model_t Type describing everything required to build a package\n and its dependencies. Contents Variables deps fortran_compile_flags fortran_compiler library_file link_flags link_libraries output_directory package_name sources targets Source Code fpm_model_t Components Type Visibility Attributes Name Initial type( dependency_tree_t ), public :: deps Project dependencies character(len=:), public, allocatable :: fortran_compile_flags Command line flags passed to fortran for compilation character(len=:), public, allocatable :: fortran_compiler Command line name to invoke fortran compiler character(len=:), public, allocatable :: library_file Output file for library archive character(len=:), public, allocatable :: link_flags Command line flags pass for linking type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against character(len=:), public, allocatable :: output_directory Base directory for build character(len=:), public, allocatable :: package_name Name of package type( srcfile_t ), public, allocatable :: sources (:) Array of sources type( build_target_ptr ), public, allocatable :: targets (:) Array of targets with module-dependencies resolved Source Code type :: fpm_model_t !> Name of package character (:), allocatable :: package_name !> Array of sources type ( srcfile_t ), allocatable :: sources (:) !> Array of targets with module-dependencies resolved type ( build_target_ptr ), allocatable :: targets (:) !> Command line name to invoke fortran compiler character (:), allocatable :: fortran_compiler !> Command line flags passed to fortran for compilation character (:), allocatable :: fortran_compile_flags !> Command line flags pass for linking character (:), allocatable :: link_flags !> Output file for library archive character (:), allocatable :: library_file !> Base directory for build character (:), allocatable :: output_directory !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Project dependencies type ( dependency_tree_t ) :: deps end type fpm_model_t","tags":"","loc":"type/fpm_model_t.html"},{"title":"srcfile_t – Fortran-lang/fpm ","text":"type, public :: srcfile_t Type for describing a source file Contents Variables digest exe_name file_name include_dependencies link_libraries modules_provided modules_used unit_scope unit_type Source Code srcfile_t Components Type Visibility Attributes Name Initial integer(kind=int64), public :: digest Current hash character(len=:), public, allocatable :: exe_name Name of executable for FPM_UNIT_PROGRAM character(len=:), public, allocatable :: file_name File path relative to cwd type( string_t ), public, allocatable :: include_dependencies (:) Files INCLUDEd by this source file type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against type( string_t ), public, allocatable :: modules_provided (:) Modules provided by this source file (lowerstring) type( string_t ), public, allocatable :: modules_used (:) Modules USEd by this source file (lowerstring) integer, public :: unit_scope = FPM_SCOPE_UNKNOWN Target module-use scope integer, public :: unit_type = FPM_UNIT_UNKNOWN Type of source unit Source Code type srcfile_t !> File path relative to cwd character (:), allocatable :: file_name !> Name of executable for FPM_UNIT_PROGRAM character (:), allocatable :: exe_name !> Target module-use scope integer :: unit_scope = FPM_SCOPE_UNKNOWN !> Modules provided by this source file (lowerstring) type ( string_t ), allocatable :: modules_provided (:) !> Type of source unit integer :: unit_type = FPM_UNIT_UNKNOWN !>  Modules USEd by this source file (lowerstring) type ( string_t ), allocatable :: modules_used (:) !> Files INCLUDEd by this source file type ( string_t ), allocatable :: include_dependencies (:) !> Native libraries to link against type ( string_t ), allocatable :: link_libraries (:) !> Current hash integer ( int64 ) :: digest end type srcfile_t","tags":"","loc":"type/srcfile_t.html"},{"title":"string_t – Fortran-lang/fpm ","text":"type, public :: string_t Contents Variables s Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s","tags":"","loc":"type/string_t.html"},{"title":"enum_descriptor – Fortran-lang/fpm ","text":"type, public :: enum_descriptor Possible git target Contents Variables branch default revision tag Source Code enum_descriptor Components Type Visibility Attributes Name Initial integer, public :: branch = 201 Branch in git repository integer, public :: default = 200 Default target integer, public :: revision = 203 Commit hash integer, public :: tag = 202 Tag in git repository Source Code type :: enum_descriptor !> Default target integer :: default = 200 !> Branch in git repository integer :: branch = 201 !> Tag in git repository integer :: tag = 202 !> Commit hash integer :: revision = 203 end type enum_descriptor","tags":"","loc":"type/enum_descriptor.html"},{"title":"git_target_t – Fortran-lang/fpm ","text":"type, public :: git_target_t Description of an git target Contents Variables object url Type-Bound Procedures checkout info Source Code git_target_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: object Additional descriptor of the git object character(len=:), public, allocatable :: url Target URL of the git repository Type-Bound Procedures procedure, public :: checkout Fetch and checkout in local directory public subroutine checkout (self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error procedure, public :: info Show information on instance public subroutine info (self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: git_target_t !> Kind of the git target integer , private :: descriptor = git_descriptor % default !> Target URL of the git repository character ( len = :), allocatable :: url !> Additional descriptor of the git object character ( len = :), allocatable :: object contains !> Fetch and checkout in local directory procedure :: checkout !> Show information on instance procedure :: info end type git_target_t","tags":"","loc":"type/git_target_t.html"},{"title":"error_t – Fortran-lang/fpm ","text":"type, public :: error_t Data type defining an error Contents Variables message Source Code error_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message Source Code type :: error_t !> Error message character ( len = :), allocatable :: message end type error_t","tags":"","loc":"type/error_t.html"},{"title":"installer_t – Fortran-lang/fpm ","text":"type, public :: installer_t Declaration of the installer type Contents Variables bindir copy includedir libdir os prefix unit verbosity Type-Bound Procedures install install_executable install_header install_library make_dir run Source Code installer_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bindir Binary dir relative to the installation prefix character(len=:), public, allocatable :: copy Command to copy objects into the installation prefix character(len=:), public, allocatable :: includedir Include directory relative to the installation prefix character(len=:), public, allocatable :: libdir Library directory relative to the installation prefix integer, public :: os Cached operating system character(len=:), public, allocatable :: prefix Path to installation directory integer, public :: unit = output_unit Output unit for informative printout integer, public :: verbosity = 1 Verbosity of the installer Type-Bound Procedures procedure, public :: install Install a generic file into a subdirectory in the installation prefix private subroutine install(self, source, destination, error) Install a generic file into a subdirectory in the installation prefix Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: source Path to the original file character(len=*), intent(in) :: destination Path to the destination inside the prefix type( error_t ), intent(out), allocatable :: error Error handling procedure, public :: install_executable Install an executable in its correct subdirectory private subroutine install_executable(self, executable, error) Install an executable in its correct subdirectory Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: executable Path to the executable type( error_t ), intent(out), allocatable :: error Error handling procedure, public :: install_header Install a header/module in its correct subdirectory private subroutine install_header(self, header, error) Install a header/module in its correct subdirectory Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: header Path to the header type( error_t ), intent(out), allocatable :: error Error handling procedure, public :: install_library Install a library in its correct subdirectory private subroutine install_library(self, library, error) Install a library in its correct subdirectory Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: library Path to the library type( error_t ), intent(out), allocatable :: error Error handling procedure, public :: make_dir Create a new directory in the prefix, type-bound for unit testing purposes private subroutine make_dir(self, dir, error) Create a new directory in the prefix Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: dir Directory to be created type( error_t ), intent(out), allocatable :: error Error handling procedure, public :: run Run an installation command, type-bound for unit testing purposes private subroutine run(self, command, error) Run an installation command Arguments Type Intent Optional Attributes Name class( installer_t ), intent(inout) :: self Instance of the installer character(len=*), intent(in) :: command Command to be launched type( error_t ), intent(out), allocatable :: error Error handling Source Code type :: installer_t !> Path to installation directory character ( len = :), allocatable :: prefix !> Binary dir relative to the installation prefix character ( len = :), allocatable :: bindir !> Library directory relative to the installation prefix character ( len = :), allocatable :: libdir !> Include directory relative to the installation prefix character ( len = :), allocatable :: includedir !> Output unit for informative printout integer :: unit = output_unit !> Verbosity of the installer integer :: verbosity = 1 !> Command to copy objects into the installation prefix character ( len = :), allocatable :: copy !> Cached operating system integer :: os contains !> Install an executable in its correct subdirectory procedure :: install_executable !> Install a library in its correct subdirectory procedure :: install_library !> Install a header/module in its correct subdirectory procedure :: install_header !> Install a generic file into a subdirectory in the installation prefix procedure :: install !> Run an installation command, type-bound for unit testing purposes procedure :: run !> Create a new directory in the prefix, type-bound for unit testing purposes procedure :: make_dir end type installer_t","tags":"","loc":"type/installer_t.html"},{"title":"version_t – Fortran-lang/fpm ","text":"type, public :: version_t Contents Type-Bound Procedures operator(.match.) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) to_string Source Code version_t Type-Bound Procedures generic, public :: operator(.match.) => match Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) private elemental function match(lhs, rhs) Try to match first version against second version Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version match following semantic versioning rules generic, public :: operator(/=) => not_equals private elemental function not_equals(lhs, rhs) result(not_equal) Check two versions for inequality Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version mismatch generic, public :: operator(<) => less private elemental function less(lhs, rhs) result(is_less) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is less generic, public :: operator(<=) => less_equals private elemental function less_equals(lhs, rhs) result(is_less_equal) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is less or equal generic, public :: operator(==) => equals private elemental function equals(lhs, rhs) result(is_equal) Check to version numbers for equality Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical Version match generic, public :: operator(>) => greater private elemental function greater(lhs, rhs) result(is_greater) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is greater generic, public :: operator(>=) => greater_equals private elemental function greater_equals(lhs, rhs) result(is_greater_equal) Relative comparison of two versions Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: lhs First version number class( version_t ), intent(in) :: rhs Second version number Return Value logical First version is greater or equal procedure, public :: to_string Create a printable string from a version data type private subroutine to_string(self, string) Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: self Version number character(len=:), intent(out), allocatable :: string Character representation of the version Source Code type :: version_t private !> Version numbers found integer , allocatable :: num (:) contains generic :: operator ( == ) => equals procedure , private :: equals generic :: operator ( /= ) => not_equals procedure , private :: not_equals generic :: operator ( > ) => greater procedure , private :: greater generic :: operator ( < ) => less procedure , private :: less generic :: operator ( >= ) => greater_equals procedure , private :: greater_equals generic :: operator ( <= ) => less_equals procedure , private :: less_equals !> Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic :: operator (. match .) => match procedure , private :: match !> Create a printable string from a version data type procedure :: to_string end type version_t","tags":"","loc":"type/version_t.html"},{"title":"dependency_node_t – Fortran-lang/fpm ","text":"type, public, extends( dependency_config_t ) :: dependency_node_t Dependency node in the projects dependency tree Contents Variables done git name path proj_dir revision update version Type-Bound Procedures info register Source Code dependency_node_t Components Type Visibility Attributes Name Initial logical, public :: done = .false. Dependency is handled type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target character(len=:), public, allocatable :: proj_dir Installation prefix of this dependencies character(len=:), public, allocatable :: revision Checked out revision of the version control system logical, public :: update = .false. Dependency should be updated type( version_t ), public, allocatable :: version Actual version of this dependency Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( dependency_config_t ), intent(in) :: self Instance of the dependency configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout procedure, public :: register Update dependency from project manifest private subroutine register(self, package, root, fetch, revision, error) Update dependency from project manifest Arguments Type Intent Optional Attributes Name class( dependency_node_t ), intent(inout) :: self Instance of the dependency node type( package_config_t ), intent(in) :: package Package configuration data character(len=*), intent(in) :: root Root directory of the project logical, intent(in) :: fetch Project has been fetched character(len=*), intent(in), optional :: revision Git revision of the project type( error_t ), intent(out), allocatable :: error Error handling Source Code type , extends ( dependency_config_t ) :: dependency_node_t !> Actual version of this dependency type ( version_t ), allocatable :: version !> Installation prefix of this dependencies character ( len = :), allocatable :: proj_dir !> Checked out revision of the version control system character ( len = :), allocatable :: revision !> Dependency is handled logical :: done = . false . !> Dependency should be updated logical :: update = . false . contains !> Update dependency from project manifest procedure :: register end type dependency_node_t","tags":"","loc":"type/dependency_node_t.html"},{"title":"dependency_tree_t – Fortran-lang/fpm ","text":"type, public :: dependency_tree_t Respresentation of a projects dependencies The dependencies are stored in a simple array for now, this can be replaced\n with a binary-search tree or a hash table in the future. Contents Variables cache dep dep_dir ndep unit verbosity Type-Bound Procedures add dump find finished load resolve update Source Code dependency_tree_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cache Cache file type( dependency_node_t ), public, allocatable :: dep (:) Flattend list of all dependencies character(len=:), public, allocatable :: dep_dir Installation prefix for dependencies integer, public :: ndep = 0 Number of currently registered dependencies integer, public :: unit = output_unit Unit for IO integer, public :: verbosity = 1 Verbosity of printout Type-Bound Procedures generic, public :: add => add_project, add_project_dependencies, add_dependencies, add_dependency Overload procedure to add new dependencies to the tree private subroutine add_project(self, package, error) Add project dependencies, each depth level after each other. Read more… Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type( package_config_t ), intent(in) :: package Project configuration to add type( error_t ), intent(out), allocatable :: error Error handling private recursive subroutine add_project_dependencies(self, package, root, main, error) Add a project and its dependencies to the dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type( package_config_t ), intent(in) :: package Project configuration to add character(len=*), intent(in) :: root Current project root directory logical, intent(in) :: main Is the main project type( error_t ), intent(out), allocatable :: error Error handling private subroutine add_dependencies(self, dependency, error) Add a list of dependencies to the dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type( dependency_config_t ), intent(in) :: dependency (:) Dependency configuration to add type( error_t ), intent(out), allocatable :: error Error handling private pure subroutine add_dependency(self, dependency, error) Add a single dependency to the dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type( dependency_config_t ), intent(in) :: dependency Dependency configuration to add type( error_t ), intent(out), allocatable :: error Error handling generic, public :: dump => dump_to_file, dump_to_unit, dump_to_toml Writing of dependency tree private subroutine dump_to_file(self, file, error) Write dependency tree to file Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree character(len=*), intent(in) :: file File name type( error_t ), intent(out), allocatable :: error Error handling private subroutine dump_to_unit(self, unit, error) Write dependency tree to file Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree integer, intent(in) :: unit Formatted unit type( error_t ), intent(out), allocatable :: error Error handling private subroutine dump_to_toml(self, table, error) Write dependency tree to TOML datastructure Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type(toml_table), intent(inout) :: table Data structure type( error_t ), intent(out), allocatable :: error Error handling generic, public :: find => find_dependency, find_name Find a dependency in the tree private pure function find_dependency(self, dependency) result(pos) Find a dependency in the dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(in) :: self Instance of the dependency tree class( dependency_config_t ), intent(in) :: dependency Dependency configuration to add Return Value integer Index of the dependency private pure function find_name(self, name) result(pos) Find a dependency in the dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(in) :: self Instance of the dependency tree character(len=*), intent(in) :: name Dependency configuration to add Return Value integer Index of the dependency procedure, public :: finished Depedendncy resolution finished private pure function finished(self) Check if we are done with the dependency resolution Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(in) :: self Instance of the dependency tree Return Value logical All dependencies are updated generic, public :: load => load_from_file, load_from_unit, load_from_toml Reading of dependency tree private subroutine load_from_file(self, file, error) Read dependency tree from file Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree character(len=*), intent(in) :: file File name type( error_t ), intent(out), allocatable :: error Error handling private subroutine load_from_unit(self, unit, error) Read dependency tree from file Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree integer, intent(in) :: unit File name type( error_t ), intent(out), allocatable :: error Error handling private subroutine load_from_toml(self, table, error) Read dependency tree from TOML data structure Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type(toml_table), intent(inout) :: table Data structure type( error_t ), intent(out), allocatable :: error Error handling generic, public :: resolve => resolve_dependencies, resolve_dependency Resolve dependencies private subroutine resolve_dependencies(self, root, error) Resolve all dependencies in the tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree character(len=*), intent(in) :: root Current installation prefix type( error_t ), intent(out), allocatable :: error Error handling private subroutine resolve_dependency(self, dependency, root, error) Resolve a single dependency node Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree type( dependency_node_t ), intent(inout) :: dependency Dependency configuration to add character(len=*), intent(in) :: root Current installation prefix type( error_t ), intent(out), allocatable :: error Error handling generic, public :: update => update_dependency Update dependency tree private subroutine update_dependency(self, name, error) Update dependency tree Arguments Type Intent Optional Attributes Name class( dependency_tree_t ), intent(inout) :: self Instance of the dependency tree character(len=*), intent(in) :: name Name of the dependency to update type( error_t ), intent(out), allocatable :: error Error handling Source Code type :: dependency_tree_t !> Unit for IO integer :: unit = output_unit !> Verbosity of printout integer :: verbosity = 1 !> Installation prefix for dependencies character ( len = :), allocatable :: dep_dir !> Number of currently registered dependencies integer :: ndep = 0 !> Flattend list of all dependencies type ( dependency_node_t ), allocatable :: dep (:) !> Cache file character ( len = :), allocatable :: cache contains !> Overload procedure to add new dependencies to the tree generic :: add => add_project , add_project_dependencies , add_dependencies , & add_dependency !> Main entry point to add a project procedure , private :: add_project !> Add a project and its dependencies to the dependency tree procedure , private :: add_project_dependencies !> Add a list of dependencies to the dependency tree procedure , private :: add_dependencies !> Add a single dependency to the dependency tree procedure , private :: add_dependency !> Resolve dependencies generic :: resolve => resolve_dependencies , resolve_dependency !> Resolve dependencies procedure , private :: resolve_dependencies !> Resolve dependencies procedure , private :: resolve_dependency !> Find a dependency in the tree generic :: find => find_dependency , find_name !> Find a dependency from an dependency configuration procedure , private :: find_dependency !> Find a dependency by its name procedure , private :: find_name !> Depedendncy resolution finished procedure :: finished !> Reading of dependency tree generic :: load => load_from_file , load_from_unit , load_from_toml !> Read dependency tree from file procedure , private :: load_from_file !> Read dependency tree from formatted unit procedure , private :: load_from_unit !> Read dependency tree from TOML data structure procedure , private :: load_from_toml !> Writing of dependency tree generic :: dump => dump_to_file , dump_to_unit , dump_to_toml !> Write dependency tree to file procedure , private :: dump_to_file !> Write dependency tree to formatted unit procedure , private :: dump_to_unit !> Write dependency tree to TOML data structure procedure , private :: dump_to_toml !> Update dependency tree generic :: update => update_dependency !> Update a list of dependencies procedure , private :: update_dependency end type dependency_tree_t","tags":"","loc":"type/dependency_tree_t.html"},{"title":"install_config_t – Fortran-lang/fpm ","text":"type, public :: install_config_t Configuration data for installation Contents Variables library Type-Bound Procedures info Source Code install_config_t Components Type Visibility Attributes Name Initial logical, public :: library Install library with this project Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on install configuration instance Arguments Type Intent Optional Attributes Name class( install_config_t ), intent(in) :: self Instance of the build configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: install_config_t !> Install library with this project logical :: library contains !> Print information on this instance procedure :: info end type install_config_t","tags":"","loc":"type/install_config_t.html"},{"title":"example_config_t – Fortran-lang/fpm ","text":"type, public, extends( executable_config_t ) :: example_config_t Configuation meta data for an example Contents Variables dependency link main name source_dir Type-Bound Procedures info Source Code example_config_t Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( example_config_t ), intent(in) :: self Instance of the example configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type , extends ( executable_config_t ) :: example_config_t contains !> Print information on this instance procedure :: info end type example_config_t","tags":"","loc":"type/example_config_t.html"},{"title":"package_config_t – Fortran-lang/fpm ","text":"type, public :: package_config_t Package meta data Contents Variables build dependency dev_dependency example executable install library name test version Type-Bound Procedures info Source Code package_config_t Components Type Visibility Attributes Name Initial type( build_config_t ), public :: build Build configuration data type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data type( dependency_config_t ), public, allocatable :: dev_dependency (:) Development dependency meta data type( example_config_t ), public, allocatable :: example (:) Example meta data type( executable_config_t ), public, allocatable :: executable (:) Executable meta data type( install_config_t ), public :: install Installation configuration data type( library_config_t ), public, allocatable :: library Library meta data character(len=:), public, allocatable :: name Name of the package type( test_config_t ), public, allocatable :: test (:) Test meta data type( version_t ), public :: version Package version Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( package_config_t ), intent(in) :: self Instance of the package configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: package_config_t !> Name of the package character ( len = :), allocatable :: name !> Package version type ( version_t ) :: version !> Build configuration data type ( build_config_t ) :: build !> Installation configuration data type ( install_config_t ) :: install !> Library meta data type ( library_config_t ), allocatable :: library !> Executable meta data type ( executable_config_t ), allocatable :: executable (:) !> Dependency meta data type ( dependency_config_t ), allocatable :: dependency (:) !> Development dependency meta data type ( dependency_config_t ), allocatable :: dev_dependency (:) !> Example meta data type ( example_config_t ), allocatable :: example (:) !> Test meta data type ( test_config_t ), allocatable :: test (:) contains !> Print information on this instance procedure :: info end type package_config_t","tags":"","loc":"type/package_config_t.html"},{"title":"library_config_t – Fortran-lang/fpm ","text":"type, public :: library_config_t Configuration meta data for a library Contents Variables build_script source_dir Type-Bound Procedures info Source Code library_config_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_script Alternative build script to be invoked character(len=:), public, allocatable :: source_dir Source path prefix Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( library_config_t ), intent(in) :: self Instance of the library configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: library_config_t !> Source path prefix character ( len = :), allocatable :: source_dir !> Alternative build script to be invoked character ( len = :), allocatable :: build_script contains !> Print information on this instance procedure :: info end type library_config_t","tags":"","loc":"type/library_config_t.html"},{"title":"test_config_t – Fortran-lang/fpm ","text":"type, public, extends( executable_config_t ) :: test_config_t Configuation meta data for an test Contents Variables dependency link main name source_dir Type-Bound Procedures info Source Code test_config_t Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( test_config_t ), intent(in) :: self Instance of the test configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type , extends ( executable_config_t ) :: test_config_t contains !> Print information on this instance procedure :: info end type test_config_t","tags":"","loc":"type/test_config_t.html"},{"title":"executable_config_t – Fortran-lang/fpm ","text":"type, public :: executable_config_t Configuation meta data for an executable Contents Variables dependency link main name source_dir Type-Bound Procedures info Source Code executable_config_t Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( executable_config_t ), intent(in) :: self Instance of the executable configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: executable_config_t !> Name of the resulting executable character ( len = :), allocatable :: name !> Source directory for collecting the executable character ( len = :), allocatable :: source_dir !> Name of the source file declaring the main program character ( len = :), allocatable :: main !> Dependency meta data for this executable type ( dependency_config_t ), allocatable :: dependency (:) !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type executable_config_t","tags":"","loc":"type/executable_config_t.html"},{"title":"dependency_config_t – Fortran-lang/fpm ","text":"type, public :: dependency_config_t Configuration meta data for a dependency Contents Variables git name path Type-Bound Procedures info Source Code dependency_config_t Components Type Visibility Attributes Name Initial type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on instance Arguments Type Intent Optional Attributes Name class( dependency_config_t ), intent(in) :: self Instance of the dependency configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: dependency_config_t !> Name of the dependency character ( len = :), allocatable :: name !> Local target character ( len = :), allocatable :: path !> Git descriptor type ( git_target_t ), allocatable :: git contains !> Print information on this instance procedure :: info end type dependency_config_t","tags":"","loc":"type/dependency_config_t.html"},{"title":"build_config_t – Fortran-lang/fpm ","text":"type, public :: build_config_t Configuration data for build Contents Variables auto_examples auto_executables auto_tests link Type-Bound Procedures info Source Code build_config_t Components Type Visibility Attributes Name Initial logical, public :: auto_examples Automatic discovery of examples logical, public :: auto_executables Automatic discovery of executables logical, public :: auto_tests Automatic discovery of tests type( string_t ), public, allocatable :: link (:) Libraries to link against Type-Bound Procedures procedure, public :: info Print information on this instance private subroutine info(self, unit, verbosity) Write information on build configuration instance Arguments Type Intent Optional Attributes Name class( build_config_t ), intent(in) :: self Instance of the build configuration integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Source Code type :: build_config_t !> Automatic discovery of executables logical :: auto_executables !> Automatic discovery of examples logical :: auto_examples !> Automatic discovery of tests logical :: auto_tests !> Libraries to link against type ( string_t ), allocatable :: link (:) contains !> Print information on this instance procedure :: info end type build_config_t","tags":"","loc":"type/build_config_t.html"},{"title":"basename – Fortran-lang/fpm","text":"public function basename(path, suffix) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path logical, intent(in), optional :: suffix Return Value character(len=:),\n  allocatable Contents Variables file_parts with_suffix Source Code basename Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_parts (:) logical, public :: with_suffix Source Code function basename ( path , suffix ) result ( base ) ! Extract filename from path with/without suffix ! character ( * ), intent ( In ) :: path logical , intent ( in ), optional :: suffix character (:), allocatable :: base character (:), allocatable :: file_parts (:) logical :: with_suffix if (. not . present ( suffix )) then with_suffix = . true . else with_suffix = suffix end if if ( with_suffix ) then call split ( path , file_parts , delimiters = '\\/' ) if ( size ( file_parts ). gt . 0 ) then base = trim ( file_parts ( size ( file_parts ))) else base = '' endif else call split ( path , file_parts , delimiters = '\\/.' ) if ( size ( file_parts ). ge . 2 ) then base = trim ( file_parts ( size ( file_parts ) - 1 )) else base = '' endif end if end function basename","tags":"","loc":"proc/basename.html"},{"title":"canon_path – Fortran-lang/fpm","text":"public function canon_path(path) result(canon) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables i iback j nixpath temp Source Code canon_path Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iback integer, public :: j character(len=len(path)), public :: nixpath character(len=len(path)), public :: temp Source Code function canon_path ( path ) result ( canon ) ! Canonicalize path for comparison !  Handles path string redundancies !  Does not test existence of path ! ! To be replaced by realpath/_fullname in stdlib_os ! character ( * ), intent ( in ) :: path character (:), allocatable :: canon integer :: i , j integer :: iback character ( len ( path )) :: nixpath character ( len ( path )) :: temp nixpath = unix_path ( path ) j = 1 do i = 1 , len ( nixpath ) ! Skip back to last directory for '/../' if ( i > 4 ) then if ( nixpath ( i - 3 : i ) == '/../' ) then iback = scan ( nixpath ( 1 : i - 4 ), '/' , back = . true .) if ( iback > 0 ) then j = iback + 1 cycle end if end if end if if ( i > 1 . and . j > 1 ) then ! Ignore current directory reference if ( nixpath ( i - 1 : i ) == './' ) then j = j - 1 cycle end if ! Ignore repeated separators if ( nixpath ( i - 1 : i ) == '//' ) then cycle end if ! Do NOT include trailing slash if ( i == len ( nixpath ) . and . nixpath ( i : i ) == '/' ) then cycle end if end if temp ( j : j ) = nixpath ( i : i ) j = j + 1 end do canon = temp ( 1 : j - 1 ) end function canon_path","tags":"","loc":"proc/canon_path.html"},{"title":"dirname – Fortran-lang/fpm","text":"public function dirname(path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables file_parts Source Code dirname Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: file_parts (:) Source Code function dirname ( path ) result ( dir ) ! Extract dirname from path ! character ( * ), intent ( in ) :: path character (:), allocatable :: dir character (:), allocatable :: file_parts (:) dir = path ( 1 : scan ( path , ' / \\' , back = . true .)) end function dirname","tags":"","loc":"proc/dirname.html"},{"title":"exists – Fortran-lang/fpm","text":"public function exists(filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Contents None","tags":"","loc":"proc/exists.html"},{"title":"get_temp_filename – Fortran-lang/fpm","text":"public function get_temp_filename() result(tempfile) Uses iso_c_binding Arguments None Return Value character(len=:),\n  allocatable Contents Variables c_tempfile c_tempfile_ptr Interfaces c_free c_tempnam Source Code get_temp_filename Variables Type Visibility Attributes Name Initial character(len=1), public, pointer :: c_tempfile (:) type(c_ptr), public :: c_tempfile_ptr Interfaces interface subroutine c_free(ptr) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr interface function c_tempnam(dir, pfx) result(tmp) bind(c,name=\"tempnam\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: dir type(c_ptr), intent(in), value :: pfx Return Value type(c_ptr) Source Code function get_temp_filename () result ( tempfile ) ! Get a unused temporary filename !  Calls posix 'tempnam' - not recommended, but !   we have no security concerns for this application !   and use here is temporary. ! Works with MinGW ! use iso_c_binding , only : c_ptr , C_NULL_PTR , c_f_pointer character (:), allocatable :: tempfile type ( c_ptr ) :: c_tempfile_ptr character ( len = 1 ), pointer :: c_tempfile (:) interface function c_tempnam ( dir , pfx ) result ( tmp ) bind ( c , name = \"tempnam\" ) import type ( c_ptr ), intent ( in ), value :: dir type ( c_ptr ), intent ( in ), value :: pfx type ( c_ptr ) :: tmp end function c_tempnam subroutine c_free ( ptr ) BIND ( C , name = \"free\" ) import type ( c_ptr ), value :: ptr end subroutine c_free end interface c_tempfile_ptr = c_tempnam ( C_NULL_PTR , C_NULL_PTR ) call c_f_pointer ( c_tempfile_ptr , c_tempfile ,[ LINE_BUFFER_LEN ]) tempfile = f_string ( c_tempfile ) call c_free ( c_tempfile_ptr ) end function get_temp_filename","tags":"","loc":"proc/get_temp_filename.html"},{"title":"is_dir – Fortran-lang/fpm","text":"public function is_dir(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Return Value logical Contents Variables stat Source Code is_dir Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code logical function is_dir ( dir ) character ( * ), intent ( in ) :: dir integer :: stat select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( \"test -d \" // dir , exitstat = stat ) case ( OS_WINDOWS ) call execute_command_line ( 'cmd /c \"if not exist ' // windows_path ( dir ) // '\\ exit /B 1\"' , exitstat = stat ) end select is_dir = ( stat == 0 ) end function is_dir","tags":"","loc":"proc/is_dir.html"},{"title":"join_path – Fortran-lang/fpm","text":"public function join_path(a1, a2, a3, a4, a5) result(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 character(len=*), intent(in), optional :: a3 character(len=*), intent(in), optional :: a4 character(len=*), intent(in), optional :: a5 Return Value character(len=:),\n  allocatable Contents Variables filesep Source Code join_path Variables Type Visibility Attributes Name Initial character(len=1), public :: filesep Source Code function join_path ( a1 , a2 , a3 , a4 , a5 ) result ( path ) ! Construct path by joining strings with os file separator ! character ( len =* ), intent ( in ) :: a1 , a2 character ( len =* ), intent ( in ), optional :: a3 , a4 , a5 character ( len = :), allocatable :: path character ( len = 1 ) :: filesep select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) filesep = '/' case ( OS_WINDOWS ) filesep = '\\' end select path = a1 // filesep // a2 if ( present ( a3 )) then path = path // filesep // a3 else return end if if ( present ( a4 )) then path = path // filesep // a4 else return end if if ( present ( a5 )) then path = path // filesep // a5 else return end if end function join_path","tags":"","loc":"proc/join_path.html"},{"title":"number_of_rows – Fortran-lang/fpm","text":"public function number_of_rows(s) result(nrows) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value integer Contents Variables ios r Source Code number_of_rows Variables Type Visibility Attributes Name Initial integer, public :: ios character(len=100), public :: r Source Code integer function number_of_rows ( s ) result ( nrows ) ! determine number or rows integer , intent ( in ) :: s integer :: ios character ( len = 100 ) :: r rewind ( s ) nrows = 0 do read ( s , '(A)' , iostat = ios ) r if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) end function number_of_rows","tags":"","loc":"proc/number_of_rows.html"},{"title":"read_lines – Fortran-lang/fpm","text":"public function read_lines(fh) result(lines) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh Return Value type( string_t ),\n  allocatable,(:) Contents Variables i line_buffer Source Code read_lines Variables Type Visibility Attributes Name Initial integer, public :: i character(len=LINE_BUFFER_LEN), public :: line_buffer Source Code function read_lines ( fh ) result ( lines ) integer , intent ( in ) :: fh type ( string_t ), allocatable :: lines (:) integer :: i character ( LINE_BUFFER_LEN ) :: line_buffer allocate ( lines ( number_of_rows ( fh ))) do i = 1 , size ( lines ) read ( fh , '(A)' ) line_buffer lines ( i )% s = trim ( line_buffer ) end do end function read_lines","tags":"","loc":"proc/read_lines.html"},{"title":"unix_path – Fortran-lang/fpm","text":"public function unix_path(path) result(nixpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables idx Source Code unix_path Variables Type Visibility Attributes Name Initial integer, public :: idx Source Code function unix_path ( path ) result ( nixpath ) ! Replace file system separators for unix ! character ( * ), intent ( in ) :: path character (:), allocatable :: nixpath integer :: idx nixpath = path idx = index ( nixpath , '\\') do while(idx > 0) nixpath(idx:idx) = ' / ' idx = index(nixpath,' \\' ) end do end function unix_path","tags":"","loc":"proc/unix_path.html"},{"title":"windows_path – Fortran-lang/fpm","text":"public function windows_path(path) result(winpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Contents Variables idx Source Code windows_path Variables Type Visibility Attributes Name Initial integer, public :: idx Source Code function windows_path ( path ) result ( winpath ) ! Replace file system separators for windows ! character ( * ), intent ( in ) :: path character (:), allocatable :: winpath integer :: idx winpath = path idx = index ( winpath , '/' ) do while ( idx > 0 ) winpath ( idx : idx ) = '\\' idx = index(winpath,' / ' ) end do end function windows_path","tags":"","loc":"proc/windows_path.html"},{"title":"delete_file – Fortran-lang/fpm","text":"public subroutine delete_file(file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Contents Variables exist unit Source Code delete_file Variables Type Visibility Attributes Name Initial logical, public :: exist integer, public :: unit Source Code subroutine delete_file ( file ) character ( len =* ), intent ( in ) :: file logical :: exist integer :: unit inquire ( file = file , exist = exist ) if ( exist ) then open ( file = file , newunit = unit ) close ( unit , status = \"delete\" ) end if end subroutine delete_file","tags":"","loc":"proc/delete_file.html"},{"title":"env_variable – Fortran-lang/fpm","text":"public subroutine env_variable(var, name) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: var character(len=*), intent(in) :: name Contents Variables length stat Source Code env_variable Variables Type Visibility Attributes Name Initial integer, public :: length integer, public :: stat Source Code subroutine env_variable ( var , name ) character ( len = :), allocatable , intent ( out ) :: var character ( len =* ), intent ( in ) :: name integer :: length , stat call get_environment_variable ( name , length = length , status = stat ) if ( stat /= 0 ) return allocate ( character ( len = length ) :: var ) if ( length > 0 ) then call get_environment_variable ( name , var , status = stat ) if ( stat /= 0 ) then deallocate ( var ) return end if end if end subroutine env_variable","tags":"","loc":"proc/env_variable.html"},{"title":"getline – Fortran-lang/fpm","text":"public subroutine getline(unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message Contents Variables buffer msg size stat Source Code getline Variables Type Visibility Attributes Name Initial character(len=LINE_BUFFER_LEN), public :: buffer character(len=LINE_BUFFER_LEN), public :: msg integer, public :: size integer, public :: stat Source Code subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg character ( len = LINE_BUFFER_LEN ) :: buffer character ( len = LINE_BUFFER_LEN ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline","tags":"","loc":"proc/getline.html"},{"title":"list_files – Fortran-lang/fpm","text":"public recursive subroutine list_files(dir, files, recurse) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir type( string_t ), intent(out), allocatable :: files (:) logical, intent(in), optional :: recurse Contents Variables dir_files fh i stat sub_dir_files temp_file Source Code list_files Variables Type Visibility Attributes Name Initial type( string_t ), public, allocatable :: dir_files (:) integer, public :: fh integer, public :: i integer, public :: stat type( string_t ), public, allocatable :: sub_dir_files (:) character(len=:), public, allocatable :: temp_file Source Code recursive subroutine list_files ( dir , files , recurse ) ! Get file & directory names in directory `dir`. ! !  - File/directory names return are relative to cwd, ie. preprended with `dir` !  - Includes files starting with `.` except current directory and parent directory ! character ( len =* ), intent ( in ) :: dir type ( string_t ), allocatable , intent ( out ) :: files (:) logical , intent ( in ), optional :: recurse integer :: stat , fh , i character (:), allocatable :: temp_file type ( string_t ), allocatable :: dir_files (:) type ( string_t ), allocatable :: sub_dir_files (:) if (. not . is_dir ( dir )) then allocate ( files ( 0 )) return end if allocate ( temp_file , source = get_temp_filename ()) select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( 'ls -A ' // dir // ' > ' // temp_file , & exitstat = stat ) case ( OS_WINDOWS ) call execute_command_line ( 'dir /b ' // windows_path ( dir ) // ' > ' // temp_file , & exitstat = stat ) end select if ( stat /= 0 ) then print * , 'execute_command_line() failed' error stop end if open ( newunit = fh , file = temp_file , status = 'old' ) files = read_lines ( fh ) close ( fh , status = \"delete\" ) do i = 1 , size ( files ) files ( i )% s = join_path ( dir , files ( i )% s ) end do if ( present ( recurse )) then if ( recurse ) then allocate ( sub_dir_files ( 0 )) do i = 1 , size ( files ) if ( is_dir ( files ( i )% s )) then call list_files ( files ( i )% s , dir_files , recurse = . true .) sub_dir_files = [ sub_dir_files , dir_files ] end if end do files = [ files , sub_dir_files ] end if end if end subroutine list_files","tags":"","loc":"proc/list_files.html"},{"title":"mkdir – Fortran-lang/fpm","text":"public subroutine mkdir(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Contents Variables stat Source Code mkdir Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine mkdir ( dir ) character ( len =* ), intent ( in ) :: dir integer :: stat if ( is_dir ( dir )) return select case ( get_os_type ()) case ( OS_UNKNOWN , OS_LINUX , OS_MACOS , OS_CYGWIN , OS_SOLARIS , OS_FREEBSD ) call execute_command_line ( 'mkdir -p ' // dir , exitstat = stat ) write ( * , '(\" + \",2a)' ) 'mkdir -p ' // dir case ( OS_WINDOWS ) call execute_command_line ( \"mkdir \" // windows_path ( dir ), exitstat = stat ) write ( * , '(\" + \",2a)' ) 'mkdir ' // windows_path ( dir ) end select if ( stat /= 0 ) then print * , 'execute_command_line() failed' error stop end if end subroutine mkdir","tags":"","loc":"proc/mkdir.html"},{"title":"get_command_line_settings – Fortran-lang/fpm","text":"public subroutine get_command_line_settings(cmd_settings) ! canon_path is not converting “.”, etc.\n& ‘ unknown help topic “’//trim(unnamed(i)).’not found in:’,manual] Arguments Type Intent Optional Attributes Name class( fpm_cmd_settings ), intent(out), allocatable :: cmd_settings Contents Variables cmdarg i install_settings widest Subroutines check_build_vals printhelp Source Code get_command_line_settings Variables Type Visibility Attributes Name Initial character(len=4096), public :: cmdarg integer, public :: i type( fpm_install_settings ), public, allocatable :: install_settings integer, public :: widest Subroutines subroutine check_build_vals() Arguments None subroutine printhelp(lines) Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: lines (:) Source Code subroutine get_command_line_settings ( cmd_settings ) class ( fpm_cmd_settings ), allocatable , intent ( out ) :: cmd_settings character ( len = 4096 ) :: cmdarg integer :: i integer :: widest type ( fpm_install_settings ), allocatable :: install_settings call set_help () ! text for --version switch, select case ( get_os_type ()) case ( OS_LINUX ); os_type = \"OS Type:     Linux\" case ( OS_MACOS ); os_type = \"OS Type:     macOS\" case ( OS_WINDOWS ); os_type = \"OS Type:     Windows\" case ( OS_CYGWIN ); os_type = \"OS Type:     Cygwin\" case ( OS_SOLARIS ); os_type = \"OS Type:     Solaris\" case ( OS_FREEBSD ); os_type = \"OS Type:     FreeBSD\" case ( OS_UNKNOWN ); os_type = \"OS Type:     Unknown\" case default ; os_type = \"OS Type:     UNKNOWN\" end select version_text = [ character ( len = 80 ) :: & & 'Version:     0.1.3, alpha' , & & 'Program:     fpm(1)' , & & 'Description: A Fortran package manager and build system' , & & 'Home Page:   https://github.com/fortran-lang/fpm' , & & 'License:     MIT' , & & os_type ] ! find the subcommand name by looking for first word on command ! not starting with dash cmdarg = '' do i = 1 , command_argument_count () call get_command_argument ( i , cmdarg ) if ( adjustl ( cmdarg ( 1 : 1 )) . ne . '-' ) exit enddo ! now set subcommand-specific help text and process commandline ! arguments. Then call subcommand routine select case ( trim ( cmdarg )) case ( 'run' ) call set_args ( '& & --target \" \" & & --list F & & --release F& & --example F& & --runner \" \" & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_run , version_text ) call check_build_vals () if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif if ( specified ( 'target' ) ) then call split ( sget ( 'target' ), tnames , delimiters = ' ,:' ) names = [ character ( len = max ( len ( names ), len ( tnames ))) :: names , tnames ] endif allocate ( fpm_run_settings :: cmd_settings ) val_runner = sget ( 'runner' ) cmd_settings = fpm_run_settings (& & args = remaining ,& & build_name = val_build ,& & compiler = val_compiler , & & example = lget ( 'example' ), & & list = lget ( 'list' ),& & name = names ,& & runner = val_runner ,& & verbose = lget ( 'verbose' ) ) case ( 'build' ) call set_args ( '& & --release F & & --list F & & --show-model F & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_build , version_text ) call check_build_vals () allocate ( fpm_build_settings :: cmd_settings ) cmd_settings = fpm_build_settings ( & & build_name = val_build ,& & compiler = val_compiler , & & list = lget ( 'list' ),& & show_model = lget ( 'show-model' ),& & verbose = lget ( 'verbose' ) ) case ( 'new' ) call set_args ( '& & --src F & & --lib F & & --app F & & --test F & & --backfill F& & --verbose F' ,& & help_new , version_text ) select case ( size ( unnamed )) case ( 1 ) write ( stderr , '(*(g0,/))' ) '<ERROR> directory name required' write ( stderr , '(*(7x,g0,/))' ) & & '<USAGE> fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 1 case ( 2 ) name = trim ( unnamed ( 2 )) case default write ( stderr , '(g0)' ) '<ERROR> only one directory name allowed' write ( stderr , '(7x,g0)' ) & & '<USAGE> fpm new NAME [--lib|--src] [--app] [--test] [--backfill]' stop 2 end select !*! canon_path is not converting \".\", etc. name = canon_path ( name ) if ( . not . is_fortran_name ( basename ( name )) ) then write ( stderr , '(g0)' ) [ character ( len = 72 ) :: & & '<ERROR>the new directory basename must be an allowed ' , & & '       Fortran name. It must be composed of 1 to 63 ASCII' , & & '       characters and start with a letter and be composed' , & & '       entirely of alphanumeric characters [a-zA-Z0-9]' , & & '       and underscores.' ] stop 4 endif allocate ( fpm_new_settings :: cmd_settings ) if ( any ( specified ([ 'src ' , 'lib ' , 'app ' , 'test' ]) ) ) then cmd_settings = fpm_new_settings (& & backfill = lget ( 'backfill' ), & & name = name , & & with_executable = lget ( 'app' ), & & with_lib = any ([ lget ( 'lib' ), lget ( 'src' )]), & & with_test = lget ( 'test' ), & & verbose = lget ( 'verbose' ) ) else cmd_settings = fpm_new_settings (& & backfill = lget ( 'backfill' ) , & & name = name , & & with_executable = . true ., & & with_lib = . true ., & & with_test = . true ., & & verbose = lget ( 'verbose' ) ) endif case ( 'help' , 'manual' ) call set_args ( '& & --verbose F & & ' , help_help , version_text ) if ( size ( unnamed ). lt . 2 ) then if ( unnamed ( 1 ). eq . 'help' ) then unnamed = [ '   ' , 'fpm' ] else unnamed = manual endif elseif ( unnamed ( 2 ). eq . 'manual' ) then unnamed = manual endif widest = 256 allocate ( character ( len = widest ) :: help_text ( 0 )) do i = 2 , size ( unnamed ) select case ( unnamed ( i )) case ( '       ' ) case ( 'fpm    ' ) help_text = [ character ( len = widest ) :: help_text , help_fpm ] case ( 'new    ' ) help_text = [ character ( len = widest ) :: help_text , help_new ] case ( 'build  ' ) help_text = [ character ( len = widest ) :: help_text , help_build ] case ( 'install' ) help_text = [ character ( len = widest ) :: help_text , help_install ] case ( 'run    ' ) help_text = [ character ( len = widest ) :: help_text , help_run ] case ( 'test   ' ) help_text = [ character ( len = widest ) :: help_text , help_test ] case ( 'runner' ) help_text = [ character ( len = widest ) :: help_text , help_runner ] case ( 'list   ' ) help_text = [ character ( len = widest ) :: help_text , help_list ] case ( 'update ' ) help_text = [ character ( len = widest ) :: help_text , help_update ] case ( 'help   ' ) help_text = [ character ( len = widest ) :: help_text , help_help ] case ( 'version' ) help_text = [ character ( len = widest ) :: help_text , version_text ] case default help_text = [ character ( len = widest ) :: help_text , & & '<ERROR> unknown help topic \"' // trim ( unnamed ( i )) // '\"' ] !!& '<ERROR> unknown help topic \"'//trim(unnamed(i)).'not found in:',manual] end select enddo call printhelp ( help_text ) case ( 'install' ) call set_args ( '--release F --no-rebuild F --verbose F --prefix \" \" & & --list F & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --libdir \"lib\" --bindir \"bin\" --includedir \"include\"' , & help_install , version_text ) call check_build_vals () allocate ( install_settings ) install_settings = fpm_install_settings (& list = lget ( 'list' ), & build_name = val_build , & compiler = val_compiler , & no_rebuild = lget ( 'no-rebuild' ), & verbose = lget ( 'verbose' )) call get_char_arg ( install_settings % prefix , 'prefix' ) call get_char_arg ( install_settings % libdir , 'libdir' ) call get_char_arg ( install_settings % bindir , 'bindir' ) call get_char_arg ( install_settings % includedir , 'includedir' ) call move_alloc ( install_settings , cmd_settings ) case ( 'list' ) call set_args ( '& & --list F& & --verbose F& &' , help_list , version_text ) call printhelp ( help_list_nodash ) if ( lget ( 'list' )) then call printhelp ( help_list_dash ) endif case ( 'test' ) call set_args ( '& & --target \" \" & & --list F& & --release F& & --runner \" \" & & --compiler \"' // get_env ( 'FPM_COMPILER' , 'gfortran' ) // '\" & & --verbose F& & --' , help_test , version_text ) call check_build_vals () if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif if ( specified ( 'target' ) ) then call split ( sget ( 'target' ), tnames , delimiters = ' ,:' ) names = [ character ( len = max ( len ( names ), len ( tnames ))) :: names , tnames ] endif allocate ( fpm_test_settings :: cmd_settings ) val_runner = sget ( 'runner' ) cmd_settings = fpm_test_settings (& & args = remaining , & & build_name = val_build , & & compiler = val_compiler , & & example = . false ., & & list = lget ( 'list' ), & & name = names , & & runner = val_runner , & & verbose = lget ( 'verbose' ) ) case ( 'update' ) call set_args ( '--fetch-only F --verbose F --clean F' , & help_update , version_text ) if ( size ( unnamed ) . gt . 1 ) then names = unnamed ( 2 :) else names = [ character ( len = len ( names )) :: ] endif allocate ( fpm_update_settings :: cmd_settings ) cmd_settings = fpm_update_settings ( name = names , & fetch_only = lget ( 'fetch-only' ), verbose = lget ( 'verbose' ), & clean = lget ( 'clean' )) case default call set_args ( '& & --list F& & --verbose F& &' , help_fpm , version_text ) ! Note: will not get here if --version or --usage or --help ! is present on commandline help_text = help_usage if ( lget ( 'list' )) then help_text = help_list_dash elseif ( len_trim ( cmdarg ). eq . 0 ) then write ( stdout , '(*(a))' ) 'Fortran Package Manager:' write ( stdout , '(*(a))' ) ' ' call printhelp ( help_list_nodash ) else write ( stderr , '(*(a))' ) '<ERROR> unknown subcommand [' , & & trim ( cmdarg ), ']' call printhelp ( help_list_dash ) endif call printhelp ( help_text ) end select contains subroutine check_build_vals () val_compiler = sget ( 'compiler' ) if ( val_compiler . eq . '' ) then val_compiler = 'gfortran' endif val_build = trim ( merge ( 'release' , 'debug  ' , lget ( 'release' ))) end subroutine check_build_vals subroutine printhelp ( lines ) character ( len = :), intent ( in ), allocatable :: lines (:) integer :: iii , ii if ( allocated ( lines )) then ii = size ( lines ) if ( ii . gt . 0 . and . len ( lines ). gt . 0 ) then write ( stdout , '(g0)' )( trim ( lines ( iii )), iii = 1 , ii ) else write ( stdout , '(a)' ) '<WARNING> *printhelp* output requested is empty' endif endif end subroutine printhelp end subroutine get_command_line_settings","tags":"","loc":"proc/get_command_line_settings.html"},{"title":"parse_c_source – Fortran-lang/fpm","text":"public function parse_c_source(c_filename, error) result(c_source) Parsing of c source files The following statements are recognised and parsed: #include preprocessor statement Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) Contents Variables fh file_lines i n_include pass stat Source Code parse_c_source Variables Type Visibility Attributes Name Initial integer, public :: fh type( string_t ), public, allocatable :: file_lines (:) integer, public :: i integer, public :: n_include integer, public :: pass integer, public :: stat Source Code function parse_c_source ( c_filename , error ) result ( c_source ) character ( * ), intent ( in ) :: c_filename type ( srcfile_t ) :: c_source type ( error_t ), allocatable , intent ( out ) :: error integer :: fh , n_include , i , pass , stat type ( string_t ), allocatable :: file_lines (:) c_source % file_name = c_filename if ( str_ends_with ( lower ( c_filename ), \".c\" )) then c_source % unit_type = FPM_UNIT_CSOURCE elseif ( str_ends_with ( lower ( c_filename ), \".h\" )) then c_source % unit_type = FPM_UNIT_CHEADER end if allocate ( c_source % modules_used ( 0 )) allocate ( c_source % modules_provided ( 0 )) open ( newunit = fh , file = c_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) ! Ignore empty files, returned as FPM_UNIT_UNKNOW if ( len_trim ( string_cat ( file_lines , ' ' )) < 1 ) then c_source % unit_type = FPM_UNIT_UNKNOWN return end if c_source % digest = fnv_1a ( file_lines ) do pass = 1 , 2 n_include = 0 file_loop : do i = 1 , size ( file_lines ) ! Process 'INCLUDE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), '#include' ) == 1 . and . & index ( file_lines ( i )% s , '\"' ) > 0 ) then n_include = n_include + 1 if ( pass == 2 ) then c_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , c_filename , & 'unable to get c include file' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '\"' )) return end if end if end if end do file_loop if ( pass == 1 ) then allocate ( c_source % include_dependencies ( n_include )) end if end do end function parse_c_source","tags":"","loc":"proc/parse_c_source.html"},{"title":"parse_f_source – Fortran-lang/fpm","text":"public function parse_f_source(f_filename, error) result(f_source) Parsing of free-form fortran source files The following statements are recognised and parsed: Module / submodule / program declaration Module use statement include statement Note Intrinsic modules used by sources are not listed in\n the modules_used field of source objects. Note Submodules are treated as normal modules which use their\n corresponding parent modules. Parsing limitations Statements must not continued onto another line\n  except for an only: list in the use statement. This is supported: use my_module , only : & my_var , my_function , my_subroutine This is NOT supported: use & my_module Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: f_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) Contents Variables fh file_lines i ic j mod_name n_include n_mod n_use pass stat temp_string Functions validate_name Source Code parse_f_source Variables Type Visibility Attributes Name Initial integer, public :: fh type( string_t ), public, allocatable :: file_lines (:) integer, public :: i integer, public :: ic integer, public :: j character(len=:), public, allocatable :: mod_name integer, public :: n_include integer, public :: n_mod integer, public :: n_use integer, public :: pass integer, public :: stat character(len=:), public, allocatable :: temp_string Functions function validate_name(name) result(valid) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value logical Source Code function parse_f_source ( f_filename , error ) result ( f_source ) character ( * ), intent ( in ) :: f_filename type ( srcfile_t ) :: f_source type ( error_t ), allocatable , intent ( out ) :: error integer :: stat integer :: fh , n_use , n_include , n_mod , i , j , ic , pass type ( string_t ), allocatable :: file_lines (:) character (:), allocatable :: temp_string , mod_name f_source % file_name = f_filename open ( newunit = fh , file = f_filename , status = 'old' ) file_lines = read_lines ( fh ) close ( fh ) ! Ignore empty files, returned as FPM_UNIT_UNKNOW if ( len_trim ( string_cat ( file_lines , ' ' )) < 1 ) return f_source % digest = fnv_1a ( file_lines ) do pass = 1 , 2 n_use = 0 n_include = 0 n_mod = 0 file_loop : do i = 1 , size ( file_lines ) ! Skip lines that are continued: not statements if ( i > 1 ) then ic = index ( file_lines ( i - 1 )% s , '!' ) if ( ic < 1 ) then ic = len ( file_lines ( i - 1 )% s ) end if temp_string = trim ( file_lines ( i - 1 )% s ( 1 : ic )) if ( len ( temp_string ) > 0 . and . index ( temp_string , '&' ) == len ( temp_string )) then cycle end if end if ! Process 'USE' statements if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'use ' ) == 1 . or . & index ( adjustl ( lower ( file_lines ( i )% s )), 'use::' ) == 1 ) then if ( index ( file_lines ( i )% s , '::' ) > 0 ) then temp_string = split_n ( file_lines ( i )% s , delims = ':' , n = 2 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , '::' )) return end if mod_name = split_n ( temp_string , delims = ' ,' , n = 1 , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) else mod_name = split_n ( file_lines ( i )% s , n = 2 , delims = ' ,' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find used module name' , i , & file_lines ( i )% s ) return end if mod_name = lower ( mod_name ) end if if (. not . validate_name ( mod_name )) then cycle end if if ( any ([( index ( mod_name , trim ( INTRINSIC_MODULE_NAMES ( j ))) > 0 , & j = 1 , size ( INTRINSIC_MODULE_NAMES ))])) then cycle end if n_use = n_use + 1 if ( pass == 2 ) then f_source % modules_used ( n_use )% s = mod_name end if end if ! Process 'INCLUDE' statements ic = index ( adjustl ( lower ( file_lines ( i )% s )), 'include' ) if ( ic == 1 ) then ic = index ( lower ( file_lines ( i )% s ), 'include' ) if ( index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), '\"' ) == 1 . or . & index ( adjustl ( file_lines ( i )% s ( ic + 7 :)), \"'\" ) == 1 ) then n_include = n_include + 1 if ( pass == 2 ) then f_source % include_dependencies ( n_include )% s = & & split_n ( file_lines ( i )% s , n = 2 , delims = \"'\" // '\"' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find include file name' , i , & file_lines ( i )% s ) return end if end if end if end if ! Extract name of module if is module if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'module ' ) == 1 ) then mod_name = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to find module name' , i , & file_lines ( i )% s ) return end if if ( mod_name == 'procedure' . or . & mod_name == 'subroutine' . or . & mod_name == 'function' . or . & scan ( mod_name , '=(' ) > 0 ) then ! Ignore these cases: ! module procedure * ! module function * ! module subroutine * ! module =* ! module (i) cycle end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for module' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 if ( pass == 2 ) then f_source % modules_provided ( n_mod ) = string_t ( mod_name ) end if f_source % unit_type = FPM_UNIT_MODULE end if ! Extract name of submodule if is submodule if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'submodule' ) == 1 ) then mod_name = split_n ( file_lines ( i )% s , n = 3 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule name' , i , & file_lines ( i )% s ) return end if if (. not . validate_name ( mod_name )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , mod_name )) return end if n_mod = n_mod + 1 temp_string = split_n ( file_lines ( i )% s , n = 2 , delims = '()' , stat = stat ) if ( stat /= 0 ) then call file_parse_error ( error , f_filename , & 'unable to get submodule ancestry' , i , & file_lines ( i )% s ) return end if f_source % unit_type = FPM_UNIT_SUBMODULE n_use = n_use + 1 if ( pass == 2 ) then if ( index ( temp_string , ':' ) > 0 ) then temp_string = temp_string ( index ( temp_string , ':' ) + 1 :) end if if (. not . validate_name ( temp_string )) then call file_parse_error ( error , f_filename , & 'empty or invalid name for submodule parent' , i , & file_lines ( i )% s , index ( file_lines ( i )% s , temp_string )) return end if f_source % modules_used ( n_use )% s = lower ( temp_string ) f_source % modules_provided ( n_mod )% s = lower ( mod_name ) end if end if ! Detect if contains a program !  (no modules allowed after program def) if ( index ( adjustl ( lower ( file_lines ( i )% s )), 'program ' ) == 1 ) then temp_string = lower ( split_n ( file_lines ( i )% s , n = 2 , delims = ' ' , stat = stat )) if ( stat == 0 ) then if ( scan ( temp_string , '=(' ) > 0 ) then ! Ignore: ! program =* ! program (i) =* cycle end if end if f_source % unit_type = FPM_UNIT_PROGRAM end if end do file_loop ! Default to subprogram unit type if ( f_source % unit_type == FPM_UNIT_UNKNOWN ) then f_source % unit_type = FPM_UNIT_SUBPROGRAM end if if ( pass == 1 ) then allocate ( f_source % modules_used ( n_use )) allocate ( f_source % include_dependencies ( n_include )) allocate ( f_source % modules_provided ( n_mod )) end if end do contains function validate_name ( name ) result ( valid ) character ( * ), intent ( in ) :: name logical :: valid integer :: i if ( len_trim ( name ) < 1 ) then valid = . false . return end if if ( lower ( name ( 1 : 1 )) < 'a' . or . & lower ( name ( 1 : 1 )) > 'z' ) then valid = . false . return end if do i = 1 , len ( name ) if (. not .( & ( name ( i : i ) >= '0' . and . name ( i : i ) <= '9' ). or . & ( lower ( name ( i : i )) >= 'a' . and . lower ( name ( i : i )) <= 'z' ). or . & name ( i : i ) == '_' ) ) then valid = . false . return end if end do valid = . true . return end function validate_name end function parse_f_source","tags":"","loc":"proc/parse_f_source.html"},{"title":"add_executable_sources – Fortran-lang/fpm","text":"public subroutine add_executable_sources(sources, executables, scope, auto_discover, error) Add to sources using the executable and test entries in the manifest and\n applies any executable-specific overrides such as executable%name .\n Adds all sources (including modules) from each executable%source_dir Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) List of srcfile_t objects to append to. Allocated if not allocated class( executable_config_t ), intent(in) :: executables (:) List of executable_config_t entries from manifest integer, intent(in) :: scope Scope to apply to the discovered sources: either FPM_SCOPE_APP or FPM_SCOPE_TEST , see fpm_model logical, intent(in) :: auto_discover If .false. only executables and tests specified in the manifest are added to sources type( error_t ), intent(out), allocatable :: error Error handling Contents Variables exe_dirs exe_source i j Source Code add_executable_sources Variables Type Visibility Attributes Name Initial type( string_t ), public, allocatable :: exe_dirs (:) type( srcfile_t ), public :: exe_source integer, public :: i integer, public :: j Source Code subroutine add_executable_sources ( sources , executables , scope , auto_discover , error ) !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) !> List of `[[executable_config_t]]` entries from manifest class ( executable_config_t ), intent ( in ) :: executables (:) !> Scope to apply to the discovered sources: either `FPM_SCOPE_APP` or `FPM_SCOPE_TEST`, see [[fpm_model]] integer , intent ( in ) :: scope !> If `.false.` only executables and tests specified in the manifest are added to `sources` logical , intent ( in ) :: auto_discover !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i , j type ( string_t ), allocatable :: exe_dirs (:) type ( srcfile_t ) :: exe_source call get_executable_source_dirs ( exe_dirs , executables ) do i = 1 , size ( exe_dirs ) call add_sources_from_dir ( sources , exe_dirs ( i )% s , scope , & with_executables = auto_discover , recurse = . false ., error = error ) if ( allocated ( error )) then return end if end do exe_loop : do i = 1 , size ( executables ) ! Check if executable already discovered automatically !  and apply any overrides do j = 1 , size ( sources ) if ( basename ( sources ( j )% file_name , suffix = . true .) == executables ( i )% main . and .& canon_path ( dirname ( sources ( j )% file_name )) == & canon_path ( executables ( i )% source_dir ) ) then sources ( j )% exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if cycle exe_loop end if end do ! Add if not already discovered (auto_discovery off) exe_source = parse_source ( join_path ( executables ( i )% source_dir , executables ( i )% main ), error ) exe_source % exe_name = executables ( i )% name if ( allocated ( executables ( i )% link )) then exe_source % link_libraries = executables ( i )% link end if exe_source % unit_scope = scope if ( allocated ( error )) return if (. not . allocated ( sources )) then sources = [ exe_source ] else sources = [ sources , exe_source ] end if end do exe_loop end subroutine add_executable_sources","tags":"","loc":"proc/add_executable_sources.html"},{"title":"add_sources_from_dir – Fortran-lang/fpm","text":"public subroutine add_sources_from_dir(sources, directory, scope, with_executables, recurse, error) Add to sources by looking for source files in directory Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) List of srcfile_t objects to append to. Allocated if not allocated character(len=*), intent(in) :: directory Directory in which to search for source files integer, intent(in) :: scope Scope to apply to the discovered sources, see fpm_model for enumeration logical, intent(in), optional :: with_executables Executable sources (fortran program s) are ignored unless with_executables=.true. logical, intent(in), optional :: recurse Whether to recursively search subdirectories, default is .true. type( error_t ), intent(out), allocatable :: error Error handling Contents Variables dir_sources exclude_source existing_src_files file_names i is_source src_file_names Source Code add_sources_from_dir Variables Type Visibility Attributes Name Initial type( srcfile_t ), public, allocatable :: dir_sources (:) logical, public, allocatable :: exclude_source (:) type( string_t ), public, allocatable :: existing_src_files (:) type( string_t ), public, allocatable :: file_names (:) integer, public :: i logical, public, allocatable :: is_source (:) type( string_t ), public, allocatable :: src_file_names (:) Source Code subroutine add_sources_from_dir ( sources , directory , scope , with_executables , recurse , error ) !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated type ( srcfile_t ), allocatable , intent ( inout ), target :: sources (:) !> Directory in which to search for source files character ( * ), intent ( in ) :: directory !> Scope to apply to the discovered sources, see [[fpm_model]] for enumeration integer , intent ( in ) :: scope !> Executable sources (fortran `program`s) are ignored unless `with_executables=.true.` logical , intent ( in ), optional :: with_executables !> Whether to recursively search subdirectories, default is `.true.` logical , intent ( in ), optional :: recurse !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: i logical , allocatable :: is_source (:), exclude_source (:) type ( string_t ), allocatable :: file_names (:) type ( string_t ), allocatable :: src_file_names (:) type ( string_t ), allocatable :: existing_src_files (:) type ( srcfile_t ), allocatable :: dir_sources (:) ! Scan directory for sources call list_files ( directory , file_names , recurse = merge ( recurse ,. true ., present ( recurse ))) if ( allocated ( sources )) then allocate ( existing_src_files ( size ( sources ))) do i = 1 , size ( sources ) existing_src_files ( i )% s = canon_path ( sources ( i )% file_name ) end do else allocate ( existing_src_files ( 0 )) end if is_source = [(. not .( canon_path ( file_names ( i )% s ) . in . existing_src_files ) . and . & ( str_ends_with ( lower ( file_names ( i )% s ), fortran_suffixes ) . or . & str_ends_with ( lower ( file_names ( i )% s ),[ \".c\" , \".h\" ]) ), i = 1 , size ( file_names ))] src_file_names = pack ( file_names , is_source ) allocate ( dir_sources ( size ( src_file_names ))) allocate ( exclude_source ( size ( src_file_names ))) do i = 1 , size ( src_file_names ) dir_sources ( i ) = parse_source ( src_file_names ( i )% s , error ) if ( allocated ( error )) return dir_sources ( i )% unit_scope = scope ! Exclude executables unless specified otherwise exclude_source ( i ) = ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM ) if ( dir_sources ( i )% unit_type == FPM_UNIT_PROGRAM . and . & & present ( with_executables )) then if ( with_executables ) then exclude_source ( i ) = . false . end if end if end do if (. not . allocated ( sources )) then sources = pack ( dir_sources ,. not . exclude_source ) else sources = [ sources , pack ( dir_sources ,. not . exclude_source )] end if end subroutine add_sources_from_dir","tags":"","loc":"proc/add_sources_from_dir.html"},{"title":"show_model – Fortran-lang/fpm","text":"public subroutine show_model(model) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(in) :: model Contents None","tags":"","loc":"proc/show_model.html"},{"title":"add_dependency – Fortran-lang/fpm","text":"public subroutine add_dependency(target, dependency) Add pointer to dependeny in target%dependencies Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout) :: target type( build_target_t ), intent(in), target :: dependency Contents Source Code add_dependency Source Code subroutine add_dependency ( target , dependency ) type ( build_target_t ), intent ( inout ) :: target type ( build_target_t ) , intent ( in ), target :: dependency target % dependencies = [ target % dependencies , build_target_ptr ( dependency )] end subroutine add_dependency","tags":"","loc":"proc/add_dependency.html"},{"title":"add_target – Fortran-lang/fpm","text":"public subroutine add_target(targets, type, output_file, source, link_libraries) Allocate a new target and append to target list Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), allocatable :: targets (:) integer, intent(in) :: type character(len=*), intent(in) :: output_file type( srcfile_t ), intent(in), optional :: source type( string_t ), intent(in), optional :: link_libraries (:) Contents Variables i new_target temp Source Code add_target Variables Type Visibility Attributes Name Initial integer, public :: i type( build_target_t ), public, pointer :: new_target type( build_target_ptr ), public, allocatable :: temp (:) Source Code subroutine add_target ( targets , type , output_file , source , link_libraries ) type ( build_target_ptr ), allocatable , intent ( inout ) :: targets (:) integer , intent ( in ) :: type character ( * ), intent ( in ) :: output_file type ( srcfile_t ), intent ( in ), optional :: source type ( string_t ), intent ( in ), optional :: link_libraries (:) integer :: i type ( build_target_ptr ), allocatable :: temp (:) type ( build_target_t ), pointer :: new_target if (. not . allocated ( targets )) allocate ( targets ( 0 )) ! Check for duplicate outputs do i = 1 , size ( targets ) if ( targets ( i )% ptr % output_file == output_file ) then write ( * , * ) 'Error while building target list: duplicate output object \"' ,& output_file , '\"' if ( present ( source )) write ( * , * ) ' Source file: \"' , source % file_name , '\"' stop 1 end if end do allocate ( new_target ) new_target % target_type = type new_target % output_file = output_file if ( present ( source )) new_target % source = source if ( present ( link_libraries )) new_target % link_libraries = link_libraries allocate ( new_target % dependencies ( 0 )) targets = [ targets , build_target_ptr ( new_target )] end subroutine add_target","tags":"","loc":"proc/add_target.html"},{"title":"resolve_module_dependencies – Fortran-lang/fpm","text":"public subroutine resolve_module_dependencies(targets, error) Add dependencies to source-based targets ( FPM_TARGET_OBJECT ) \n based on any modules used by the corresponding source file. Source file scoping Source files are assigned a scope of either FPM_SCOPE_LIB , FPM_SCOPE_APP or FPM_SCOPE_TEST . The scope controls which\n modules may be used by the source file: Library sources ( FPM_SCOPE_LIB ) may only use modules\n   also with library scope. This includes library modules\n   from dependencies. Executable sources ( FPM_SCOPE_APP , FPM_SCOPE_TEST ) may use\n   library modules (including dependencies) as well as any modules\n   corresponding to source files in the same directory as the \n   executable source. Warning If a module used by a source file cannot be resolved to\n a source file in the package of the correct scope, then a fatal error is returned by the procedure and model construction fails. Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) type( error_t ), intent(out), allocatable :: error Contents Variables dep i j Source Code resolve_module_dependencies Variables Type Visibility Attributes Name Initial type( build_target_ptr ), public :: dep integer, public :: i integer, public :: j Source Code subroutine resolve_module_dependencies ( targets , error ) type ( build_target_ptr ), intent ( inout ), target :: targets (:) type ( error_t ), allocatable , intent ( out ) :: error type ( build_target_ptr ) :: dep integer :: i , j do i = 1 , size ( targets ) if (. not . allocated ( targets ( i )% ptr % source )) cycle do j = 1 , size ( targets ( i )% ptr % source % modules_used ) if ( targets ( i )% ptr % source % modules_used ( j )% s . in . targets ( i )% ptr % source % modules_provided ) then ! Dependency satisfied in same file, skip cycle end if if ( any ( targets ( i )% ptr % source % unit_scope == & [ FPM_SCOPE_APP , FPM_SCOPE_EXAMPLE , FPM_SCOPE_TEST ])) then dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s , & include_dir = dirname ( targets ( i )% ptr % source % file_name )) else dep % ptr => & find_module_dependency ( targets , targets ( i )% ptr % source % modules_used ( j )% s ) end if if (. not . associated ( dep % ptr )) then call fatal_error ( error , & 'Unable to find source for module dependency: \"' // & targets ( i )% ptr % source % modules_used ( j )% s // & '\" used by \"' // targets ( i )% ptr % source % file_name // '\"' ) return end if call add_dependency ( targets ( i )% ptr , dep % ptr ) end do end do end subroutine resolve_module_dependencies","tags":"","loc":"proc/resolve_module_dependencies.html"},{"title":"resolve_target_linking – Fortran-lang/fpm","text":"public subroutine resolve_target_linking(targets) For libraries and executables, build a list of objects required for linking stored in target%link_objects Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) Contents Variables i Subroutines get_link_objects Source Code resolve_target_linking Variables Type Visibility Attributes Name Initial integer, public :: i Subroutines recursive subroutine get_link_objects(link_objects, target, is_exe) Wrapper to build link object list Read more… Arguments Type Intent Optional Attributes Name type( string_t ), intent(inout), allocatable :: link_objects (:) type( build_target_t ), intent(in) :: target logical, intent(in) :: is_exe Source Code subroutine resolve_target_linking ( targets ) type ( build_target_ptr ), intent ( inout ), target :: targets (:) integer :: i do i = 1 , size ( targets ) associate ( target => targets ( i )% ptr ) allocate ( target % link_objects ( 0 )) if ( target % target_type == FPM_TARGET_ARCHIVE ) then call get_link_objects ( target % link_objects , target , is_exe = . false .) else if ( target % target_type == FPM_TARGET_EXECUTABLE ) then call get_link_objects ( target % link_objects , target , is_exe = . true .) end if end associate end do contains !> Wrapper to build link object list !> !>  For libraries: just list dependency objects of lib target !> !>  For executables: need to recursively discover non-library !>   dependency objects. (i.e. modules in same dir as program) !> recursive subroutine get_link_objects ( link_objects , target , is_exe ) type ( string_t ), intent ( inout ), allocatable :: link_objects (:) type ( build_target_t ), intent ( in ) :: target logical , intent ( in ) :: is_exe integer :: i type ( string_t ) :: temp_str if (. not . allocated ( target % dependencies )) return do i = 1 , size ( target % dependencies ) associate ( dep => target % dependencies ( i )% ptr ) if (. not . allocated ( dep % source )) cycle ! Skip library dependencies for executable targets !  since the library archive will always be linked if ( is_exe . and .( dep % source % unit_scope == FPM_SCOPE_LIB )) cycle ! Skip if dependency object already listed if ( dep % output_file . in . link_objects ) cycle ! Add dependency object file to link object list temp_str % s = dep % output_file link_objects = [ link_objects , temp_str ] ! For executable objects, also need to include non-library !  dependencies from dependencies (recurse) if ( is_exe ) call get_link_objects ( link_objects , dep , is_exe = . true .) end associate end do end subroutine get_link_objects end subroutine resolve_target_linking","tags":"","loc":"proc/resolve_target_linking.html"},{"title":"targets_from_sources – Fortran-lang/fpm","text":"public subroutine targets_from_sources(model, sources) Constructs a list of build targets from a list of source files Source-target mapping One compiled object target ( FPM_TARGET_OBJECT ) is generated for each\n non-executable source file ( FPM_UNIT_MODULE , FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE ). If any source file has scope FPM_SCOPE_LIB ( i.e. there are library sources)\n then the first target in the target list will be a library archive target\n ( FPM_TARGET_ARCHIVE ). The archive target will have a dependency on every\n compiled object target corresponding to a library source file. One compiled object target ( FPM_TARGET_OBJECT ) and one executable target ( FPM_TARGET_EXECUTABLE ) is\n generated for each exectuable source file ( FPM_UNIT_PROGRAM ). The exectuble target\n always has a dependency on the corresponding compiled object target. If there\n is a library, then the executable target has an additional dependency on the library\n archive target. Note Inter-object dependencies based on modules used and provided are generated separately\n in resolve_module_dependencies after all targets have been enumerated. Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout), target :: model The package model within which to construct the target list type( srcfile_t ), intent(in) :: sources (:) The list of sources from which to construct the target list Contents Variables dep exe_dir i with_lib xsuffix Functions get_object_name Source Code targets_from_sources Variables Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: dep character(len=:), public, allocatable :: exe_dir integer, public :: i logical, public :: with_lib character(len=:), public, allocatable :: xsuffix Functions function get_object_name(source) result(object_file) Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(in) :: source Return Value character(len=:),\n  allocatable Source Code subroutine targets_from_sources ( model , sources ) !> The package model within which to construct the target list type ( fpm_model_t ), intent ( inout ), target :: model !> The list of sources from which to construct the target list type ( srcfile_t ), intent ( in ) :: sources (:) integer :: i character (:), allocatable :: xsuffix , exe_dir type ( build_target_t ), pointer :: dep logical :: with_lib if ( get_os_type () == OS_WINDOWS ) then xsuffix = '.exe' else xsuffix = '' end if with_lib = any ([( sources ( i )% unit_scope == FPM_SCOPE_LIB , i = 1 , size ( sources ))]) if ( with_lib ) call add_target ( model % targets , type = FPM_TARGET_ARCHIVE ,& output_file = join_path ( model % output_directory ,& model % package_name , 'lib' // model % package_name // '.a' )) do i = 1 , size ( sources ) select case ( sources ( i )% unit_type ) case ( FPM_UNIT_MODULE , FPM_UNIT_SUBMODULE , FPM_UNIT_SUBPROGRAM , FPM_UNIT_CSOURCE ) call add_target ( model % targets , source = sources ( i ), & type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i ))) if ( with_lib . and . sources ( i )% unit_scope == FPM_SCOPE_LIB ) then ! Archive depends on object call add_dependency ( model % targets ( 1 )% ptr , model % targets ( size ( model % targets ))% ptr ) end if case ( FPM_UNIT_PROGRAM ) call add_target ( model % targets , type = FPM_TARGET_OBJECT ,& output_file = get_object_name ( sources ( i )), & source = sources ( i ) & ) if ( sources ( i )% unit_scope == FPM_SCOPE_APP ) then exe_dir = 'app' else if ( sources ( i )% unit_scope == FPM_SCOPE_EXAMPLE ) then exe_dir = 'example' else exe_dir = 'test' end if call add_target ( model % targets , type = FPM_TARGET_EXECUTABLE ,& link_libraries = sources ( i )% link_libraries , & output_file = join_path ( model % output_directory , exe_dir , & sources ( i )% exe_name // xsuffix )) ! Executable depends on object call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( size ( model % targets ) - 1 )% ptr ) if ( with_lib ) then ! Executable depends on library call add_dependency ( model % targets ( size ( model % targets ))% ptr , model % targets ( 1 )% ptr ) end if end select end do contains function get_object_name ( source ) result ( object_file ) ! Generate object target path from source name and model params ! ! type ( srcfile_t ), intent ( in ) :: source character (:), allocatable :: object_file integer :: i character ( 1 ), parameter :: filesep = '/' character (:), allocatable :: dir object_file = canon_path ( source % file_name ) ! Convert any remaining directory separators to underscores i = index ( object_file , filesep ) do while ( i > 0 ) object_file ( i : i ) = '_' i = index ( object_file , filesep ) end do object_file = join_path ( model % output_directory , model % package_name , object_file ) // '.o' end function get_object_name end subroutine targets_from_sources","tags":"","loc":"proc/targets_from_sources.html"},{"title":"add_compile_flag_defaults – Fortran-lang/fpm","text":"public subroutine add_compile_flag_defaults(build_name, compiler, model) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: build_name character(len=*), intent(in) :: compiler type( fpm_model_t ), intent(inout) :: model Contents Variables fflags mandatory modpath Source Code add_compile_flag_defaults Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: fflags character(len=:), public, allocatable :: mandatory character(len=:), public, allocatable :: modpath Source Code subroutine add_compile_flag_defaults ( build_name , compiler , model ) ! Choose compile flags based on cli settings & manifest inputs character ( len =* ), intent ( in ) :: build_name , compiler type ( fpm_model_t ), intent ( inout ) :: model ! could just be a function to return a string instead of passing model ! but likely to change other components like matching C compiler character ( len = :), allocatable :: fflags ! optional flags that might be overridden by user character ( len = :), allocatable :: modpath character ( len = :), allocatable :: mandatory ! flags required for fpm to function properly; ! ie. add module path and module include directory as appropriate ! special reserved names \"debug\" and \"release\" are for supported compilers with no user-specified compile or load flags ! vendor            Fortran   C         Module output   Module include OpenMP    Free for OSS !                   compiler  compiler  directory       directory ! Gnu               gfortran   gcc     -J              -I            -fopenmp   X ! Intel             ifort      icc     -module         -I            -qopenmp   X ! Intel(Windows)    ifort      icc     /module:path    /I            /Qopenmp   X ! Intel oneAPI      ifx        icx     -module         -I            -qopenmp   X ! PGI               pgfortran  pgcc    -module         -I            -mp        X ! NVIDIA            nvfortran  nvc     -module         -I            -mp        X ! LLVM flang        flang      clang   -module         -I            -mp        X ! LFortran          lfortran   ---     ?               ?             ?          X ! Lahey/Futjitsu    lfc        ?       -M              -I            -openmp    ? ! NAG               nagfor     ?       -mdir           -I            -openmp    x ! Cray              crayftn    craycc  -J              -I            -homp      ? ! IBM               xlf90      ?       -qmoddir        -I            -qsmp      X ! Oracle/Sun        ?          ?       -moddir=        -M            -xopenmp   ? ! Silverfrost FTN95 ftn95      ?       ?               /MOD_PATH     ?          ? ! Elbrus            ?          lcc     -J              -I            -fopenmp   ? ! Hewlett Packard   ?          ?       ?               ?             ?          discontinued ! Watcom            ?          ?       ?               ?             ?          discontinued ! PathScale         ?          ?       -module         -I            -mp        discontinued ! G95               ?          ?       -fmod=          -I            -fopenmp   discontinued ! Open64            ?          ?       -module         -I            -mp        discontinued ! Unisys            ?          ?       ?               ?             ?          discontinued modpath = join_path ( model % output_directory , model % package_name ) fflags = '' mandatory = '' select case ( build_name // '_' // compiler ) case ( 'release_caf' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -funroll-loops& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_caf' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -fbacktrace& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_gfortran' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -funroll-loops& & -fcoarray=single& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_gfortran' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -fbacktrace& & -fcoarray=single& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_f95' ) fflags = '& & -O3& & -Wimplicit-interface& & -fPIC& & -fmax-errors=1& & -ffast-math& & -funroll-loops& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_f95' ) fflags = '& & -Wall& & -Wextra& & -Wimplicit-interface& & -fPIC -fmax-errors=1& & -g& & -fbounds-check& & -fcheck-array-temporaries& & -Wno-maybe-uninitialized -Wno-uninitialized& & -fbacktrace& &' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_nvfortran' ) fflags = '& & -Mbackslash& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_nvfortran' ) fflags = '& & -Minform=inform& & -Mbackslash& & -g& & -Mbounds& & -Mchkptr& & -Mchkstk& & -traceback& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_ifort' ) fflags = '& & -fp-model precise& & -pc 64& & -align all& & -error-limit 1& & -reentrancy threaded& & -nogen-interfaces& & -assume byterecl& & -assume nounderscore& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_ifort' ) fflags = '& & -warn all& & -check:all:noarg_temp_created& & -error-limit 1& & -O0& & -g& & -assume byterecl& & -traceback& &' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_ifx' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_ifx' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_pgfortran' , 'release_pgf90' , 'release_pgf95' ) ! Portland Group F90/F95 compilers fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_pgfortran' , 'debug_pgf90' , 'debug_pgf95' ) ! Portland Group F90/F95 compilers fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_flang' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'debug_flang' ) fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath case ( 'release_lfc' ) fflags = ' ' mandatory = ' -M ' // modpath // ' -I ' // modpath case ( 'debug_lfc' ) fflags = ' ' mandatory = ' -M ' // modpath // ' -I ' // modpath case ( 'release_nagfor' ) fflags = ' & & -O4& & -coarray=single& & -PIC& &' mandatory = ' -mdir ' // modpath // ' -I ' // modpath ! case ( 'debug_nagfor' ) fflags = '& & -g& & -C=all& & -O0& & -gline& & -coarray=single& & -PIC& &' mandatory = ' -mdir ' // modpath // ' -I ' // modpath ! case ( 'release_crayftn' ) fflags = ' ' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'debug_crayftn' ) fflags = ' ' mandatory = ' -J ' // modpath // ' -I ' // modpath case ( 'release_xlf90' ) fflags = ' ' mandatory = ' -qmoddir ' // modpath // ' -I ' // modpath case ( 'debug_xlf90' ) fflags = ' ' mandatory = ' -qmoddir ' // modpath // ' -I ' // modpath case default fflags = ' ' mandatory = ' -module ' // modpath // ' -I ' // modpath write ( * , * ) '<WARNING> unknown compiler (' , compiler , ')' write ( * , * ) '          and build name (' , build_name , ')' write ( * , * ) '          combination.' write ( * , * ) '          known compilers are gfortran, nvfortran, ifort' end select model % fortran_compile_flags = fflags // ' ' // mandatory end subroutine add_compile_flag_defaults","tags":"","loc":"proc/add_compile_flag_defaults.html"},{"title":"build_model – Fortran-lang/fpm","text":"public subroutine build_model(model, settings, package, error) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(out) :: model type( fpm_build_settings ), intent(in) :: settings type( package_config_t ), intent(in) :: package type( error_t ), intent(out), allocatable :: error Contents Variables dependency i lib_dir manifest package_list Source Code build_model Variables Type Visibility Attributes Name Initial type( package_config_t ), public :: dependency integer, public :: i character(len=:), public, allocatable :: lib_dir character(len=:), public, allocatable :: manifest type( string_t ), public, allocatable :: package_list (:) Source Code subroutine build_model ( model , settings , package , error ) ! Constructs a valid fpm model from command line settings and toml manifest ! type ( fpm_model_t ), intent ( out ) :: model type ( fpm_build_settings ), intent ( in ) :: settings type ( package_config_t ), intent ( in ) :: package type ( error_t ), allocatable , intent ( out ) :: error type ( string_t ), allocatable :: package_list (:) integer :: i type ( package_config_t ) :: dependency character ( len = :), allocatable :: manifest , lib_dir if ( settings % verbose ) then write ( * , * ) '<INFO>BUILD_NAME:' , settings % build_name write ( * , * ) '<INFO>COMPILER:  ' , settings % compiler endif model % package_name = package % name if ( allocated ( package % build % link )) then model % link_libraries = package % build % link else allocate ( model % link_libraries ( 0 )) end if call new_dependency_tree ( model % deps , cache = join_path ( \"build\" , \"cache.toml\" )) call model % deps % add ( package , error ) if ( allocated ( error )) return allocate ( package_list ( 1 )) package_list ( 1 )% s = package % name if ( settings % compiler . eq . '' ) then model % fortran_compiler = 'gfortran' else model % fortran_compiler = settings % compiler endif model % output_directory = join_path ( 'build' , basename ( model % fortran_compiler ) // '_' // settings % build_name ) call add_compile_flag_defaults ( settings % build_name , basename ( model % fortran_compiler ), model ) model % link_flags = '' ! Add sources from executable directories if ( is_dir ( 'app' ) . and . package % build % auto_executables ) then call add_sources_from_dir ( model % sources , 'app' , FPM_SCOPE_APP , & with_executables = . true ., error = error ) if ( allocated ( error )) then return end if end if if ( is_dir ( 'example' ) . and . package % build % auto_examples ) then call add_sources_from_dir ( model % sources , 'example' , FPM_SCOPE_EXAMPLE , & with_executables = . true ., error = error ) if ( allocated ( error )) then return end if end if if ( is_dir ( 'test' ) . and . package % build % auto_tests ) then call add_sources_from_dir ( model % sources , 'test' , FPM_SCOPE_TEST , & with_executables = . true ., error = error ) if ( allocated ( error )) then return endif end if if ( allocated ( package % executable )) then call add_executable_sources ( model % sources , package % executable , FPM_SCOPE_APP , & auto_discover = package % build % auto_executables , & error = error ) if ( allocated ( error )) then return end if end if if ( allocated ( package % example )) then call add_executable_sources ( model % sources , package % example , FPM_SCOPE_EXAMPLE , & auto_discover = package % build % auto_examples , & error = error ) if ( allocated ( error )) then return end if end if if ( allocated ( package % test )) then call add_executable_sources ( model % sources , package % test , FPM_SCOPE_TEST , & auto_discover = package % build % auto_tests , & error = error ) if ( allocated ( error )) then return endif endif do i = 1 , model % deps % ndep associate ( dep => model % deps % dep ( i )) manifest = join_path ( dep % proj_dir , \"fpm.toml\" ) call get_package_data ( dependency , manifest , error , & apply_defaults = . true .) if ( allocated ( error )) exit if ( allocated ( dependency % library )) then lib_dir = join_path ( dep % proj_dir , dependency % library % source_dir ) call add_sources_from_dir ( model % sources , lib_dir , FPM_SCOPE_LIB , & error = error ) if ( allocated ( error )) exit end if if ( allocated ( dependency % build % link )) then model % link_libraries = [ model % link_libraries , dependency % build % link ] end if end associate end do if ( allocated ( error )) return call targets_from_sources ( model , model % sources ) do i = 1 , size ( model % link_libraries ) model % link_flags = model % link_flags // \" -l\" // model % link_libraries ( i )% s end do if ( model % targets ( 1 )% ptr % target_type == FPM_TARGET_ARCHIVE ) then model % library_file = model % targets ( 1 )% ptr % output_file end if call resolve_module_dependencies ( model % targets , error ) call resolve_target_linking ( model % targets ) end subroutine build_model","tags":"","loc":"proc/build_model.html"},{"title":"cmd_build – Fortran-lang/fpm","text":"public subroutine cmd_build(settings) Arguments Type Intent Optional Attributes Name type( fpm_build_settings ), intent(in) :: settings Contents Variables error i model package Variables Type Visibility Attributes Name Initial type( error_t ), public, allocatable :: error integer, public :: i type( fpm_model_t ), public :: model type( package_config_t ), public :: package","tags":"","loc":"proc/cmd_build.html"},{"title":"cmd_run – Fortran-lang/fpm","text":"public subroutine cmd_run(settings, test) Arguments Type Intent Optional Attributes Name class( fpm_run_settings ), intent(in) :: settings logical, intent(in) :: test Contents Variables LINE_WIDTH col_width error exe_cmd exe_source exe_target executables found i j model nCol package run_scope Source Code cmd_run Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_WIDTH = 80 integer, public :: col_width type( error_t ), public, allocatable :: error type( string_t ), public :: exe_cmd type( srcfile_t ), public, pointer :: exe_source type( build_target_t ), public, pointer :: exe_target type( string_t ), public, allocatable :: executables (:) logical, public :: found (size(settings%name)) integer, public :: i integer, public :: j type( fpm_model_t ), public :: model integer, public :: nCol type( package_config_t ), public :: package integer, public :: run_scope Source Code subroutine cmd_run ( settings , test ) class ( fpm_run_settings ), intent ( in ) :: settings logical , intent ( in ) :: test integer , parameter :: LINE_WIDTH = 80 integer :: i , j , col_width , nCol logical :: found ( size ( settings % name )) type ( error_t ), allocatable :: error type ( package_config_t ) :: package type ( fpm_model_t ) :: model type ( string_t ) :: exe_cmd type ( string_t ), allocatable :: executables (:) type ( build_target_t ), pointer :: exe_target type ( srcfile_t ), pointer :: exe_source integer :: run_scope call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if call build_model ( model , settings % fpm_build_settings , package , error ) if ( allocated ( error )) then print '(a)' , error % message error stop 1 end if if ( test ) then run_scope = FPM_SCOPE_TEST else run_scope = merge ( FPM_SCOPE_EXAMPLE , FPM_SCOPE_APP , settings % example ) end if ! Enumerate executable targets to run col_width = - 1 found (:) = . false . allocate ( executables ( 0 )) do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == run_scope ) then col_width = max ( col_width , len ( basename ( exe_target % output_file )) + 2 ) if ( size ( settings % name ) == 0 ) then exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] else do j = 1 , size ( settings % name ) if ( trim ( settings % name ( j )) == exe_source % exe_name ) then found ( j ) = . true . exe_cmd % s = exe_target % output_file executables = [ executables , exe_cmd ] end if end do end if end if end if end do ! Check if any apps/tests were found if ( col_width < 0 ) then if ( test ) then write ( stderr , * ) 'No tests to run' else write ( stderr , * ) 'No executables to run' end if stop end if ! Check all names are valid if ( any (. not . found )) then write ( stderr , '(A)' , advance = \"no\" ) 'fpm::run<ERROR> specified names ' do j = 1 , size ( settings % name ) if (. not . found ( j )) write ( stderr , '(A)' , advance = \"no\" ) '\"' // trim ( settings % name ( j )) // '\" ' end do write ( stderr , '(A)' ) 'not found.' write ( stderr , * ) j = 1 nCol = LINE_WIDTH / col_width write ( stderr , * ) 'Available names:' do i = 1 , size ( model % targets ) exe_target => model % targets ( i )% ptr if ( exe_target % target_type == FPM_TARGET_EXECUTABLE . and . & allocated ( exe_target % dependencies )) then exe_source => exe_target % dependencies ( 1 )% ptr % source if ( exe_source % unit_scope == run_scope ) then write ( stderr , '(A)' , advance = ( merge ( \"yes\" , \"no \" , modulo ( j , nCol ) == 0 ))) & & [ character ( len = col_width ) :: basename ( exe_target % output_file )] j = j + 1 end if end if end do write ( stderr , * ) stop 1 end if call build_package ( model ) do i = 1 , size ( executables ) if ( settings % list ) then write ( stderr , * ) executables ( i )% s else if ( exists ( executables ( i )% s )) then if ( settings % runner . ne . ' ' ) then call run ( settings % runner // ' ' // executables ( i )% s // \" \" // settings % args ) else call run ( executables ( i )% s // \" \" // settings % args ) endif else write ( stderr , * ) 'fpm::run<ERROR>' , executables ( i )% s , ' not found' stop 1 end if end if end do end subroutine cmd_run","tags":"","loc":"proc/cmd_run.html"},{"title":"get_env – Fortran-lang/fpm","text":"public function get_env(NAME, DEFAULT) result(VALUE) !print , NAME, ” is not defined in the environment. Strange…”\n!print , “This processor doesn’t support environment variables. Boooh!” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: NAME character(len=*), intent(in), optional :: DEFAULT Return Value character(len=:),\n  allocatable Contents Variables howbig length stat Source Code get_env Variables Type Visibility Attributes Name Initial integer, public :: howbig integer, public :: length integer, public :: stat Source Code function get_env ( NAME , DEFAULT ) result ( VALUE ) implicit none character ( len =* ), intent ( in ) :: NAME character ( len =* ), intent ( in ), optional :: DEFAULT character ( len = :), allocatable :: VALUE integer :: howbig integer :: stat integer :: length ! get length required to hold value length = 0 if ( NAME . ne . '' ) then call get_environment_variable ( NAME , length = howbig , status = stat , trim_name = . true .) select case ( stat ) case ( 1 ) !*!print *, NAME, \" is not defined in the environment. Strange...\" VALUE = '' case ( 2 ) !*!print *, \"This processor doesn't support environment variables. Boooh!\" VALUE = '' case default ! make string to hold value of sufficient size allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) ! get value call get_environment_variable ( NAME , VALUE , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else VALUE = '' endif if ( VALUE . eq . '' . and . present ( DEFAULT )) VALUE = DEFAULT end function get_env","tags":"","loc":"proc/get_env.html"},{"title":"get_os_type – Fortran-lang/fpm","text":"public function get_os_type() result(r) Determine the OS type Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN,\n OS_SOLARIS, OS_FREEBSD. At first, the environment variable OS is checked, which is usually\n found on Windows. Then, OSTYPE is read in and compared with common\n names. If this fails too, check the existence of files that can be\n found on specific system types only. Returns OS_UNKNOWN if the operating system cannot be determined. Arguments None Return Value integer Contents Variables file_exists length rc val Source Code get_os_type Variables Type Visibility Attributes Name Initial logical, public :: file_exists integer, public :: length integer, public :: rc character(len=32), public :: val Source Code integer function get_os_type () result ( r ) !! Determine the OS type !! !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN, !! OS_SOLARIS, OS_FREEBSD. !! !! At first, the environment variable `OS` is checked, which is usually !! found on Windows. Then, `OSTYPE` is read in and compared with common !! names. If this fails too, check the existence of files that can be !! found on specific system types only. !! !! Returns OS_UNKNOWN if the operating system cannot be determined. character ( len = 32 ) :: val integer :: length , rc logical :: file_exists r = OS_UNKNOWN ! Check environment variable `OS`. call get_environment_variable ( 'OS' , val , length , rc ) if ( rc == 0 . and . length > 0 . and . index ( val , 'Windows_NT' ) > 0 ) then r = OS_WINDOWS return end if ! Check environment variable `OSTYPE`. call get_environment_variable ( 'OSTYPE' , val , length , rc ) if ( rc == 0 . and . length > 0 ) then ! Linux if ( index ( val , 'linux' ) > 0 ) then r = OS_LINUX return end if ! macOS if ( index ( val , 'darwin' ) > 0 ) then r = OS_MACOS return end if ! Windows, MSYS, MinGW, Git Bash if ( index ( val , 'win' ) > 0 . or . index ( val , 'msys' ) > 0 ) then r = OS_WINDOWS return end if ! Cygwin if ( index ( val , 'cygwin' ) > 0 ) then r = OS_CYGWIN return end if ! Solaris, OpenIndiana, ... if ( index ( val , 'SunOS' ) > 0 . or . index ( val , 'solaris' ) > 0 ) then r = OS_SOLARIS return end if ! FreeBSD if ( index ( val , 'FreeBSD' ) > 0 . or . index ( val , 'freebsd' ) > 0 ) then r = OS_FREEBSD return end if end if ! Linux inquire ( file = '/etc/os-release' , exist = file_exists ) if ( file_exists ) then r = OS_LINUX return end if ! macOS inquire ( file = '/usr/bin/sw_vers' , exist = file_exists ) if ( file_exists ) then r = OS_MACOS return end if ! FreeBSD inquire ( file = '/bin/freebsd-version' , exist = file_exists ) if ( file_exists ) then r = OS_FREEBSD return end if end function get_os_type","tags":"","loc":"proc/get_os_type.html"},{"title":"os_is_unix – Fortran-lang/fpm","text":"public function os_is_unix(os) result(unix) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: os Return Value logical Contents Variables build_os Source Code os_is_unix Variables Type Visibility Attributes Name Initial integer, public :: build_os Source Code logical function os_is_unix ( os ) result ( unix ) integer , intent ( in ), optional :: os integer :: build_os if ( present ( os )) then build_os = os else build_os = get_os_type () end if unix = os /= OS_WINDOWS end function os_is_unix","tags":"","loc":"proc/os_is_unix.html"},{"title":"run – Fortran-lang/fpm","text":"public subroutine run(cmd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd Contents Variables stat Source Code run Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine run ( cmd ) character ( len =* ), intent ( in ) :: cmd integer :: stat print * , '+ ' , cmd call execute_command_line ( cmd , exitstat = stat ) if ( stat /= 0 ) then print * , 'Command failed' error stop end if end subroutine run","tags":"","loc":"proc/run.html"},{"title":"f_string – Fortran-lang/fpm","text":"public function f_string(c_string) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c_string (:) Return Value character(len=:),\n  allocatable Contents Variables i n Source Code f_string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n Source Code function f_string ( c_string ) use iso_c_binding character ( len = 1 ), intent ( in ) :: c_string (:) character (:), allocatable :: f_string integer :: i , n i = 0 do while ( c_string ( i + 1 ) /= C_NULL_CHAR ) i = i + 1 end do n = i allocate ( character ( n ) :: f_string ) do i = 1 , n f_string ( i : i ) = c_string ( i ) end do end function f_string","tags":"","loc":"proc/f_string.html"},{"title":"lower – Fortran-lang/fpm","text":"public pure elemental function lower(str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Contents Variables i ibegin iend Source Code lower Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ibegin integer, public :: iend Source Code elemental pure function lower ( str , begin , end ) result ( string ) ! Changes a string to lowercase over specified range ! Author: John S. Urban ! License: Public Domain character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower","tags":"","loc":"proc/lower.html"},{"title":"string_array_contains – Fortran-lang/fpm","text":"public function string_array_contains(search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical Contents Variables i Source Code string_array_contains Variables Type Visibility Attributes Name Initial integer, public :: i Source Code logical function string_array_contains ( search_string , array ) ! Check if array of string_t contains a particular string ! character ( * ), intent ( in ) :: search_string type ( string_t ), intent ( in ) :: array (:) integer :: i string_array_contains = any ([( array ( i )% s == search_string , & i = 1 , size ( array ))]) end function string_array_contains","tags":"","loc":"proc/string_array_contains.html"},{"title":"string_cat – Fortran-lang/fpm","text":"public function string_cat(strings, delim) result(cat) Concatenate an array of type(string_t) into \n  a single character Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: strings (:) character(len=*), intent(in), optional :: delim Return Value character(len=:),\n  allocatable Contents Variables delim_str i n Source Code string_cat Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: delim_str integer, public :: i integer, public :: n Source Code function string_cat ( strings , delim ) result ( cat ) type ( string_t ), intent ( in ) :: strings (:) character ( * ), intent ( in ), optional :: delim character (:), allocatable :: cat integer :: i , n character (:), allocatable :: delim_str if ( size ( strings ) < 1 ) then cat = '' return end if if ( present ( delim )) then delim_str = delim else delim_str = '' end if cat = strings ( 1 )% s do i = 2 , size ( strings ) cat = cat // delim_str // strings ( i )% s end do end function string_cat","tags":"","loc":"proc/string_cat.html"},{"title":"split – Fortran-lang/fpm","text":"public subroutine split(input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Contents Variables dlim i10 i20 i30 ibegin icol icount idlim ifound ii iiii ilen imax inotnull ireturn iterm n nlls ordr Source Code split Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlim integer, public :: i10 integer, public :: i20 integer, public :: i30 integer, public, allocatable :: ibegin (:) integer, public :: icol integer, public :: icount integer, public :: idlim integer, public :: ifound integer, public :: ii integer, public :: iiii integer, public :: ilen integer, public :: imax integer, public :: inotnull integer, public :: ireturn integer, public, allocatable :: iterm (:) integer, public :: n character(len=:), public, allocatable :: nlls character(len=:), public, allocatable :: ordr Source Code subroutine split ( input_line , array , delimiters , order , nulls ) ! parse string on delimiter characters and store tokens into an allocatable array\" ! Author: John S. Urban ! License: Public Domain !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found select case ( ilen ) case ( 0 ) ! command was totally blank case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE end select select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo end subroutine split","tags":"","loc":"proc/split.html"},{"title":"fnv_1a – Fortran-lang/fpm","text":"public interface fnv_1a Contents Module Procedures fnv_1a_char fnv_1a_string_t Module Procedures private pure function fnv_1a_char(input, seed) result(hash) Hash a character(*) string of default kind Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input integer(kind=int64), intent(in), optional :: seed Return Value integer(kind=int64) private pure function fnv_1a_string_t(input, seed) result(hash) Hash a string_t array of default kind Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: input (:) integer(kind=int64), intent(in), optional :: seed Return Value integer(kind=int64)","tags":"","loc":"interface/fnv_1a.html"},{"title":"operator(.in.) – Fortran-lang/fpm","text":"public interface operator(.in.) Contents Module Procedures string_array_contains Module Procedures public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical","tags":"","loc":"interface/operator(.in.).html"},{"title":"resize – Fortran-lang/fpm","text":"public interface resize Contents Module Procedures resize_string Module Procedures private subroutine resize_string(list, n) Arguments Type Intent Optional Attributes Name type( string_t ), intent(inout), allocatable :: list (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"interface/resize.html"},{"title":"str – Fortran-lang/fpm","text":"public interface str Contents Module Procedures str_int str_int64 str_logical Module Procedures private pure function str_int(i) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=str_int_len(i)) private pure function str_int64(i) result(s) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=str_int64_len(i)) private pure function str_logical(l) result(s) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=str_logical_len(l))","tags":"","loc":"interface/str.html"},{"title":"str_ends_with – Fortran-lang/fpm","text":"public interface str_ends_with Contents Module Procedures str_ends_with_str str_ends_with_any Module Procedures private pure function str_ends_with_str(s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e Return Value logical private pure function str_ends_with_any(s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e (:) Return Value logical","tags":"","loc":"interface/str_ends_with.html"},{"title":"build_package – Fortran-lang/fpm","text":"public subroutine build_package(model) Top-level routine to build package described by model Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout) :: model Contents Variables i j queue schedule_ptr Source Code build_package Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j type( build_target_ptr ), public, allocatable :: queue (:) integer, public, allocatable :: schedule_ptr (:) Source Code subroutine build_package ( model ) type ( fpm_model_t ), intent ( inout ) :: model integer :: i , j type ( build_target_ptr ), allocatable :: queue (:) integer , allocatable :: schedule_ptr (:) ! Need to make output directory for include (mod) files if (. not . exists ( join_path ( model % output_directory , model % package_name ))) then call mkdir ( join_path ( model % output_directory , model % package_name )) end if ! Perform depth-first topological sort of targets do i = 1 , size ( model % targets ) call sort_target ( model % targets ( i )% ptr ) end do ! Construct build schedule queue call schedule_targets ( queue , schedule_ptr , model % targets ) ! Loop over parallel schedule regions do i = 1 , size ( schedule_ptr ) - 1 ! Build targets in schedule region i !$omp parallel do default(shared) do j = schedule_ptr ( i ),( schedule_ptr ( i + 1 ) - 1 ) call build_target ( model , queue ( j )% ptr ) end do end do end subroutine build_package","tags":"","loc":"proc/build_package.html"},{"title":"schedule_targets – Fortran-lang/fpm","text":"public subroutine schedule_targets(queue, schedule_ptr, targets) Construct a build schedule from the sorted targets. The schedule is broken into regions, described by schedule_ptr ,\n  where targets in each region can be compiled in parallel. Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(out), allocatable :: queue (:) integer, allocatable :: schedule_ptr (:) type( build_target_ptr ), intent(in) :: targets (:) Contents Variables i j n_schedule n_sorted Source Code schedule_targets Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: n_schedule integer, public :: n_sorted Source Code subroutine schedule_targets ( queue , schedule_ptr , targets ) type ( build_target_ptr ), allocatable , intent ( out ) :: queue (:) integer , allocatable :: schedule_ptr (:) type ( build_target_ptr ), intent ( in ) :: targets (:) integer :: i , j integer :: n_schedule , n_sorted n_schedule = 0 ! Number of schedule regions n_sorted = 0 ! Total number of targets to build do i = 1 , size ( targets ) if ( targets ( i )% ptr % sorted ) then n_sorted = n_sorted + 1 end if n_schedule = max ( n_schedule , targets ( i )% ptr % schedule ) end do allocate ( queue ( n_sorted )) allocate ( schedule_ptr ( n_schedule + 1 )) ! Construct the target queue and schedule region pointer n_sorted = 1 schedule_ptr ( n_sorted ) = 1 do i = 1 , n_schedule do j = 1 , size ( targets ) if ( targets ( j )% ptr % sorted ) then if ( targets ( j )% ptr % schedule == i ) then queue ( n_sorted )% ptr => targets ( j )% ptr n_sorted = n_sorted + 1 end if end if end do schedule_ptr ( i + 1 ) = n_sorted end do end subroutine schedule_targets","tags":"","loc":"proc/schedule_targets.html"},{"title":"sort_target – Fortran-lang/fpm","text":"public recursive subroutine sort_target(target) Topologically sort a target for scheduling by \n  recursing over its dependencies. Checks disk-cached source hashes to determine if objects are\n  up-to-date. Up-to-date sources are tagged as skipped. On completion, target should either be marked as \n sorted ( target%sorted=.true. ) or skipped ( target%skip=.true. ) If target is marked as sorted, target%schedule should be an \n integer greater than zero indicating the region for scheduling Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout), target :: target Contents Variables exe_obj fh i j stat Source Code sort_target Variables Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: exe_obj integer, public :: fh integer, public :: i integer, public :: j integer, public :: stat Source Code recursive subroutine sort_target ( target ) type ( build_target_t ), intent ( inout ), target :: target integer :: i , j , fh , stat type ( build_target_t ), pointer :: exe_obj ! Check if target has already been processed (as a dependency) if ( target % sorted . or . target % skip ) then return end if ! Check for a circular dependency ! (If target has been touched but not processed) if ( target % touched ) then write ( * , * ) '(!) Circular dependency found with: ' , target % output_file stop else target % touched = . true . ! Set touched flag end if ! Load cached source file digest if present if (. not . allocated ( target % digest_cached ) . and . & exists ( target % output_file ) . and . & exists ( target % output_file // '.digest' )) then allocate ( target % digest_cached ) open ( newunit = fh , file = target % output_file // '.digest' , status = 'old' ) read ( fh , * , iostat = stat ) target % digest_cached close ( fh ) if ( stat /= 0 ) then ! Cached digest is not recognized deallocate ( target % digest_cached ) end if end if if ( allocated ( target % source )) then ! Skip if target is source-based and source file is unmodified if ( allocated ( target % digest_cached )) then if ( target % digest_cached == target % source % digest ) target % skip = . true . end if elseif ( exists ( target % output_file )) then ! Skip if target is not source-based and already exists target % skip = . true . end if ! Loop over target dependencies target % schedule = 1 do i = 1 , size ( target % dependencies ) ! Sort dependency call sort_target ( target % dependencies ( i )% ptr ) if (. not . target % dependencies ( i )% ptr % skip ) then ! Can't skip target if any dependency is not skipped target % skip = . false . ! Set target schedule after all of its dependencies target % schedule = max ( target % schedule , target % dependencies ( i )% ptr % schedule + 1 ) end if end do ! Mark flag as processed: either sorted or skipped target % sorted = . not . target % skip end subroutine sort_target","tags":"","loc":"proc/sort_target.html"},{"title":"git_target_branch – Fortran-lang/fpm","text":"public function git_target_branch(url, branch) result(self) Target a branch in the git repository Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: branch Name of the branch of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_branch Source Code function git_target_branch ( url , branch ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Name of the branch of interest character ( len =* ), intent ( in ) :: branch !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % branch self % url = url self % object = branch end function git_target_branch","tags":"","loc":"proc/git_target_branch.html"},{"title":"git_target_default – Fortran-lang/fpm","text":"public function git_target_default(url) result(self) Default target Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository Return Value type( git_target_t ) New git target Contents Source Code git_target_default Source Code function git_target_default ( url ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % default self % url = url end function git_target_default","tags":"","loc":"proc/git_target_default.html"},{"title":"git_target_revision – Fortran-lang/fpm","text":"public function git_target_revision(url, sha1) result(self) Target a specific git revision Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: sha1 Commit hash of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_revision Source Code function git_target_revision ( url , sha1 ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Commit hash of interest character ( len =* ), intent ( in ) :: sha1 !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % revision self % url = url self % object = sha1 end function git_target_revision","tags":"","loc":"proc/git_target_revision.html"},{"title":"git_target_tag – Fortran-lang/fpm","text":"public function git_target_tag(url, tag) result(self) Target a git tag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: tag Tag name of interest Return Value type( git_target_t ) New git target Contents Source Code git_target_tag Source Code function git_target_tag ( url , tag ) result ( self ) !> Target URL of the git repository character ( len =* ), intent ( in ) :: url !> Tag name of interest character ( len =* ), intent ( in ) :: tag !> New git target type ( git_target_t ) :: self self % descriptor = git_descriptor % tag self % url = url self % object = tag end function git_target_tag","tags":"","loc":"proc/git_target_tag.html"},{"title":"checkout – Fortran-lang/fpm","text":"public subroutine checkout(self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error Contents Variables object stat Source Code checkout Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: object integer, public :: stat Source Code subroutine checkout ( self , local_path , error ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Error type ( error_t ), allocatable , intent ( out ) :: error integer :: stat character ( len = :), allocatable :: object if ( allocated ( self % object )) then object = self % object else object = 'HEAD' end if call execute_command_line ( \"git init \" // local_path , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while initiating git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" fetch --depth=1 \" // & self % url // \" \" // object , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while fetching git repository for remote dependency' ) return end if call execute_command_line ( \"git -C \" // local_path // \" checkout -qf FETCH_HEAD\" , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , 'Error while checking out git repository for remote dependency' ) return end if end subroutine checkout","tags":"","loc":"proc/checkout.html"},{"title":"git_revision – Fortran-lang/fpm","text":"public subroutine git_revision(local_path, object, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: local_path Local path to checkout in character(len=:), intent(out), allocatable :: object Git object reference type( error_t ), intent(out), allocatable :: error Error Contents Variables hexdigits iend iomsg istart line stat temp_file unit Source Code git_revision Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: hexdigits = '0123456789abcdef' integer, public :: iend character(len=:), public, allocatable :: iomsg integer, public :: istart character(len=:), public, allocatable :: line integer, public :: stat character(len=:), public, allocatable :: temp_file integer, public :: unit Source Code subroutine git_revision ( local_path , object , error ) !> Local path to checkout in character ( * ), intent ( in ) :: local_path !> Git object reference character ( len = :), allocatable , intent ( out ) :: object !> Error type ( error_t ), allocatable , intent ( out ) :: error integer :: stat , unit , istart , iend character ( len = :), allocatable :: temp_file , line , iomsg character ( len =* ), parameter :: hexdigits = '0123456789abcdef' allocate ( temp_file , source = get_temp_filename ()) line = \"git -C \" // local_path // \" log -n 1 > \" // temp_file call execute_command_line ( line , exitstat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Error while retrieving commit information\" ) return end if open ( file = temp_file , newunit = unit ) call getline ( unit , line , stat , iomsg ) if ( stat /= 0 ) then call fatal_error ( error , iomsg ) return end if close ( unit , status = \"delete\" ) ! Tokenize: ! commit 0123456789abcdef (HEAD, ...) istart = scan ( line , ' ' ) + 1 iend = verify ( line ( istart :), hexdigits ) + istart - 1 if ( iend < istart ) iend = len ( line ) object = line ( istart : iend ) end subroutine git_revision","tags":"","loc":"proc/git_revision.html"},{"title":"info – Fortran-lang/fpm","text":"public subroutine info(self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout Contents Variables fmt pr Source Code info Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: fmt = '(\"#\", 1x, a, t30, a)' integer, public :: pr Source Code subroutine info ( self , unit , verbosity ) !> Instance of the git target class ( git_target_t ), intent ( in ) :: self !> Unit for IO integer , intent ( in ) :: unit !> Verbosity of the printout integer , intent ( in ), optional :: verbosity integer :: pr character ( len =* ), parameter :: fmt = '(\"#\", 1x, a, t30, a)' if ( present ( verbosity )) then pr = verbosity else pr = 1 end if if ( pr < 1 ) return write ( unit , fmt ) \"Git target\" if ( allocated ( self % url )) then write ( unit , fmt ) \"- URL\" , self % url end if if ( allocated ( self % object )) then select case ( self % descriptor ) case default write ( unit , fmt ) \"- object\" , self % object case ( git_descriptor % tag ) write ( unit , fmt ) \"- tag\" , self % object case ( git_descriptor % branch ) write ( unit , fmt ) \"- branch\" , self % object case ( git_descriptor % revision ) write ( unit , fmt ) \"- sha1\" , self % object end select end if end subroutine info","tags":"","loc":"proc/info.html"},{"title":"fatal_error – Fortran-lang/fpm","text":"public subroutine fatal_error(error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message Contents Source Code fatal_error Source Code subroutine fatal_error ( error , message ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Error message character ( len =* ), intent ( in ) :: message allocate ( error ) error % message = message end subroutine fatal_error","tags":"","loc":"proc/fatal_error.html"},{"title":"file_not_found_error – Fortran-lang/fpm","text":"public subroutine file_not_found_error(error, file_name) Error created when a file is missing or not found Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of the missing file Contents Source Code file_not_found_error Source Code subroutine file_not_found_error ( error , file_name ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of the missing file character ( len =* ), intent ( in ) :: file_name allocate ( error ) error % message = \"'\" // file_name // \"' could not be found, check if the file exists\" end subroutine file_not_found_error","tags":"","loc":"proc/file_not_found_error.html"},{"title":"file_parse_error – Fortran-lang/fpm","text":"public subroutine file_parse_error(error, file_name, message, line_num, line_string, line_col) Error created when file parsing fails Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of file character(len=*), intent(in) :: message Parse error message integer, intent(in), optional :: line_num Line number of parse error character(len=*), intent(in), optional :: line_string Line context string integer, intent(in), optional :: line_col Line context column Contents Variables temp_string Source Code file_parse_error Variables Type Visibility Attributes Name Initial character(len=50), public :: temp_string Source Code subroutine file_parse_error ( error , file_name , message , line_num , & line_string , line_col ) !> Instance of the error data type ( error_t ), allocatable , intent ( out ) :: error !> Name of file character ( len =* ), intent ( in ) :: file_name !> Parse error message character ( len =* ), intent ( in ) :: message !> Line number of parse error integer , intent ( in ), optional :: line_num !> Line context string character ( len =* ), intent ( in ), optional :: line_string !> Line context column integer , intent ( in ), optional :: line_col character ( 50 ) :: temp_string allocate ( error ) error % message = 'Parse error: ' // message // new_line ( 'a' ) error % message = error % message // file_name if ( present ( line_num )) then write ( temp_string , '(I0)' ) line_num error % message = error % message // ':' // trim ( temp_string ) end if if ( present ( line_col )) then if ( line_col > 0 ) then write ( temp_string , '(I0)' ) line_col error % message = error % message // ':' // trim ( temp_string ) end if end if if ( present ( line_string )) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // line_string if ( present ( line_col )) then if ( line_col > 0 ) then error % message = error % message // new_line ( 'a' ) error % message = error % message // '   | ' // repeat ( ' ' , line_col - 1 ) // '&#94;' end if end if end if end subroutine file_parse_error","tags":"","loc":"proc/file_parse_error.html"},{"title":"syntax_error – Fortran-lang/fpm","text":"public interface syntax_error Alias syntax errors to fatal errors for now Contents Module Procedures fatal_error Module Procedures public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message","tags":"","loc":"interface/syntax_error.html"},{"title":"read_package_file – Fortran-lang/fpm","text":"public subroutine read_package_file(table, manifest, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: manifest Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation Contents Variables exist parse_error unit Source Code read_package_file Variables Type Visibility Attributes Name Initial logical, public :: exist type(toml_error), public, allocatable :: parse_error integer, public :: unit Source Code subroutine read_package_file ( table , manifest , error ) !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Name of the package configuration file character ( len =* ), intent ( in ) :: manifest !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error type ( toml_error ), allocatable :: parse_error integer :: unit logical :: exist inquire ( file = manifest , exist = exist ) if (. not . exist ) then call file_not_found_error ( error , manifest ) return end if open ( file = manifest , newunit = unit ) call toml_parse ( table , unit , parse_error ) close ( unit ) if ( allocated ( parse_error )) then allocate ( error ) call move_alloc ( parse_error % message , error % message ) return end if end subroutine read_package_file","tags":"","loc":"proc/read_package_file.html"},{"title":"get_value – Fortran-lang/fpm","text":"public interface get_value Contents Module Procedures get_child_value_string_list Module Procedures private subroutine get_child_value_string_list(table, key, list, error) Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table Instance of the TOML data structure character(len=*), intent(in) :: key Key to read from type( string_t ), intent(out), allocatable :: list (:) List of strings to read type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/get_value.html"},{"title":"default_example – Fortran-lang/fpm","text":"public subroutine default_example(self, name) Populate test in case we find the default example/ directory Arguments Type Intent Optional Attributes Name type( example_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package Contents Source Code default_example Source Code subroutine default_example ( self , name ) !> Instance of the executable meta data type ( example_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name // \"-demo\" self % source_dir = \"example\" self % main = \"main.f90\" end subroutine default_example","tags":"","loc":"proc/default_example.html"},{"title":"default_executable – Fortran-lang/fpm","text":"public subroutine default_executable(self, name) Populate executable in case we find the default app directory Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package Contents Source Code default_executable Source Code subroutine default_executable ( self , name ) !> Instance of the executable meta data type ( executable_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name self % source_dir = \"app\" self % main = \"main.f90\" end subroutine default_executable","tags":"","loc":"proc/default_executable.html"},{"title":"default_library – Fortran-lang/fpm","text":"public subroutine default_library(self) Populate library in case we find the default src directory Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library meta data Contents Source Code default_library Source Code subroutine default_library ( self ) !> Instance of the library meta data type ( library_config_t ), intent ( out ) :: self self % source_dir = \"src\" end subroutine default_library","tags":"","loc":"proc/default_library.html"},{"title":"default_test – Fortran-lang/fpm","text":"public subroutine default_test(self, name) Populate test in case we find the default test/ directory Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package Contents Source Code default_test Source Code subroutine default_test ( self , name ) !> Instance of the executable meta data type ( test_config_t ), intent ( out ) :: self !> Name of the package character ( len =* ), intent ( in ) :: name self % name = name // \"-test\" self % source_dir = \"test\" self % main = \"main.f90\" end subroutine default_test","tags":"","loc":"proc/default_test.html"},{"title":"get_package_data – Fortran-lang/fpm","text":"public subroutine get_package_data(package, file, error, apply_defaults) Obtain package meta data from a configuation file Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: package Parsed package meta data character(len=*), intent(in) :: file Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation logical, intent(in), optional :: apply_defaults Apply package defaults (uses file system operations) Contents Variables root table Source Code get_package_data Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: root type(toml_table), public, allocatable :: table Source Code subroutine get_package_data ( package , file , error , apply_defaults ) !> Parsed package meta data type ( package_config_t ), intent ( out ) :: package !> Name of the package configuration file character ( len =* ), intent ( in ) :: file !> Error status of the operation type ( error_t ), allocatable , intent ( out ) :: error !> Apply package defaults (uses file system operations) logical , intent ( in ), optional :: apply_defaults type ( toml_table ), allocatable :: table character ( len = :), allocatable :: root call read_package_file ( table , file , error ) if ( allocated ( error )) return if (. not . allocated ( table )) then call fatal_error ( error , \"Unclassified error while reading: '\" // file // \"'\" ) return end if call new_package ( package , table , error ) if ( allocated ( error )) return if ( present ( apply_defaults )) then if ( apply_defaults ) then root = dirname ( file ) if ( len_trim ( root ) == 0 ) root = \".\" call package_defaults ( package , root , error ) if ( allocated ( error )) return end if end if end subroutine get_package_data","tags":"","loc":"proc/get_package_data.html"},{"title":"new_installer – Fortran-lang/fpm","text":"public subroutine new_installer(self, prefix, bindir, libdir, includedir, verbosity, copy) Create a new instance of an installer Arguments Type Intent Optional Attributes Name type( installer_t ), intent(out) :: self Instance of the installer character(len=*), intent(in), optional :: prefix Path to installation directory character(len=*), intent(in), optional :: bindir Binary dir relative to the installation prefix character(len=*), intent(in), optional :: libdir Library directory relative to the installation prefix character(len=*), intent(in), optional :: includedir Include directory relative to the installation prefix integer, intent(in), optional :: verbosity Verbosity of the installer character(len=*), intent(in), optional :: copy Copy command Contents Source Code new_installer Source Code subroutine new_installer ( self , prefix , bindir , libdir , includedir , verbosity , & copy ) !> Instance of the installer type ( installer_t ), intent ( out ) :: self !> Path to installation directory character ( len =* ), intent ( in ), optional :: prefix !> Binary dir relative to the installation prefix character ( len =* ), intent ( in ), optional :: bindir !> Library directory relative to the installation prefix character ( len =* ), intent ( in ), optional :: libdir !> Include directory relative to the installation prefix character ( len =* ), intent ( in ), optional :: includedir !> Verbosity of the installer integer , intent ( in ), optional :: verbosity !> Copy command character ( len =* ), intent ( in ), optional :: copy self % os = get_os_type () if ( present ( copy )) then self % copy = copy else if ( os_is_unix ( self % os )) then self % copy = default_copy_unix else self % copy = default_copy_win end if end if if ( present ( includedir )) then self % includedir = includedir else self % includedir = default_includedir end if if ( present ( prefix )) then self % prefix = prefix else call set_default_prefix ( self % prefix , self % os ) end if if ( present ( bindir )) then self % bindir = bindir else self % bindir = default_bindir end if if ( present ( libdir )) then self % libdir = libdir else self % libdir = default_libdir end if if ( present ( verbosity )) then self % verbosity = verbosity else self % verbosity = 1 end if end subroutine new_installer","tags":"","loc":"proc/new_installer.html"},{"title":"char – Fortran-lang/fpm","text":"public interface char Contents Module Procedures as_string Module Procedures private function as_string(self) result(string) Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: self Version number Return Value character(len=:),\n  allocatable Character representation of the version","tags":"","loc":"interface/char.html"},{"title":"new_version – Fortran-lang/fpm","text":"public interface new_version Contents Module Procedures new_version_from_string new_version_from_int Module Procedures private subroutine new_version_from_string(self, string, error) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data character(len=*), intent(in) :: string String describing the version information type( error_t ), intent(out), allocatable :: error Error handling private subroutine new_version_from_int(self, num) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data integer, intent(in) :: num (:) Subversion numbers to define version data","tags":"","loc":"interface/new_version.html"},{"title":"new_dependency_node – Fortran-lang/fpm","text":"public pure subroutine new_dependency_node(self, dependency, version, proj_dir, update) Create a new dependency node from a configuration Arguments Type Intent Optional Attributes Name type( dependency_node_t ), intent(out) :: self Instance of the dependency node type( dependency_config_t ), intent(in) :: dependency Dependency configuration data type( version_t ), intent(in), optional :: version Version of the dependency character(len=*), intent(in), optional :: proj_dir Installation prefix of the dependency logical, intent(in), optional :: update Dependency should be updated Contents Source Code new_dependency_node Source Code pure subroutine new_dependency_node ( self , dependency , version , proj_dir , update ) !> Instance of the dependency node type ( dependency_node_t ), intent ( out ) :: self !> Dependency configuration data type ( dependency_config_t ), intent ( in ) :: dependency !> Version of the dependency type ( version_t ), intent ( in ), optional :: version !> Installation prefix of the dependency character ( len =* ), intent ( in ), optional :: proj_dir !> Dependency should be updated logical , intent ( in ), optional :: update self % dependency_config_t = dependency if ( present ( version )) then self % version = version end if if ( present ( proj_dir )) then self % proj_dir = proj_dir end if if ( present ( update )) then self % update = update end if end subroutine new_dependency_node","tags":"","loc":"proc/new_dependency_node.html"},{"title":"new_dependency_tree – Fortran-lang/fpm","text":"public subroutine new_dependency_tree(self, verbosity, cache) Create a new dependency tree Arguments Type Intent Optional Attributes Name type( dependency_tree_t ), intent(out) :: self Instance of the dependency tree integer, intent(in), optional :: verbosity Verbosity of printout character(len=*), intent(in), optional :: cache Name of the cache file Contents Source Code new_dependency_tree Source Code subroutine new_dependency_tree ( self , verbosity , cache ) !> Instance of the dependency tree type ( dependency_tree_t ), intent ( out ) :: self !> Verbosity of printout integer , intent ( in ), optional :: verbosity !> Name of the cache file character ( len =* ), intent ( in ), optional :: cache call resize ( self % dep ) self % dep_dir = join_path ( \"build\" , \"dependencies\" ) if ( present ( verbosity )) then self % verbosity = verbosity end if if ( present ( cache )) then self % cache = cache end if end subroutine new_dependency_tree","tags":"","loc":"proc/new_dependency_tree.html"},{"title":"resize – Fortran-lang/fpm","text":"public interface resize Overloaded reallocation interface Contents Module Procedures resize_dependency_node Module Procedures private pure subroutine resize_dependency_node(var, n) Reallocate a list of dependencies Arguments Type Intent Optional Attributes Name type( dependency_node_t ), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"interface/resize~2.html"},{"title":"cmd_install – Fortran-lang/fpm","text":"public subroutine cmd_install(settings) Entry point for the fpm-install subcommand Arguments Type Intent Optional Attributes Name type( fpm_install_settings ), intent(in) :: settings Representation of the command line settings Contents Variables dir error exe installable installer lib model package Source Code cmd_install Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dir type( error_t ), public, allocatable :: error character(len=:), public, allocatable :: exe logical, public :: installable type( installer_t ), public :: installer character(len=:), public, allocatable :: lib type( fpm_model_t ), public :: model type( package_config_t ), public :: package Source Code subroutine cmd_install ( settings ) !> Representation of the command line settings type ( fpm_install_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( error_t ), allocatable :: error type ( fpm_model_t ) :: model type ( installer_t ) :: installer character ( len = :), allocatable :: lib , exe , dir logical :: installable call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) call handle_error ( error ) call build_model ( model , settings % fpm_build_settings , package , error ) call handle_error ( error ) installable = ( allocated ( package % library ) . and . package % install % library ) & . or . allocated ( package % executable ) if (. not . installable ) then call fatal_error ( error , \"Project does not contain any installable targets\" ) call handle_error ( error ) end if if ( settings % list ) then call install_info ( output_unit , package , model ) return end if if (. not . settings % no_rebuild ) then call build_package ( model ) end if call new_installer ( installer , prefix = settings % prefix , & bindir = settings % bindir , libdir = settings % libdir , & includedir = settings % includedir , & verbosity = merge ( 2 , 1 , settings % verbose )) if ( allocated ( package % library ) . and . package % install % library ) then dir = join_path ( model % output_directory , model % package_name ) lib = \"lib\" // model % package_name // \".a\" call installer % install_library ( join_path ( dir , lib ), error ) call handle_error ( error ) call install_module_files ( installer , dir , error ) call handle_error ( error ) end if if ( allocated ( package % executable )) then call install_executables ( installer , model , error ) call handle_error ( error ) end if end subroutine cmd_install","tags":"","loc":"proc/cmd_install.html"},{"title":"cmd_new – Fortran-lang/fpm","text":"public subroutine cmd_new(settings) Arguments Type Intent Optional Attributes Name type( fpm_new_settings ), intent(in) :: settings Contents Variables bname date littlefile message Subroutines filewrite warnwrite Source Code cmd_new Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bname character(len=8), public :: date character(len=:), public, allocatable :: littlefile (:) character(len=:), public, allocatable :: message (:) Subroutines subroutine filewrite(filename, filedata) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: filedata (:) subroutine warnwrite(fname, data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=*), intent(in) :: data (:) Source Code subroutine cmd_new ( settings ) type ( fpm_new_settings ), intent ( in ) :: settings character ( len = :), allocatable :: bname ! baeename of NAME character ( len = :), allocatable :: message (:) character ( len = :), allocatable :: littlefile (:) character ( len = 8 ) :: date call date_and_time ( DATE = date ) if ( exists ( settings % name ) . and . . not . settings % backfill ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists.' write ( stderr , '(*(g0,1x))' )& & '        perhaps you wanted to add --backfill ?' return elseif ( is_dir ( settings % name ) . and . settings % backfill ) then write ( * , '(*(g0))' ) 'backfilling ' , settings % name elseif ( exists ( settings % name ) ) then write ( stderr , '(*(g0,1x))' )& & 'ERROR: ' , settings % name , 'already exists and is not a directory.' return else ! make new directory call mkdir ( settings % name ) endif ! change to new directory as a test. System dependent potentially call run ( 'cd ' // settings % name ) ! NOTE: need some system routines to handle filenames like \".\" ! like realpath() or getcwd(). bname = basename ( settings % name ) ! create NAME/.gitignore file call warnwrite ( join_path ( settings % name , '.gitignore' ), [ 'build/*' ]) littlefile = [ character ( len = 80 ) :: '# ' // bname , 'My cool new project!' ] ! create NAME/README.md call warnwrite ( join_path ( settings % name , 'README.md' ), littlefile ) ! start building NAME/fpm.toml message = [ character ( len = 80 ) :: & & 'name = \"' // bname // '\"                     ' , & & 'version = \"0.1.0\"                        ' , & & 'license = \"license\"                      ' , & & 'author = \"Jane Doe\"                      ' , & & 'maintainer = \"jane.doe@example.com\"      ' , & & 'copyright = \"' // date ( 1 : 4 ) // ' Jane Doe\"   ' , & & '                                         ' , & & '' ] if ( settings % with_lib ) then call mkdir ( join_path ( settings % name , 'src' ) ) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[library]                            ' , & & 'source-dir=\"src\"                     ' , & & '' ] ! create placeholder module src/bname.f90 littlefile = [ character ( len = 80 ) :: & & 'module ' // bname , & & '  implicit none' , & & '  private' , & & '' , & & '  public :: say_hello' , & & 'contains' , & & '  subroutine say_hello' , & & '    print *, \"Hello, ' // bname // '!\"' , & & '  end subroutine say_hello' , & & 'end module ' // bname ] ! create NAME/src/NAME.f90 call warnwrite ( join_path ( settings % name , 'src' , bname // '.f90' ),& & littlefile ) endif if ( settings % with_test ) then ! create NAME/test or stop call mkdir ( join_path ( settings % name , 'test' )) ! create next section of fpm.toml message = [ character ( len = 80 ) :: message , & & '[[test]]                             ' , & & 'name=\"runTests\"                      ' , & & 'source-dir=\"test\"                    ' , & & 'main=\"main.f90\"                      ' , & & '' ] littlefile = [ character ( len = 80 ) :: & & 'program main' , & & 'implicit none' , & & '' , & & 'print *, \"Put some tests in here!\"' , & & 'end program main' ] ! create NAME/test/main.f90 call warnwrite ( join_path ( settings % name , 'test/main.f90' ), littlefile ) endif if ( settings % with_executable ) then ! create next section of fpm.toml call mkdir ( join_path ( settings % name , 'app' )) ! create NAME/app or stop message = [ character ( len = 80 ) :: message , & & '[[executable]]                       ' , & & 'name=\"' // bname // '\"                   ' , & & 'source-dir=\"app\"                     ' , & & 'main=\"main.f90\"                      ' , & & '' ] if ( exists ( bname // '/src/' )) then littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  use ' // bname // ', only: say_hello' , & & '  implicit none' , & & '' , & & '  call say_hello()' , & & 'end program main' ] else littlefile = [ character ( len = 80 ) :: & & 'program main' , & & '  implicit none' , & & '' , & & '  print *, \"hello from project ' // bname // '\"' , & & 'end program main' ] endif call warnwrite ( join_path ( settings % name , 'app/main.f90' ), littlefile ) endif ! now that built it write NAME/fpm.toml call warnwrite ( join_path ( settings % name , 'fpm.toml' ), message ) ! assumes git(1) is installed and in path call run ( 'git init ' // settings % name ) contains subroutine warnwrite ( fname , data ) character ( len =* ), intent ( in ) :: fname character ( len =* ), intent ( in ) :: data (:) if (. not . exists ( fname )) then call filewrite ( fname , data ) else write ( stderr , '(*(g0,1x))' ) 'INFO:   ' , fname ,& & 'already exists. Not overwriting' endif end subroutine warnwrite subroutine filewrite ( filename , filedata ) ! procedure to write filedata to file filename use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , stdout => output_unit , stderr => error_unit character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ) :: filedata (:) integer :: lun , i , ios character ( len = 256 ) :: message message = ' ' ios = 0 if ( filename . ne . ' ' ) then open ( file = filename , & & newunit = lun , & & form = 'formatted' , & ! FORM    = FORMATTED | UNFORMATTED & access = 'sequential' , & ! ACCESS  = SEQUENTIAL| DIRECT | STREAM & action = 'write' , & ! ACTION  = READ|WRITE| READWRITE & position = 'rewind' , & ! POSITION= ASIS      | REWIND | APPEND & status = 'new' , & ! STATUS  = NEW| REPLACE| OLD| SCRATCH| UNKNOWN & iostat = ios , & & iomsg = message ) else lun = stdout ios = 0 endif if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 1 endif ! write file do i = 1 , size ( filedata ) write ( lun , '(a)' , iostat = ios , iomsg = message ) trim ( filedata ( i )) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' )& & '*filewrite* error:' , filename , trim ( message ) error stop 4 endif enddo ! close file close ( unit = lun , iostat = ios , iomsg = message ) if ( ios . ne . 0 ) then write ( stderr , '(*(a:,1x))' ) '*filewrite* error:' , trim ( message ) error stop 2 endif end subroutine filewrite end subroutine cmd_new","tags":"","loc":"proc/cmd_new.html"},{"title":"cmd_update – Fortran-lang/fpm","text":"public subroutine cmd_update(settings) Entry point for the update subcommand Arguments Type Intent Optional Attributes Name type( fpm_update_settings ), intent(in) :: settings Representation of the command line arguments Contents Variables cache deps error ii package Source Code cmd_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cache type( dependency_tree_t ), public :: deps type( error_t ), public, allocatable :: error integer, public :: ii type( package_config_t ), public :: package Source Code subroutine cmd_update ( settings ) !> Representation of the command line arguments type ( fpm_update_settings ), intent ( in ) :: settings type ( package_config_t ) :: package type ( dependency_tree_t ) :: deps type ( error_t ), allocatable :: error integer :: ii character ( len = :), allocatable :: cache call get_package_data ( package , \"fpm.toml\" , error , apply_defaults = . true .) call handle_error ( error ) if (. not . exists ( \"build\" )) then call mkdir ( \"build\" ) end if cache = join_path ( \"build\" , \"cache.toml\" ) if ( settings % clean ) then call delete_file ( cache ) end if call new_dependency_tree ( deps , cache = cache , & verbosity = merge ( 2 , 1 , settings % verbose )) call deps % add ( package , error ) call handle_error ( error ) if ( settings % fetch_only ) return if ( size ( settings % name ) == 0 ) then do ii = 1 , deps % ndep call deps % update ( deps % dep ( ii )% name , error ) call handle_error ( error ) end do else do ii = 1 , size ( settings % name ) call deps % update ( trim ( settings % name ( ii )), error ) call handle_error ( error ) end do end if end subroutine cmd_update","tags":"","loc":"proc/cmd_update.html"},{"title":"new_install_config – Fortran-lang/fpm","text":"public subroutine new_install_config(self, table, error) Create a new installation configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( install_config_t ), intent(out) :: self Instance of the install configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Source Code new_install_config Source Code subroutine new_install_config ( self , table , error ) !> Instance of the install configuration type ( install_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"library\" , self % library , . false .) end subroutine new_install_config","tags":"","loc":"proc/new_install_config.html"},{"title":"new_example – Fortran-lang/fpm","text":"public subroutine new_example(self, table, error) Construct a new example configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( example_config_t ), intent(out) :: self Instance of the example configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child Source Code new_example Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child Source Code subroutine new_example ( self , table , error ) !> Instance of the example configuration type ( example_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve example name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"example\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_example","tags":"","loc":"proc/new_example.html"},{"title":"new_package – Fortran-lang/fpm","text":"public subroutine new_package(self, table, error) Construct a new package configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: self Instance of the package configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child children ii invalid_chars nn node stat version Source Code new_package Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child type(toml_array), public, pointer :: children integer, public :: ii character(len=*), public, parameter :: invalid_chars = achar(8)//achar(9)//achar(10)//achar(12)//achar(13) integer, public :: nn type(toml_table), public, pointer :: node integer, public :: stat character(len=:), public, allocatable :: version Source Code subroutine new_package ( self , table , error ) !> Instance of the package configuration type ( package_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error ! Backspace (8), tabulator (9), newline (10), formfeed (12) and carriage ! return (13) are invalid in package names character ( len =* ), parameter :: invalid_chars = & achar ( 8 ) // achar ( 9 ) // achar ( 10 ) // achar ( 12 ) // achar ( 13 ) type ( toml_table ), pointer :: child , node type ( toml_array ), pointer :: children character ( len = :), allocatable :: version integer :: ii , nn , stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve package name\" ) return end if if ( len ( self % name ) <= 0 ) then call syntax_error ( error , \"Package name must be a non-empty string\" ) return end if ii = scan ( self % name , invalid_chars ) if ( ii > 0 ) then call syntax_error ( error , \"Package name contains invalid characters\" ) return end if call get_value ( table , \"build\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for build entry, must be a table\" ) return end if call new_build_config ( self % build , child , error ) if ( allocated ( error )) return call get_value ( table , \"install\" , child , requested = . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Type mismatch for install entry, must be a table\" ) return end if call new_install_config ( self % install , child , error ) if ( allocated ( error )) return call get_value ( table , \"version\" , version , \"0\" ) call new_version ( self % version , version , error ) if ( allocated ( error )) return call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"dev-dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dev_dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"library\" , child , requested = . false .) if ( associated ( child )) then allocate ( self % library ) call new_library ( self % library , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"executable\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % executable ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve executable from array entry\" ) exit end if call new_executable ( self % executable ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % executable , error ) if ( allocated ( error )) return end if call get_value ( table , \"example\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % example ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve example from array entry\" ) exit end if call new_example ( self % example ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % example , error ) if ( allocated ( error )) return if ( allocated ( self % executable )) then call unique_programs ( self % executable , self % example , error ) if ( allocated ( error )) return end if end if call get_value ( table , \"test\" , children , requested = . false .) if ( associated ( children )) then nn = len ( children ) allocate ( self % test ( nn )) do ii = 1 , nn call get_value ( children , ii , node , stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Could not retrieve test from array entry\" ) exit end if call new_test ( self % test ( ii ), node , error ) if ( allocated ( error )) exit end do if ( allocated ( error )) return call unique_programs ( self % test , error ) if ( allocated ( error )) return end if end subroutine new_package","tags":"","loc":"proc/new_package.html"},{"title":"new_library – Fortran-lang/fpm","text":"public subroutine new_library(self, table, error) Construct a new library configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Source Code new_library Source Code subroutine new_library ( self , table , error ) !> Instance of the library configuration type ( library_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"source-dir\" , self % source_dir , \"src\" ) call get_value ( table , \"build-script\" , self % build_script ) end subroutine new_library","tags":"","loc":"proc/new_library.html"},{"title":"new_test – Fortran-lang/fpm","text":"public subroutine new_test(self, table, error) Construct a new test configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the test configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child Source Code new_test Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child Source Code subroutine new_test ( self , table , error ) !> Instance of the test configuration type ( test_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve test name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"test\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_test","tags":"","loc":"proc/new_test.html"},{"title":"new_executable – Fortran-lang/fpm","text":"public subroutine new_executable(self, table, error) Construct a new executable configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables child Source Code new_executable Variables Type Visibility Attributes Name Initial type(toml_table), public, pointer :: child Source Code subroutine new_executable ( self , table , error ) !> Instance of the executable configuration type ( executable_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: child call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"name\" , self % name ) if (. not . allocated ( self % name )) then call syntax_error ( error , \"Could not retrieve executable name\" ) return end if call get_value ( table , \"source-dir\" , self % source_dir , \"app\" ) call get_value ( table , \"main\" , self % main , \"main.f90\" ) call get_value ( table , \"dependencies\" , child , requested = . false .) if ( associated ( child )) then call new_dependencies ( self % dependency , child , error ) if ( allocated ( error )) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_executable","tags":"","loc":"proc/new_executable.html"},{"title":"new_dependencies – Fortran-lang/fpm","text":"public subroutine new_dependencies(deps, table, error) Construct new dependency array from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out), allocatable :: deps (:) Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables idep list node stat Source Code new_dependencies Variables Type Visibility Attributes Name Initial integer, public :: idep type(toml_key), public, allocatable :: list (:) type(toml_table), public, pointer :: node integer, public :: stat Source Code subroutine new_dependencies ( deps , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), allocatable , intent ( out ) :: deps (:) !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error type ( toml_table ), pointer :: node type ( toml_key ), allocatable :: list (:) integer :: idep , stat call table % get_keys ( list ) ! An empty table is okay if ( size ( list ) < 1 ) return allocate ( deps ( size ( list ))) do idep = 1 , size ( list ) call get_value ( table , list ( idep )% key , node , stat = stat ) if ( stat /= toml_stat % success ) then call syntax_error ( error , \"Dependency \" // list ( idep )% key // \" must be a table entry\" ) exit end if call new_dependency ( deps ( idep ), node , error ) if ( allocated ( error )) exit end do end subroutine new_dependencies","tags":"","loc":"proc/new_dependencies.html"},{"title":"new_dependency – Fortran-lang/fpm","text":"public subroutine new_dependency(self, table, error) Construct a new dependency configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out) :: self Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables obj url Source Code new_dependency Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: obj character(len=:), public, allocatable :: url Source Code subroutine new_dependency ( self , table , error ) !> Instance of the dependency configuration type ( dependency_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: url , obj call check ( table , error ) if ( allocated ( error )) return call table % get_key ( self % name ) call get_value ( table , \"path\" , url ) if ( allocated ( url )) then call move_alloc ( url , self % path ) else call get_value ( table , \"git\" , url ) call get_value ( table , \"tag\" , obj ) if ( allocated ( obj )) then self % git = git_target_tag ( url , obj ) end if if (. not . allocated ( self % git )) then call get_value ( table , \"branch\" , obj ) if ( allocated ( obj )) then self % git = git_target_branch ( url , obj ) end if end if if (. not . allocated ( self % git )) then call get_value ( table , \"rev\" , obj ) if ( allocated ( obj )) then self % git = git_target_revision ( url , obj ) end if end if if (. not . allocated ( self % git )) then self % git = git_target_default ( url ) end if end if end subroutine new_dependency","tags":"","loc":"proc/new_dependency.html"},{"title":"new_build_config – Fortran-lang/fpm","text":"public subroutine new_build_config(self, table, error) Construct a new build configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( build_config_t ), intent(out) :: self Instance of the build configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling Contents Variables stat Source Code new_build_config Variables Type Visibility Attributes Name Initial integer, public :: stat Source Code subroutine new_build_config ( self , table , error ) !> Instance of the build configuration type ( build_config_t ), intent ( out ) :: self !> Instance of the TOML data structure type ( toml_table ), intent ( inout ) :: table !> Error handling type ( error_t ), allocatable , intent ( out ) :: error integer :: stat call check ( table , error ) if ( allocated ( error )) return call get_value ( table , \"auto-executables\" , self % auto_executables , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-executables' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-tests\" , self % auto_tests , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-tests' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"auto-examples\" , self % auto_examples , . true ., stat = stat ) if ( stat /= toml_stat % success ) then call fatal_error ( error , \"Error while reading value for 'auto-examples' in fpm.toml, expecting logical\" ) return end if call get_value ( table , \"link\" , self % link , error ) if ( allocated ( error )) return end subroutine new_build_config","tags":"","loc":"proc/new_build_config.html"},{"title":"fpm_filesystem – Fortran-lang/fpm","text":"Uses fpm_environment fpm_strings Contents Functions basename canon_path dirname exists get_temp_filename is_dir join_path number_of_rows read_lines unix_path windows_path Subroutines delete_file env_variable getline list_files mkdir Functions public function basename (path, suffix) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path logical, intent(in), optional :: suffix Return Value character(len=:),\n  allocatable public function canon_path (path) result(canon) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable public function dirname (path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable public function exists (filename) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical public function get_temp_filename () result(tempfile) Arguments None Return Value character(len=:),\n  allocatable public function is_dir (dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Return Value logical public function join_path (a1, a2, a3, a4, a5) result(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a1 character(len=*), intent(in) :: a2 character(len=*), intent(in), optional :: a3 character(len=*), intent(in), optional :: a4 character(len=*), intent(in), optional :: a5 Return Value character(len=:),\n  allocatable public function number_of_rows (s) result(nrows) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s Return Value integer public function read_lines (fh) result(lines) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh Return Value type( string_t ),\n  allocatable, (:) public function unix_path (path) result(nixpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable public function windows_path (path) result(winpath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),\n  allocatable Subroutines public subroutine delete_file (file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file public subroutine env_variable (var, name) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: var character(len=*), intent(in) :: name public subroutine getline (unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message public recursive subroutine list_files (dir, files, recurse) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir type( string_t ), intent(out), allocatable :: files (:) logical, intent(in), optional :: recurse public subroutine mkdir (dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir","tags":"","loc":"module/fpm_filesystem.html"},{"title":"fpm_command_line – Fortran-lang/fpm","text":"Definition of the command line interface This module uses M_CLI2 to define\n the command line interface.\n To define a command line interface create a new command settings type\n from the fpm_cmd_settings base class or the respective parent command\n settings. The subcommand is selected by the first non-option argument in the command\n line. In the subcase block the actual command line is defined and transferred\n to an instance of the fpm_cmd_settings , the actual type is used by the fpm main program to determine which command entry point is chosen. To add a new subcommand add a new case to select construct and specify the\n wanted command line and the expected default values.\n Some of the following points also apply if you add a new option or argument\n to an existing fpm subcommand.\n Add this point you should create a help page for the new command in a simple\n catman-like format as well in the set_help procedure.\n Make sure to register new subcommands in the fpm-manual command by adding\n them to the manual character array and in the help/manual case as well.\n You should add the new command to the synopsis section of the fpm-list , fpm-help and fpm --list help pages below to make sure the help output\n is complete and consistent as well. Uses fpm_environment M_CLI2 fpm_strings fpm_filesystem iso_fortran_env Contents Derived Types fpm_build_settings fpm_cmd_settings fpm_install_settings fpm_new_settings fpm_run_settings fpm_test_settings fpm_update_settings Subroutines get_command_line_settings Derived Types type, public, extends( fpm_cmd_settings ) :: fpm_build_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: list = .false. logical, public :: show_model = .false. logical, public :: verbose = .true. type, public, abstract :: fpm_cmd_settings Components Type Visibility Attributes Name Initial logical, public :: verbose = .true. type, public, extends( fpm_build_settings ) :: fpm_install_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bindir character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler character(len=:), public, allocatable :: includedir character(len=:), public, allocatable :: libdir logical, public :: list = .false. logical, public :: no_rebuild character(len=:), public, allocatable :: prefix logical, public :: show_model = .false. logical, public :: verbose = .true. type, public, extends( fpm_cmd_settings ) :: fpm_new_settings Components Type Visibility Attributes Name Initial logical, public :: backfill = .true. character(len=:), public, allocatable :: name logical, public :: verbose = .true. logical, public :: with_executable = .false. logical, public :: with_lib = .true. logical, public :: with_test = .false. type, public, extends( fpm_build_settings ) :: fpm_run_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: example logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) character(len=:), public, allocatable :: runner logical, public :: show_model = .false. logical, public :: verbose = .true. type, public, extends( fpm_run_settings ) :: fpm_test_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: args character(len=:), public, allocatable :: build_name character(len=:), public, allocatable :: compiler logical, public :: example logical, public :: list = .false. character(len=ibug), public, allocatable :: name (:) character(len=:), public, allocatable :: runner logical, public :: show_model = .false. logical, public :: verbose = .true. type, public, extends( fpm_cmd_settings ) :: fpm_update_settings Settings for interacting and updating with project dependencies Components Type Visibility Attributes Name Initial logical, public :: clean logical, public :: fetch_only character(len=ibug), public, allocatable :: name (:) logical, public :: verbose = .true. Subroutines public subroutine get_command_line_settings (cmd_settings) ! canon_path is not converting “.”, etc.\n& ‘ unknown help topic “’//trim(unnamed(i)).’not found in:’,manual] Arguments Type Intent Optional Attributes Name class( fpm_cmd_settings ), intent(out), allocatable :: cmd_settings","tags":"","loc":"module/fpm_command_line.html"},{"title":"fpm_source_parsing – Fortran-lang/fpm","text":"Parsing of package source files This module exposes two functions, parse_f_source and parse_c_source ,\n which perform a rudimentary parsing of fortran and c source files\n in order to extract information required for module dependency tracking. Both functions additionally calculate and store a file digest (hash) which\n is used by the backend ( fpm_backend ) to skip compilation of unmodified sources. Both functions return an instance of the srcfile_t type. For more information, please read the documentation for each function: parse_f_source parse_c_source Uses fpm_error fpm_strings fpm_model fpm_filesystem Contents Functions parse_c_source parse_f_source Functions public function parse_c_source (c_filename, error) result(c_source) Parsing of c source files Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t ) public function parse_f_source (f_filename, error) result(f_source) Parsing of free-form fortran source files Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: f_filename type( error_t ), intent(out), allocatable :: error Return Value type( srcfile_t )","tags":"","loc":"module/fpm_source_parsing.html"},{"title":"fpm_sources – Fortran-lang/fpm","text":"Discovery of sources This module implements subroutines for building a list of srcfile_t objects by looking for source files in the filesystem. Uses fpm_error fpm_model fpm_filesystem fpm_strings fpm_source_parsing fpm_manifest_executable Contents Subroutines add_executable_sources add_sources_from_dir Subroutines public subroutine add_executable_sources (sources, executables, scope, auto_discover, error) Add to sources using the executable and test entries in the manifest and\n applies any executable-specific overrides such as executable%name .\n Adds all sources (including modules) from each executable%source_dir Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) List of srcfile_t objects to append to. Allocated if not allocated class( executable_config_t ), intent(in) :: executables (:) List of executable_config_t entries from manifest integer, intent(in) :: scope Scope to apply to the discovered sources: either FPM_SCOPE_APP or FPM_SCOPE_TEST , see fpm_model logical, intent(in) :: auto_discover If .false. only executables and tests specified in the manifest are added to sources type( error_t ), intent(out), allocatable :: error Error handling public subroutine add_sources_from_dir (sources, directory, scope, with_executables, recurse, error) Add to sources by looking for source files in directory Arguments Type Intent Optional Attributes Name type( srcfile_t ), intent(inout), allocatable, target :: sources (:) List of srcfile_t objects to append to. Allocated if not allocated character(len=*), intent(in) :: directory Directory in which to search for source files integer, intent(in) :: scope Scope to apply to the discovered sources, see fpm_model for enumeration logical, intent(in), optional :: with_executables Executable sources (fortran program s) are ignored unless with_executables=.true. logical, intent(in), optional :: recurse Whether to recursively search subdirectories, default is .true. type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_sources.html"},{"title":"fpm_model – Fortran-lang/fpm","text":"The fpm package model Defines the fpm model data types which encapsulate all information \n required to correctly build a package and its dependencies. The process (see build_model ) for generating a valid fpm_model is as follows: Source files are discovered ( fpm_sources ) and parsed ( fpm_source_parsing ) A list of build targets is generated ( targets_from_sources ) from the sources Inter-target dependencies are resolved ( resolve_module_dependencies ) based on modules used and provided Object link lists are generated for link targets (executables and libraries) ( resolve_target_linking ) Once a valid fpm_model has been constructed, it may be passed to build_package to\n build the package. Enumerations Source type: FPM_UNIT_* Describes the type of source file — determines build target generation Source scope: FPM_SCOPE_* Describes the scoping rules for using modules — controls module dependency resolution Target type: FPM_TARGET_* Describes the type of build target — determines backend build rules Uses iso_fortran_env fpm_strings fpm_dependency Contents Variables FPM_SCOPE_APP FPM_SCOPE_DEP FPM_SCOPE_EXAMPLE FPM_SCOPE_LIB FPM_SCOPE_TEST FPM_SCOPE_UNKNOWN FPM_TARGET_ARCHIVE FPM_TARGET_EXECUTABLE FPM_TARGET_OBJECT FPM_TARGET_UNKNOWN FPM_UNIT_CHEADER FPM_UNIT_CSOURCE FPM_UNIT_MODULE FPM_UNIT_PROGRAM FPM_UNIT_SUBMODULE FPM_UNIT_SUBPROGRAM FPM_UNIT_UNKNOWN Derived Types build_target_ptr build_target_t fpm_model_t srcfile_t Subroutines show_model Variables Type Visibility Attributes Name Initial integer, public, parameter :: FPM_SCOPE_APP = 3 Module-use scope is library/dependency and app modules integer, public, parameter :: FPM_SCOPE_DEP = 2 Module-use scope is library/dependency modules only integer, public, parameter :: FPM_SCOPE_EXAMPLE = 5 integer, public, parameter :: FPM_SCOPE_LIB = 1 Module-use scope is library/dependency modules only integer, public, parameter :: FPM_SCOPE_TEST = 4 Module-use scope is library/dependency and test modules integer, public, parameter :: FPM_SCOPE_UNKNOWN = -1 Source has no module-use scope integer, public, parameter :: FPM_TARGET_ARCHIVE = 2 Target type is library archive integer, public, parameter :: FPM_TARGET_EXECUTABLE = 1 Target type is executable integer, public, parameter :: FPM_TARGET_OBJECT = 3 Target type is compiled object integer, public, parameter :: FPM_TARGET_UNKNOWN = -1 Target type is unknown (ignored) integer, public, parameter :: FPM_UNIT_CHEADER = 6 Source type is c header file integer, public, parameter :: FPM_UNIT_CSOURCE = 5 Source type is c source file integer, public, parameter :: FPM_UNIT_MODULE = 2 Source type is fortran module integer, public, parameter :: FPM_UNIT_PROGRAM = 1 Source type is fortran program integer, public, parameter :: FPM_UNIT_SUBMODULE = 3 Source type is fortran submodule integer, public, parameter :: FPM_UNIT_SUBPROGRAM = 4 Source type is fortran subprogram integer, public, parameter :: FPM_UNIT_UNKNOWN = -1 Source type unknown Derived Types type, public :: build_target_ptr Wrapper type for constructing arrays of build_target_t pointers Components Type Visibility Attributes Name Initial type( build_target_t ), public, pointer :: ptr => null() type, public :: build_target_t Type describing a generated build target Components Type Visibility Attributes Name Initial type( build_target_ptr ), public, allocatable :: dependencies (:) Resolved build dependencies integer(kind=int64), public, allocatable :: digest_cached Previous source file hash type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against type( string_t ), public, allocatable :: link_objects (:) Objects needed to link this target character(len=:), public, allocatable :: output_file File path of build target object relative to cwd integer, public :: schedule = -1 Targets in the same schedule group are guaranteed to be independent logical, public :: skip = .false. Flag set if build target will be skipped (not built) logical, public :: sorted = .false. Flag set if build target is sorted for building type( srcfile_t ), public, allocatable :: source Primary source for this build target integer, public :: target_type = FPM_TARGET_UNKNOWN Target type logical, public :: touched = .false. Flag set when first visited to check for circular dependencies type, public :: fpm_model_t Type describing everything required to build a package\n and its dependencies. Components Type Visibility Attributes Name Initial type( dependency_tree_t ), public :: deps Project dependencies character(len=:), public, allocatable :: fortran_compile_flags Command line flags passed to fortran for compilation character(len=:), public, allocatable :: fortran_compiler Command line name to invoke fortran compiler character(len=:), public, allocatable :: library_file Output file for library archive character(len=:), public, allocatable :: link_flags Command line flags pass for linking type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against character(len=:), public, allocatable :: output_directory Base directory for build character(len=:), public, allocatable :: package_name Name of package type( srcfile_t ), public, allocatable :: sources (:) Array of sources type( build_target_ptr ), public, allocatable :: targets (:) Array of targets with module-dependencies resolved type, public :: srcfile_t Type for describing a source file Components Type Visibility Attributes Name Initial integer(kind=int64), public :: digest Current hash character(len=:), public, allocatable :: exe_name Name of executable for FPM_UNIT_PROGRAM character(len=:), public, allocatable :: file_name File path relative to cwd type( string_t ), public, allocatable :: include_dependencies (:) Files INCLUDEd by this source file type( string_t ), public, allocatable :: link_libraries (:) Native libraries to link against type( string_t ), public, allocatable :: modules_provided (:) Modules provided by this source file (lowerstring) type( string_t ), public, allocatable :: modules_used (:) Modules USEd by this source file (lowerstring) integer, public :: unit_scope = FPM_SCOPE_UNKNOWN Target module-use scope integer, public :: unit_type = FPM_UNIT_UNKNOWN Type of source unit Subroutines public subroutine show_model (model) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(in) :: model","tags":"","loc":"module/fpm_model.html"},{"title":"fpm_targets – Fortran-lang/fpm","text":"Build target handling This module handles the construction of the build target list\n from the sources list ( targets_from_sources ), the \n resolution of module-dependencies between build targets\n ( resolve_module_dependencies ), and the enumeration of\n objects required for link targets ( resolve_target_linking ). A build target ( build_target_t ) is a file to be generated\n by the backend (compilation and linking). Note The current implementation is ignorant to the existence of\n module files ( .mod , .smod ). Dependencies arising from modules\n are based on the corresponding object files ( .o ) only. For more information, please read the documentation for the procedures: targets_from_sources resolve_module_dependencies Uses fpm_error fpm_model fpm_environment fpm_filesystem fpm_strings Contents Subroutines add_dependency add_target resolve_module_dependencies resolve_target_linking targets_from_sources Subroutines public subroutine add_dependency (target, dependency) Add pointer to dependeny in target%dependencies Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout) :: target type( build_target_t ), intent(in), target :: dependency public subroutine add_target (targets, type, output_file, source, link_libraries) Allocate a new target and append to target list Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), allocatable :: targets (:) integer, intent(in) :: type character(len=*), intent(in) :: output_file type( srcfile_t ), intent(in), optional :: source type( string_t ), intent(in), optional :: link_libraries (:) public subroutine resolve_module_dependencies (targets, error) Add dependencies to source-based targets ( FPM_TARGET_OBJECT ) \n based on any modules used by the corresponding source file. Read more… Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) type( error_t ), intent(out), allocatable :: error public subroutine resolve_target_linking (targets) For libraries and executables, build a list of objects required for linking Read more… Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(inout), target :: targets (:) public subroutine targets_from_sources (model, sources) Constructs a list of build targets from a list of source files Read more… Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout), target :: model The package model within which to construct the target list type( srcfile_t ), intent(in) :: sources (:) The list of sources from which to construct the target list","tags":"","loc":"module/fpm_targets.html"},{"title":"fpm_compiler – Fortran-lang/fpm","text":"Uses fpm_model fpm_filesystem Contents Subroutines add_compile_flag_defaults Subroutines public subroutine add_compile_flag_defaults (build_name, compiler, model) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: build_name character(len=*), intent(in) :: compiler type( fpm_model_t ), intent(inout) :: model","tags":"","loc":"module/fpm_compiler.html"},{"title":"fpm – Fortran-lang/fpm","text":"Uses fpm_strings fpm_backend fpm_command_line fpm_dependency fpm_environment fpm_filesystem fpm_model fpm_compiler fpm_sources fpm_targets fpm_manifest fpm_error fpm_manifest_test iso_fortran_env fpm_manifest_dependency Contents Subroutines build_model cmd_build cmd_run Subroutines public subroutine build_model (model, settings, package, error) Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(out) :: model type( fpm_build_settings ), intent(in) :: settings type( package_config_t ), intent(in) :: package type( error_t ), intent(out), allocatable :: error public subroutine cmd_build (settings) Arguments Type Intent Optional Attributes Name type( fpm_build_settings ), intent(in) :: settings public subroutine cmd_run (settings, test) Arguments Type Intent Optional Attributes Name class( fpm_run_settings ), intent(in) :: settings logical, intent(in) :: test","tags":"","loc":"module/fpm.html"},{"title":"fpm_environment – Fortran-lang/fpm","text":"Contents Variables OS_CYGWIN OS_FREEBSD OS_LINUX OS_MACOS OS_SOLARIS OS_UNKNOWN OS_WINDOWS Functions get_env get_os_type os_is_unix Subroutines run Variables Type Visibility Attributes Name Initial integer, public, parameter :: OS_CYGWIN = 4 integer, public, parameter :: OS_FREEBSD = 6 integer, public, parameter :: OS_LINUX = 1 integer, public, parameter :: OS_MACOS = 2 integer, public, parameter :: OS_SOLARIS = 5 integer, public, parameter :: OS_UNKNOWN = 0 integer, public, parameter :: OS_WINDOWS = 3 Functions public function get_env (NAME, DEFAULT) result(VALUE) !print , NAME, ” is not defined in the environment. Strange…”\n!print , “This processor doesn’t support environment variables. Boooh!” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: NAME character(len=*), intent(in), optional :: DEFAULT Return Value character(len=:),\n  allocatable public function get_os_type () result(r) Determine the OS type Read more… Arguments None Return Value integer public function os_is_unix (os) result(unix) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: os Return Value logical Subroutines public subroutine run (cmd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd","tags":"","loc":"module/fpm_environment.html"},{"title":"fpm_strings – Fortran-lang/fpm","text":"Uses iso_fortran_env Contents Interfaces fnv_1a operator(.in.) resize str str_ends_with Derived Types string_t Functions f_string lower string_array_contains string_cat Subroutines split Interfaces public interface fnv_1a private pure function fnv_1a_char(input, seed) result(hash) Hash a character(*) string of default kind Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input integer(kind=int64), intent(in), optional :: seed Return Value integer(kind=int64) private pure function fnv_1a_string_t(input, seed) result(hash) Hash a string_t array of default kind Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: input (:) integer(kind=int64), intent(in), optional :: seed Return Value integer(kind=int64) public interface operator(.in.) public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical public interface resize private subroutine resize_string(list, n) Arguments Type Intent Optional Attributes Name type( string_t ), intent(inout), allocatable :: list (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size public interface str private pure function str_int(i) result(s) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=str_int_len(i)) private pure function str_int64(i) result(s) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=str_int64_len(i)) private pure function str_logical(l) result(s) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=str_logical_len(l)) public interface str_ends_with private pure function str_ends_with_str(s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e Return Value logical private pure function str_ends_with_any(s, e) result(r) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: e (:) Return Value logical Derived Types type, public :: string_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s Functions public function f_string (c_string) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c_string (:) Return Value character(len=:),\n  allocatable public pure elemental function lower (str, begin, end) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) public function string_array_contains (search_string, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: search_string type( string_t ), intent(in) :: array (:) Return Value logical public function string_cat (strings, delim) result(cat) Concatenate an array of type(string_t) into \n  a single character Arguments Type Intent Optional Attributes Name type( string_t ), intent(in) :: strings (:) character(len=*), intent(in), optional :: delim Return Value character(len=:),\n  allocatable Subroutines public subroutine split (input_line, array, delimiters, order, nulls) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls","tags":"","loc":"module/fpm_strings.html"},{"title":"fpm_backend – Fortran-lang/fpm","text":"Build backend Uses a valid fpm_model instance to schedule and execute the\n compilation and linking of package targets. The package build process ( build_package ) comprises three steps: Target sorting: topological sort of the target dependency graph ( sort_target ) Target scheduling: group targets into schedule regions based on the sorting ( schedule_targets ) Target building: generate targets by compilation or linking Note If compiled with OpenMP, targets will be build in parallel where possible. Incremental compilation The backend process supports incremental compilation whereby targets are not \n re-compiled if their corresponding dependencies have not been modified. Source-based targets ( i.e. objects) are not re-compiled if the corresponding source\n   file is unmodified AND all of the target dependencies are not marked for re-compilation Link targets ( i.e. executables and libraries) are not re-compiled if the \n   target output file already exists AND all of the target dependencies are not marked for\n   re-compilation Source file modification is determined by a file digest (hash) which is calculated during\n the source parsing phase ( fpm_source_parsing ) and cached to disk after a target is \n successfully generated. Uses fpm_environment fpm_filesystem fpm_model fpm_strings Contents Subroutines build_package schedule_targets sort_target Subroutines public subroutine build_package (model) Top-level routine to build package described by model Arguments Type Intent Optional Attributes Name type( fpm_model_t ), intent(inout) :: model public subroutine schedule_targets (queue, schedule_ptr, targets) Construct a build schedule from the sorted targets. Read more… Arguments Type Intent Optional Attributes Name type( build_target_ptr ), intent(out), allocatable :: queue (:) integer, allocatable :: schedule_ptr (:) type( build_target_ptr ), intent(in) :: targets (:) public recursive subroutine sort_target (target) Topologically sort a target for scheduling by \n  recursing over its dependencies. Read more… Arguments Type Intent Optional Attributes Name type( build_target_t ), intent(inout), target :: target","tags":"","loc":"module/fpm_backend.html"},{"title":"fpm_git – Fortran-lang/fpm","text":"Implementation for interacting with git repositories. Uses fpm_error fpm_filesystem Contents Variables git_descriptor Derived Types enum_descriptor git_target_t Functions git_target_branch git_target_default git_target_revision git_target_tag Subroutines checkout git_revision info Variables Type Visibility Attributes Name Initial type( enum_descriptor ), public, parameter :: git_descriptor = enum_descriptor() Actual enumerator for descriptors Derived Types type, public :: enum_descriptor Possible git target Components Type Visibility Attributes Name Initial integer, public :: branch = 201 Branch in git repository integer, public :: default = 200 Default target integer, public :: revision = 203 Commit hash integer, public :: tag = 202 Tag in git repository type, public :: git_target_t Description of an git target Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: object Additional descriptor of the git object character(len=:), public, allocatable :: url Target URL of the git repository Type-Bound Procedures procedure, public :: checkout Fetch and checkout in local directory procedure, public :: info Show information on instance Functions public function git_target_branch (url, branch) result(self) Target a branch in the git repository Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: branch Name of the branch of interest Return Value type( git_target_t ) New git target public function git_target_default (url) result(self) Default target Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository Return Value type( git_target_t ) New git target public function git_target_revision (url, sha1) result(self) Target a specific git revision Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: sha1 Commit hash of interest Return Value type( git_target_t ) New git target public function git_target_tag (url, tag) result(self) Target a git tag Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: url Target URL of the git repository character(len=*), intent(in) :: tag Tag name of interest Return Value type( git_target_t ) New git target Subroutines public subroutine checkout (self, local_path, error) Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target character(len=*), intent(in) :: local_path Local path to checkout in type( error_t ), intent(out), allocatable :: error Error public subroutine git_revision (local_path, object, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: local_path Local path to checkout in character(len=:), intent(out), allocatable :: object Git object reference type( error_t ), intent(out), allocatable :: error Error public subroutine info (self, unit, verbosity) Show information on git target Arguments Type Intent Optional Attributes Name class( git_target_t ), intent(in) :: self Instance of the git target integer, intent(in) :: unit Unit for IO integer, intent(in), optional :: verbosity Verbosity of the printout","tags":"","loc":"module/fpm_git.html"},{"title":"fpm_error – Fortran-lang/fpm","text":"Implementation of basic error handling. Contents Interfaces syntax_error Derived Types error_t Subroutines fatal_error file_not_found_error file_parse_error Interfaces public interface syntax_error Alias syntax errors to fatal errors for now public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message Derived Types type, public :: error_t Data type defining an error Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Error message Subroutines public subroutine fatal_error (error, message) Generic fatal runtime error Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: message Error message public subroutine file_not_found_error (error, file_name) Error created when a file is missing or not found Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of the missing file public subroutine file_parse_error (error, file_name, message, line_num, line_string, line_col) Error created when file parsing fails Arguments Type Intent Optional Attributes Name type( error_t ), intent(out), allocatable :: error Instance of the error data character(len=*), intent(in) :: file_name Name of file character(len=*), intent(in) :: message Parse error message integer, intent(in), optional :: line_num Line number of parse error character(len=*), intent(in), optional :: line_string Line context string integer, intent(in), optional :: line_col Line context column","tags":"","loc":"module/fpm_error.html"},{"title":"fpm_toml – Fortran-lang/fpm","text":"Interface to TOML processing library This module acts as a proxy to the toml-f public Fortran API and allows\n to selectively expose components from the library to fpm .\n The interaction with toml-f data types outside of this module should be\n limited to tables, arrays and key-lists, most of the necessary interactions\n are implemented in the building interface with the get_value and set_value procedures. This module allows to implement features necessary for fpm , which are\n not yet available in upstream toml-f . For more details on the library used see the TOML-Fortran developer pages. Uses fpm_error fpm_strings tomlf Contents Interfaces get_value Subroutines read_package_file Interfaces public interface get_value private subroutine get_child_value_string_list(table, key, list, error) Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table Instance of the TOML data structure character(len=*), intent(in) :: key Key to read from type( string_t ), intent(out), allocatable :: list (:) List of strings to read type( error_t ), intent(out), allocatable :: error Error handling Subroutines public subroutine read_package_file (table, manifest, error) Process the configuration file to a TOML data structure Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: table TOML data structure character(len=*), intent(in) :: manifest Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation","tags":"","loc":"module/fpm_toml.html"},{"title":"fpm_manifest – Fortran-lang/fpm","text":"Package configuration data. This module provides the necessary procedure to translate a TOML document\n to the corresponding Fortran type, while verifying it with respect to\n its schema. Additionally, the required data types for users of this module are reexported\n to hide the actual implementation details. Uses fpm_manifest_build fpm_manifest_example fpm_manifest_executable fpm_manifest_dependency fpm_manifest_library fpm_manifest_package fpm_error fpm_toml fpm_manifest_test fpm_filesystem Contents Subroutines default_example default_executable default_library default_test get_package_data Subroutines public subroutine default_example (self, name) Populate test in case we find the default example/ directory Arguments Type Intent Optional Attributes Name type( example_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package public subroutine default_executable (self, name) Populate executable in case we find the default app directory Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package public subroutine default_library (self) Populate library in case we find the default src directory Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library meta data public subroutine default_test (self, name) Populate test in case we find the default test/ directory Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the executable meta data character(len=*), intent(in) :: name Name of the package public subroutine get_package_data (package, file, error, apply_defaults) Obtain package meta data from a configuation file Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: package Parsed package meta data character(len=*), intent(in) :: file Name of the package configuration file type( error_t ), intent(out), allocatable :: error Error status of the operation logical, intent(in), optional :: apply_defaults Apply package defaults (uses file system operations)","tags":"","loc":"module/fpm_manifest.html"},{"title":"fpm_installer – Fortran-lang/fpm","text":"Implementation of an installer object. The installer provides a way to install objects to their respective directories\n in the installation prefix, a generic install command allows to install\n to any directory within the prefix. Uses iso_fortran_env fpm_environment fpm_error fpm_filesystem Contents Derived Types installer_t Subroutines new_installer Derived Types type, public :: installer_t Declaration of the installer type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: bindir Binary dir relative to the installation prefix character(len=:), public, allocatable :: copy Command to copy objects into the installation prefix character(len=:), public, allocatable :: includedir Include directory relative to the installation prefix character(len=:), public, allocatable :: libdir Library directory relative to the installation prefix integer, public :: os Cached operating system character(len=:), public, allocatable :: prefix Path to installation directory integer, public :: unit = output_unit Output unit for informative printout integer, public :: verbosity = 1 Verbosity of the installer Type-Bound Procedures procedure, public :: install Install a generic file into a subdirectory in the installation prefix procedure, public :: install_executable Install an executable in its correct subdirectory procedure, public :: install_header Install a header/module in its correct subdirectory procedure, public :: install_library Install a library in its correct subdirectory procedure, public :: make_dir Create a new directory in the prefix, type-bound for unit testing purposes procedure, public :: run Run an installation command, type-bound for unit testing purposes Subroutines public subroutine new_installer (self, prefix, bindir, libdir, includedir, verbosity, copy) Create a new instance of an installer Arguments Type Intent Optional Attributes Name type( installer_t ), intent(out) :: self Instance of the installer character(len=*), intent(in), optional :: prefix Path to installation directory character(len=*), intent(in), optional :: bindir Binary dir relative to the installation prefix character(len=*), intent(in), optional :: libdir Library directory relative to the installation prefix character(len=*), intent(in), optional :: includedir Include directory relative to the installation prefix integer, intent(in), optional :: verbosity Verbosity of the installer character(len=*), intent(in), optional :: copy Copy command","tags":"","loc":"module/fpm_installer.html"},{"title":"fpm_versioning – Fortran-lang/fpm","text":"Implementation of versioning data for comparing packages Uses fpm_error Contents Interfaces char new_version Derived Types version_t Interfaces public interface char private function as_string(self) result(string) Arguments Type Intent Optional Attributes Name class( version_t ), intent(in) :: self Version number Return Value character(len=:),\n  allocatable Character representation of the version public interface new_version private subroutine new_version_from_string(self, string, error) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data character(len=*), intent(in) :: string String describing the version information type( error_t ), intent(out), allocatable :: error Error handling private subroutine new_version_from_int(self, num) Create a new version from a string Arguments Type Intent Optional Attributes Name type( version_t ), intent(out) :: self Instance of the versioning data integer, intent(in) :: num (:) Subversion numbers to define version data Derived Types type, public :: version_t Type-Bound Procedures generic, public :: operator(.match.) => match Compare a version against a version constraint (x.x.0 <= v < x.x.HUGE) generic, public :: operator(/=) => not_equals generic, public :: operator(<) => less generic, public :: operator(<=) => less_equals generic, public :: operator(==) => equals generic, public :: operator(>) => greater generic, public :: operator(>=) => greater_equals procedure, public :: to_string Create a printable string from a version data type","tags":"","loc":"module/fpm_versioning.html"},{"title":"fpm_dependency – Fortran-lang/fpm","text":"# Dependency management ## Fetching dependencies and creating a dependency tree Dependencies on the top-level can be specified from: package%dependencies package%dev_dependencies package%executable(:)%dependencies package%test(:)%dependencies Each dependency is fetched in some way and provides a path to its package\n manifest.\n The package%dependencies of the dependencies are resolved recursively. To initialize the dependency tree all dependencies are recursively fetched\n and stored in a flat data structure to avoid retrieving a package twice.\n The data structure used to store this information should describe the current\n status of the dependency tree. Important information are: name of the package version of the package path to the package root Additionally, for version controlled dependencies the following should be\n stored along with the package: the upstream url the current checked out revision Fetching a remote (version controlled) dependency turns it for our purpose\n into a local path dependency which is handled by the same means. ## Updating dependencies For a given dependency tree all top-level dependencies can be updated.\n We have two cases to consider, a remote dependency and a local dependency,\n again, remote dependencies turn into local dependencies by fetching.\n Therefore we will update remote dependencies by simply refetching them. For remote dependencies we have to refetch if the revision in the manifest\n changes or the upstream HEAD has changed (for branches and tags). Note For our purpose a tag is just a fancy branch name. Tags can be delete and\n       modified afterwards, therefore they do not differ too much from branches\n       from our perspective. For the latter case we only know if we actually fetch from the upstream URL. In case of local (and fetched remote) dependencies we have to read the package\n manifest and compare its dependencies against our dependency tree, any change\n requires updating the respective dependencies as well. ## Handling dependency compatibilties Currenly ignored. First come, first serve. Uses iso_fortran_env fpm_environment fpm_error fpm_filesystem fpm_git fpm_manifest fpm_strings fpm_toml fpm_versioning Contents Interfaces resize Derived Types dependency_node_t dependency_tree_t Subroutines new_dependency_node new_dependency_tree Interfaces public interface resize Overloaded reallocation interface private pure subroutine resize_dependency_node(var, n) Reallocate a list of dependencies Arguments Type Intent Optional Attributes Name type( dependency_node_t ), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size Derived Types type, public, extends( dependency_config_t ) :: dependency_node_t Dependency node in the projects dependency tree Components Type Visibility Attributes Name Initial logical, public :: done = .false. Dependency is handled type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target character(len=:), public, allocatable :: proj_dir Installation prefix of this dependencies character(len=:), public, allocatable :: revision Checked out revision of the version control system logical, public :: update = .false. Dependency should be updated type( version_t ), public, allocatable :: version Actual version of this dependency Type-Bound Procedures procedure, public :: info Print information on this instance procedure, public :: register Update dependency from project manifest type, public :: dependency_tree_t Respresentation of a projects dependencies Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cache Cache file type( dependency_node_t ), public, allocatable :: dep (:) Flattend list of all dependencies character(len=:), public, allocatable :: dep_dir Installation prefix for dependencies integer, public :: ndep = 0 Number of currently registered dependencies integer, public :: unit = output_unit Unit for IO integer, public :: verbosity = 1 Verbosity of printout Type-Bound Procedures generic, public :: add => add_project, add_project_dependencies, add_dependencies, add_dependency Overload procedure to add new dependencies to the tree generic, public :: dump => dump_to_file, dump_to_unit, dump_to_toml Writing of dependency tree generic, public :: find => find_dependency, find_name Find a dependency in the tree procedure, public :: finished Depedendncy resolution finished generic, public :: load => load_from_file, load_from_unit, load_from_toml Reading of dependency tree generic, public :: resolve => resolve_dependencies, resolve_dependency Resolve dependencies generic, public :: update => update_dependency Update dependency tree Subroutines public pure subroutine new_dependency_node (self, dependency, version, proj_dir, update) Create a new dependency node from a configuration Arguments Type Intent Optional Attributes Name type( dependency_node_t ), intent(out) :: self Instance of the dependency node type( dependency_config_t ), intent(in) :: dependency Dependency configuration data type( version_t ), intent(in), optional :: version Version of the dependency character(len=*), intent(in), optional :: proj_dir Installation prefix of the dependency logical, intent(in), optional :: update Dependency should be updated public subroutine new_dependency_tree (self, verbosity, cache) Create a new dependency tree Arguments Type Intent Optional Attributes Name type( dependency_tree_t ), intent(out) :: self Instance of the dependency tree integer, intent(in), optional :: verbosity Verbosity of printout character(len=*), intent(in), optional :: cache Name of the cache file","tags":"","loc":"module/fpm_dependency.html"},{"title":"fpm_cmd_install – Fortran-lang/fpm","text":"Uses iso_fortran_env fpm fpm_backend fpm_command_line fpm_error fpm_filesystem fpm_installer fpm_manifest fpm_model fpm_strings Contents Subroutines cmd_install Subroutines public subroutine cmd_install (settings) Entry point for the fpm-install subcommand Arguments Type Intent Optional Attributes Name type( fpm_install_settings ), intent(in) :: settings Representation of the command line settings","tags":"","loc":"module/fpm_cmd_install.html"},{"title":"fpm_cmd_new – Fortran-lang/fpm","text":"Uses fpm_command_line fpm_environment fpm_filesystem iso_fortran_env Contents Subroutines cmd_new Subroutines public subroutine cmd_new (settings) Arguments Type Intent Optional Attributes Name type( fpm_new_settings ), intent(in) :: settings","tags":"","loc":"module/fpm_cmd_new.html"},{"title":"fpm_cmd_update – Fortran-lang/fpm","text":"Uses fpm_command_line fpm_dependency fpm_error fpm_filesystem fpm_manifest Contents Subroutines cmd_update Subroutines public subroutine cmd_update (settings) Entry point for the update subcommand Arguments Type Intent Optional Attributes Name type( fpm_update_settings ), intent(in) :: settings Representation of the command line arguments","tags":"","loc":"module/fpm_cmd_update.html"},{"title":"fpm_manifest_install – Fortran-lang/fpm","text":"Implementation of the installation configuration. An install table can currently have the following fields library = bool Uses fpm_error fpm_toml Contents Derived Types install_config_t Subroutines new_install_config Derived Types type, public :: install_config_t Configuration data for installation Components Type Visibility Attributes Name Initial logical, public :: library Install library with this project Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_install_config (self, table, error) Create a new installation configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( install_config_t ), intent(out) :: self Instance of the install configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_install.html"},{"title":"fpm_manifest_example – Fortran-lang/fpm","text":"Implementation of the meta data for an example. The example data structure is effectively a decorated version of an executable\n and shares most of its properties, except for the defaults and can be\n handled under most circumstances just like any other executable. A example table can currently have the following fields [[ example ]] name = \"string\" source-dir = \"path\" main = \"file\" link = [\"lib\"] [example.dependencies] Uses fpm_manifest_dependency fpm_manifest_executable fpm_error fpm_toml Contents Derived Types example_config_t Subroutines new_example Derived Types type, public, extends( executable_config_t ) :: example_config_t Configuation meta data for an example Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_example (self, table, error) Construct a new example configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( example_config_t ), intent(out) :: self Instance of the example configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_example.html"},{"title":"fpm_manifest_package – Fortran-lang/fpm","text":"Define the package data containing the meta data from the configuration file. The package data defines a Fortran type corresponding to the respective\n TOML document, after creating it from a package file no more interaction\n with the TOML document is required. Every configuration type provides it custom constructor (prefixed with new_ )\n and knows how to deserialize itself from a TOML document.\n To ensure we find no untracked content in the package file all keywords are\n checked and possible entries have to be explicitly allowed in the check function.\n If entries are mutally exclusive or interdependent inside the current table\n the check function is required to enforce this schema on the data structure. The package file root allows the following keywords name = \"string\" version = \"string\" license = \"string\" author = \"string\" maintainer = \"string\" copyright = \"string\" [library] [dependencies] [dev-dependencies] [build] [install] [[ executable ]] [[ example ]] [[ test ]] Uses fpm_manifest_build fpm_manifest_dependency fpm_manifest_example fpm_manifest_executable fpm_manifest_library fpm_manifest_install fpm_manifest_test fpm_error fpm_toml fpm_versioning Contents Derived Types package_config_t Subroutines new_package Derived Types type, public :: package_config_t Package meta data Components Type Visibility Attributes Name Initial type( build_config_t ), public :: build Build configuration data type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data type( dependency_config_t ), public, allocatable :: dev_dependency (:) Development dependency meta data type( example_config_t ), public, allocatable :: example (:) Example meta data type( executable_config_t ), public, allocatable :: executable (:) Executable meta data type( install_config_t ), public :: install Installation configuration data type( library_config_t ), public, allocatable :: library Library meta data character(len=:), public, allocatable :: name Name of the package type( test_config_t ), public, allocatable :: test (:) Test meta data type( version_t ), public :: version Package version Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_package (self, table, error) Construct a new package configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( package_config_t ), intent(out) :: self Instance of the package configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_package.html"},{"title":"fpm_manifest_library – Fortran-lang/fpm","text":"Implementation of the meta data for libraries. A library table can currently have the following fields [library] source-dir = \"path\" build-script = \"file\" Uses fpm_error fpm_toml Contents Derived Types library_config_t Subroutines new_library Derived Types type, public :: library_config_t Configuration meta data for a library Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: build_script Alternative build script to be invoked character(len=:), public, allocatable :: source_dir Source path prefix Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_library (self, table, error) Construct a new library configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( library_config_t ), intent(out) :: self Instance of the library configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_library.html"},{"title":"fpm_manifest_test – Fortran-lang/fpm","text":"Implementation of the meta data for a test. The test data structure is effectively a decorated version of an executable\n and shares most of its properties, except for the defaults and can be\n handled under most circumstances just like any other executable. A test table can currently have the following fields [[ test ]] name = \"string\" source-dir = \"path\" main = \"file\" link = [\"lib\"] [test.dependencies] Uses fpm_manifest_dependency fpm_manifest_executable fpm_error fpm_toml Contents Derived Types test_config_t Subroutines new_test Derived Types type, public, extends( executable_config_t ) :: test_config_t Configuation meta data for an test Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_test (self, table, error) Construct a new test configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( test_config_t ), intent(out) :: self Instance of the test configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_test.html"},{"title":"fpm_manifest_executable – Fortran-lang/fpm","text":"Implementation of the meta data for an executables. An executable table can currently have the following fields [[ executable ]] name = \"string\" source-dir = \"path\" main = \"file\" link = [\"lib\"] [executable.dependencies] Uses fpm_manifest_dependency fpm_error fpm_strings fpm_toml Contents Derived Types executable_config_t Subroutines new_executable Derived Types type, public :: executable_config_t Configuation meta data for an executable Components Type Visibility Attributes Name Initial type( dependency_config_t ), public, allocatable :: dependency (:) Dependency meta data for this executable type( string_t ), public, allocatable :: link (:) Libraries to link against character(len=:), public, allocatable :: main Name of the source file declaring the main program character(len=:), public, allocatable :: name Name of the resulting executable character(len=:), public, allocatable :: source_dir Source directory for collecting the executable Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_executable (self, table, error) Construct a new executable configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( executable_config_t ), intent(out) :: self Instance of the executable configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_executable.html"},{"title":"fpm_manifest_dependency – Fortran-lang/fpm","text":"Implementation of the meta data for dependencies. A dependency table can currently have the following fields [dependencies] \"dep1\" = { git = \"url\" } \"dep2\" = { git = \"url\" , branch = \"name\" } \"dep3\" = { git = \"url\" , tag = \"name\" } \"dep4\" = { git = \"url\" , rev = \"sha1\" } \"dep0\" = { path = \"path\" } To reduce the amount of boilerplate code this module provides two constructors\n for dependency types, one basic for an actual dependency (inline) table\n and another to collect all dependency objects from a dependencies table,\n which is handling the allocation of the objects and is forwarding the\n individual dependency tables to their respective constructors.\n The usual entry point should be the constructor for the super table. This objects contains a target to retrieve required fpm projects to\n build the target declaring the dependency.\n Resolving a dependency will result in obtaining a new package configuration\n data for the respective project. Uses fpm_error fpm_git fpm_toml Contents Derived Types dependency_config_t Subroutines new_dependencies new_dependency Derived Types type, public :: dependency_config_t Configuration meta data for a dependency Components Type Visibility Attributes Name Initial type( git_target_t ), public, allocatable :: git Git descriptor character(len=:), public, allocatable :: name Name of the dependency character(len=:), public, allocatable :: path Local target Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_dependencies (deps, table, error) Construct new dependency array from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out), allocatable :: deps (:) Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling public subroutine new_dependency (self, table, error) Construct a new dependency configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( dependency_config_t ), intent(out) :: self Instance of the dependency configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_dependency.html"},{"title":"fpm_manifest_build – Fortran-lang/fpm","text":"Implementation of the build configuration data. A build table can currently have the following fields [build] auto-executables = bool auto-examples = bool auto-tests = bool link = [\"lib\"] Uses fpm_error fpm_strings fpm_toml Contents Derived Types build_config_t Subroutines new_build_config Derived Types type, public :: build_config_t Configuration data for build Components Type Visibility Attributes Name Initial logical, public :: auto_examples Automatic discovery of examples logical, public :: auto_executables Automatic discovery of executables logical, public :: auto_tests Automatic discovery of tests type( string_t ), public, allocatable :: link (:) Libraries to link against Type-Bound Procedures procedure, public :: info Print information on this instance Subroutines public subroutine new_build_config (self, table, error) Construct a new build configuration from a TOML data structure Arguments Type Intent Optional Attributes Name type( build_config_t ), intent(out) :: self Instance of the build configuration type(toml_table), intent(inout) :: table Instance of the TOML data structure type( error_t ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/fpm_manifest_build.html"},{"title":"Packaging and contributing – Fortran-lang/fpm","text":"","tags":"","loc":"page//index.html"},{"title":"Contributing Guidelines – Fortran-lang/fpm","text":"Contributing to the Fortran Package Manager Thank you for considering contributing to the Fortran Package Manager ( fpm ).\nPlease review and follow these guidelines to make the contribution process\nsimple and effective for all involved. It will help communicate that you\nrespect the time of the community developers. In return, the community will\nhelp address your problem, evaluate changes, and guide you through your pull\nrequests. By contributing to fpm , you certify that you own or are allowed to share the\ncontent of your contribution under the fpm license . Style Reporting a bug Suggesting a feature Workflow General guidelines For new contributors Style Please follow the Fortran stdlib style guide for any Fortran code that you contribute.\nThis allows us to focus on substance rather than style. Reporting a bug A bug is a demonstrable problem caused by the code in this repository.\nGood bug reports are extremely valuable to us—thank you! Before opening a bug report: Check if the issue has already been reported\n   ( issues ). Check if it is still an issue or it has been fixed?\n   Try to reproduce it with the latest version from the master branch. Isolate the problem and create a minimal test case. A good bug report should include all information needed to reproduce the bug.\nPlease be as detailed as possible: Which version of fpm are you using? Please be specific. What are the steps to reproduce the issue? What is the expected outcome? What happens instead? This information will help the community diagnose the issue quickly and with\nminimal back-and-forth. Suggesting a feature Before suggesting a new feature, take a moment to find out if it fits the scope\nof the project, or if it has already been discussed. It is up to you to provide\na strong argument to convince the community of the benefits of this feature.\nPlease provide as much detail and context as possible. If applicable, include a\nmocked-up snippet of what the output or behavior would look like with this\nfeature implemented. “Crazy”, out-of-the-box ideas are especially welcome.\nIt’s quite possible that we are not considering an unusually creative solution. Workflow fpm is a community project. There is no one single person making final\ndecisions. This is the workflow that we follow: Open a new issue to\n   describe a bug or propose a new feature.\n   Refer to the earlier sections on how to write a good bug report or feature\n   request. Discuss with the community and reach majority consensus about what should be\n   done about the bug or feature request.\n   We define “majority” loosely as 80%.\n   This means that at least 4 of 5 people engaged in the discussion should be\n   able to agree on the next step.\n   This allows us to have the community mostly agree while not getting stuck if\n   one person disagrees.\n   At this stage, the scope of the fix/feature, its behavior, and API if\n   applicable should be defined.\n   Only when you have community consensus on these items you should proceed to\n   writing code and opening a PR. When actively working on code towards a PR, please assign yourself to the\n   issue on GitHub. This is good collaborative practice to avoid duplicated effort and also\n   inform others what you are currently working on. Open a new Pull Request (PR) with your contribution.\n   The body of the PR should at least include a bullet-point summary of the\n   changes, and a detailed description is encouraged.\n   If the PR completely addresses the issue you opened in step 1, include in\n   the PR description the following line: Fixes #<issue-number> . Request reviewers to your PR.\n   For small bug fixes or documentation improvements, 1 to 2 reviewers is\n   sufficient.\n   For implementation of bigger features, request 3 to 4 or more reviewers.\n   Ideally, request reviewers that participated in step 2. If your PR implements a feature that adds or changes the behavior of fpm ,\n   your PR must also include appropriate changes to the documentation. This workflow can evolve and change over time as we learn how best to work\ntogether. If you have an idea on how to improve the workflow itself, please\nopen an issue and we’ll discuss it. General guidelines A PR should implement only one feature or bug fix. Do not commit changes to files that are irrelevant to your feature or bug fix. Smaller PRs are better than large PRs, and will lead to a shorter review and\n  merge cycle Add tests for your feature or bug fix to be sure that it stays functional and useful Be open to constructive criticism and requests for improving your code. Again, please follow the Fortran stdlib style guide . For new contributors If you have never created a pull request before, welcome :tada:.\nYou can learn how from this great tutorial . Don’t know where to start?\nYou can start by looking through the list of open issues .","tags":"","loc":"page/./Contributing.html"},{"title":"License – Fortran-lang/fpm","text":"MIT License Copyright (c) 2020 fpm contributors Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Manifest reference – Fortran-lang/fpm","text":"Fortran package manager (fpm) manifest reference The fpm.toml file for each project is called its manifest .\nIt is written using the TOML format.\nEvery manifest file consists of the following sections: name :\n  The name of the project version :\n  The version of the project license :\n  The project license maintainer :\n  Maintainer of the project author :\n  Author of the project copyright :\n  Copyright of the project description :\n  Description of the project categories :\n  Categories associated with the project keywords :\n  Keywords describing the project homepage :\n  The project’s homepage Build configuration: auto-tests :\n    Toggle automatic discovery of test executables auto-examples :\n    Toggle automatic discovery of example programs auto-executables :\n    Toggle automatic discovery of executables link :\n    Link with external dependencies Target sections: library Configuration of the library target executable Configuration of the executable targets test Configuration of the test targets Dependency sections: dependencies :\n    Project library dependencies dev-dependencies :\n    Dependencies only needed for tests install :\n  Installation configuration Project name The project name identifies the package and is used to refer to it.\nIt is used when listing the project as dependency for another package and the default name of the library and executable target.\nTherefore, the project name must always be present. Example: name = \"hello_world\" Project version The version number of the project is specified as string.\nA standardized way to manage and specify versions is the Semantic Versioning scheme. Example: version = \"1.0.0\" Project license The project license field contains the license identifier.\nA standardized way to specify licensing information are SPDX identifiers. Examples: Projects licensed under the GNU Lesser General Public License , either version 3 or any later version, is specified as license = \"LGPL-3.0-or-later\" Dual licensed project under the Apache license, version 2.0 or the MIT license are specified as license = \"Apache-2.0 OR MIT\" Project maintainer Information on the project maintainer and means to reach out to them. Example: maintainer = \"jane.doe@example.com\" Project author Information on the project author. Example: author = \"Jane Doe\" Project copyright A statement clarifying the copyright status of the project. Example: copyright = \"Copyright 2020 Jane Doe\" Project description The description provides a short summary on the project.\nIt should be plain text and not using any markup formatting. Example: description = \"A short summary on this project\" Project categories The project can be associated with different categories. Example: categories = [\"io\"] Project keywords The keywords field is an array of strings describing the project. Example: keywords = [\"hdf5\", \"mpi\"] Project homepage URL to the webpage of the project. Example: homepage = \"https://stdlib.fortran-lang.org\" Project targets Every fpm project can define library, executable and test targets.\nLibrary targets are exported and useable for other projects. Library configuration Defines the exported library target of the project.\nA library is generated if the source directory is found in a project.\nThe default source directory is src but can be modified in the library section using the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms. Example: [library] source-dir = \"lib\" Custom build script Supported in Bootstrap fpm only Projects with custom build scripts can specify those in the build-script entry.\nThe custom build script will be executed when the library build step is reached. Example: [library] build-script = \"build.sh\" Build scripts written in make are automatically detected and executed with make [library] build-script = \"Makefile\" Executable targets Executable targets are Fortran programs defined as executable sections.\nIf no executable section is specified the app directory is searched for program definitions.\nFor explicitly specified executables the name entry must always be specified.\nThe source directory for each executable can be adjusted in the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms.\nThe source file containing the program body can be specified in the main entry. Executables can have their own dependencies.\nSee specifying dependencies for more details. Executables can also specify their own external library dependencies.\nSee external libraries for more details. Linking against libraries is supported in Fortran fpm only Example: [[ executable ]] name = \"app-name\" source-dir = \"prog\" main = \"program.f90\" [[ executable ]] name = \"app-tool\" link = \"z\" [executable.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } Specifying many separate executables can be done by using inline tables for brevity instead executable = [ { name = \"a-prog\" }, { name = \"app-tool\" , source-dir = \"tool\" }, ] Example targets Example applications for a project are defined as example sections.\nIf no example section is specified the example directory is searched for program definitions.\nFor explicitly specified examples the name entry must always be specified.\nThe source directory for each example can be adjusted in the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms.\nThe source file containing the program body can be specified in the main entry. Examples can have their own dependencies.\nSee specifying dependencies for more details. Examples can also specify their own external library dependencies.\nSee external libraries for more details. Linking against libraries is supported in Fortran fpm only Example: [[ example ]] name = \"demo-app\" source-dir = \"demo\" main = \"program.f90\" [[ example ]] name = \"example-tool\" link = \"z\" [example.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } Test targets Test targets are Fortran programs defined as test sections.\nThey follow similar rules as the executable targets.\nIf no test section is specified the test directory is searched for program definitions.\nFor explicitly specified tests the name entry must always be specified.\nThe source directory for each test can be adjusted in the source-dir entry.\nPaths for the source directory are given relative to the project root and use / as path separator on all platforms.\nThe source file containing the program body can be specified in the main entry. Tests can have their own dependencies.\nSee specifying dependencies for more details. Tests can also specify their own external library dependencies.\nSee external libraries for more details. Linking against libraries is supported in Fortran fpm only Example: [[ test ]] name = \"test-name\" source-dir = \"testing\" main = \"tester.F90\" [[ test ]] name = \"tester\" link = [\"blas\", \"lapack\"] [test.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } Link external libraries Supported in Fortran fpm only To declare link time dependencies on external libraries a list of native libraries can be specified in the link entry.\nSpecify either one library as string or a list of strings in case several libraries should be linked.\nWhen possible the project should only link one native library.\nThe list of library dependencies is exported to dependent packages. Example: To link against the zlib compression library use [build] link = \"z\" To dependent on LAPACK also BLAS should be linked.\nIn this case the order of the libraries matters: [build] link = [\"blas\", \"lapack\"] Automatic target discovery Supported in Fortran fpm only Executables and test can be discovered automatically in their default directories.\nThe automatic discovery recursively searches the app , example , and test directories for program definitions and declares them as executable, example, and test targets, respectively.\nThe automatic discovery is enabled by default. To disable the automatic discovery of targets set the auto-executables , auto-examples , and auto-tests entry to false . [build] auto-executables = false auto-examples = false auto-tests = false Specifying dependencies Dependencies can be declared in the dependencies table in the manifest root or the executable or test sections.\nWhen declared in the manifest root the dependencies are exported with the project. Local dependencies To declare local dependencies use the path entry. [dependencies] my-utils = { path = \"utils\" } Local dependency paths are given relative to the project root and use / as path separator on all platforms. Dependencies from version control systems Dependencies can be specified by the projects git repository. [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" } To use a specific upstream branch declare the branch name with [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , branch = \"master\" } Alternatively, reference tags by using the tag entry [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , tag = \"v0.2.1\" } To pin a specific revision specify the commit hash in the rev entry [dependencies] toml-f = { git = \"https://github.com/toml-f/toml-f\" , rev = \"2f5eaba\" } For more verbose layout use normal tables rather than inline tables to specify dependencies [dependencies] [dependencies.toml-f] git = \"https://github.com/toml-f/toml-f\" rev = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\" Development dependencies Development dependencies allow to declare dev-dependencies in the manifest root, which are available to all tests but not exported with the project. Installation configuration In the install section components for the installation can be selected.\nBy default only executables are installed, library projects can set the library boolean to also installatation the module files and the archive. Example [install] library = true","tags":"","loc":"page/./Manifest.html"},{"title":"Packaging with fpm – Fortran-lang/fpm","text":"Preparing your package for FPM This document describes how you need to organize your application or library for\nit to successfully build with the Fortran Package Manager ( fpm ). What kind of package can fpm build? Example package layouts Single program Single-module library Multi-module library Application and library Multi-level library Be more explicit Add some tests Adding dependencies Custom build scripts What kind of package can fpm build? You can use fpm to build: Applications (program only) Libraries (modules only) Combination of the two (programs and modules combined) Let’s look at some examples of different kinds of package layouts that you can\nuse with fpm . Example package layouts This section describes some example package layouts that you can build with fpm . You can use them to model the layout of your own package. Single program Let’s start with the simplest package imaginable—a single program without\ndependencies or modules. Here’s what the layout of the top-level directory\nlooks like: . ├── app │   └── main.f90 └── fpm.toml We have one source file ( main.f90 ) in one directory ( app ). Its contents\nare: program main print * , 'Hello, World!' end program main This program prints the usual greeting to the standard output, and nothing more. There’s another important file in the top-level directory, fpm.toml .  This is fpm ’s configuration file specific to your package.  It includes all the data\nthat fpm needs to build your app.  In our simple case, it looks like this: name = \"hello\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" The preamble includes some metadata, such as license , author , and similar,\nthat you may have seen in other package manager configuration files.  The one\noption that matters here right now is: name = \"hello\" This line specifies the name of your package, which determines the name of the\nexecutable file of your program. In this example, our program executable, once\nbuilt, will be called hello . Let’s now build this program using fpm : $ fpm build # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/hello) On the first line, we ran fpm build to compile and link the application.\nThe latter two lines are emitted by fpm , and indicate which command was\nexecuted at each build step ( gfortran ), and which files have been output\nby it: object file main.o , and executable hello . We can now run the app with fpm run : $ fpm run\n Hello, World! If your application needs to use a module internally, but you don’t intend\nto build it as a library to be used in other projects, you can include the\nmodule in your program source file as well.\nFor example: $ cat app / main . f90 module math_constants real , parameter :: pi = 4 * atan ( 1. ) end module math_constants program main use math_constants , only : pi print * , 'Hello, World!' print * , 'pi = ' , pi end program main Now, run this using fpm run : $ fpm run # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/hello) Hello, World! pi = 3 .14159274 Notice that you can run fpm run , and if the package hasn’t been built yet, fpm build will run automatically for you. This is true if the source files\nhave been updated since the last build.  Thus, if you want to run your\napplication, you can skip the fpm build step, and go straight to fpm run . Although we have named our program hello , which is the same name as the\npackage name in fpm.toml , you can name it anything you want as long as it’s\npermitted by the language. In this last example, our source file defined a math_constants module inside\nthe same source file as the main program. Let’s see how we can define an fpm package that makes this module available as a library. Single-module library The package layout for this example looks like this: . ├── fpm . toml └── src └── math_constants . f90 In this example we’ll build a simple math constants library that exports\nthe number pi as a parameter: $ cat src / math_constants . f90 module math_constants real , parameter :: pi = 4 * atan ( 1. ) end module math_constants and our fpm.toml is the same as before. Now use fpm build to build the package: $ fpm build # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a Based on the output of fpm build , fpm first ran gfortran to emit the\nbinary object ( math_constants.o ) and module ( math_constants.mod ) files.\nThen it ran ar to create a static library archive math_constants.a . build/debug/library is thus both your include and library path, should you\nwant to compile and link an external program with this library. For modules in the top-level ( src ) directory, fpm requires that: The module has the same name as the source file. There is only one module per file. These two requirements simplify the build process for fpm . As Fortran\ncompilers emit module files ( .mod ) with the same name as the module itself\n(but not the source file, .f90 ), naming the module the same as the source file\nallows fpm to: Uniquely and exactly map a source file ( .f90 ) to its object ( .o ) and\nmodule ( .mod ) files. Avoid conflicts with modules of the same name that could appear in dependency\npackages (more on this in a bit). Since this is a library without executable programs, fpm run here does\nnothing. In this example, our library is made of only one module. However, most\nreal-world libraries are likely to use multiple modules. Let’s see how you can\npackage your multi-module library. Multi-module library In this example, we’ll use another module to define a 64-bit real kind\nparameter and make it available in math_constants to define pi with\nhigher precision. To make this exercise worthwhile, we’ll define another math\nconstant, Euler’s number. Our package layout looks like this: . ├── fpm . toml └── src ├── math_constants . f90 └── type_kinds . f90 And our source file contents are: $ cat src / math_constants . f90 module math_constants use type_kinds , only : rk real ( rk ), parameter :: pi = 4 * atan ( 1._rk ) real ( rk ), parameter :: e = exp ( 1._rk ) end module math_constants $ cat src / type_kinds . f90 module type_kinds use iso_fortran_env , only : real64 integer , parameter :: rk = real64 end module type_kinds and there are no changes to our fpm.toml relative to previous examples. Like before, notice that the module type_kinds is name exactly as the\nsource file that contains it.\nThis is important. By now you know how to build the package: $ fpm build # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a Our build path now contains: $ ls build/debug/library/\nmath_constants.a  math_constants.mod  math_constants.o  type_kinds.mod  type_kinds.o And the static library includes all the object files: $ nm build/debug/library/math_constants.a\n\nmath_constants.o:\n\ntype_kinds.o: The takeaways from this example are that: fpm automatically scanned the src directory for any source files. It also resolved the dependency order between different modules. Application and library Let’s now combine the two previous examples into one: We’ll build the math\nconstants library and an executable program that uses it. We’ll use this\nprogram as a demo, and to verify that defining higher-precision constants from\nthe previous example actually worked. Here’s the package layout for your application + library package: . ├── app │ └── main . f90 ├── fpm . toml └── src ├── math_constants . f90 └── type_kinds . f90 Our fpm.toml remains unchanged and our executable program source file is: $ cat app / main . f90 program main use math_constants , only : e , pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , 'e = ' , e end program main Let’s go straight to running the demo program: $ fpm run # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) math_constants library demo pi = 3 .1415926535897931 e = 2 .7182818284590451 The fpm build + run process works as expected, and our program correctly\noutputs higher-precision constants. So far we covered how fpm builds: A single program A single-module library A multi-module library A program and a library However, all our modules so far have been organized in the top level source\ndirectory. More complex libraries may organize their modules in subdirectories.\nLet’s see how we can build this with fpm . Multi-level library In this example, we’ll define our library as a collection of modules, two of\nwhich are defined in a subdirectory: . ├── app │ └── main . f90 ├── fpm . toml └── src ├── math_constants │ ├── derived . f90 │ └── fundamental . f90 ├── math_constants . f90 └── type_kinds . f90 First, fpm.toml and src/type_kinds.f90 remain unchanged relative to the\nprevious example. The rest of the source files are: $ cat src / math_constants . f90 module math_constants use math_constants_fundamental , only : e , pi use math_constants_derived , only : half_pi , two_pi end module math_constants $ cat src / math_constants / fundamental . f90 module math_constants_fundamental use type_kinds , only : rk real ( rk ), parameter :: pi = 4 * atan ( 1._rk ) real ( rk ), parameter :: e = exp ( 1._rk ) end module math_constants_fundamental $ cat src / math_constants / derived . f90 module math_constants_derived use math_constants_fundamental , only : pi use type_kinds , only : rk real ( rk ), parameter :: two_pi = 2 * pi real ( rk ), parameter :: half_pi = pi / 2 end module math_constants_derived $ cat app / main . f90 program main use math_constants , only : e , pi , half_pi , two_pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , '2*pi = ' , two_pi print * , 'pi/2 = ' , half_pi print * , 'e = ' , e end program main Our top-level math_constants module now doesn’t define the constants, but\nimports them from the two modules in the subdirectory. Constants e and pi we define in the math_constants_fundamental module, and two_pi and half_pi in the math_constants_derived module. From the main program, we access all\nthe constants from the top-level module math_constants . Let’s build and run this package: $ fpm run # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants_fundamental.o build/debug/library/math_constants_fundamental.mod) # gfortran (for build/debug/library/math_constants_derived.o build/debug/library/math_constants_derived.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) math_constants library demo pi = 3 .1415926535897931 2 *pi = 6 .2831853071795862\n pi/2 = 1 .5707963267948966 e = 2 .7182818284590451 Again, fpm built and run the package as expected. Recall from an earlier example that fpm required the modules in the top-level src directory to be named the same as their source file. This is why src/math_constants.f90 defines module math_constants . For modules defined in subdirectories, there’s an additional requirement: module\nname must contain the path components of the directory that its source file is\nin.  In our case, src/math_constants/fundamental.f90 defines the math_constants_fundamental module.  Likewise, src/math_constants/derived.f90 defines the math_constants_derived module. This rule applies generally to any number of nested directories and modules.\nFor example, src/a/b/c/d.f90 must define a module called a_b_c_d . Takeaways from this example are that: You can place your module source files in any levels of subdirectories inside src . The module name must include the path components and the source file name–for example, src/a/b/c/d.f90 must define a module called a_b_c_d . Be more explicit So far we’ve let fpm use its defaults to determine the layout of our package.\nIt determined where our library sources would live, what the name of the\nexecutable will be, and some other things. But we can be more explicit about it,\nand make some changes to those things. Let’s look at what the fpm.toml file from our last example would look like if\nwe specified everything. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" You can see that by making these explicit in the fpm.toml we are able to\nchange many of the settings that fpm used by default. We can change the\nfolders where our sources are stored, we can change the name of our executable,\nand we can change the name of the file our program is defined in. Add some tests fpm also provides support for unit testing. By default, fpm looks for a\nprogram in test/main.f90 which it will compile and execute with the command fpm test . The tests are treated pretty much exactly like the executables.\nLet’s define one explicitly in our fpm.toml file. We’ll make sure that our\ndefinition of pi satisfies the property sin(pi) == 0.0 . Here’s the fpm.toml file: name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" where the contents of the main.f90 file are program main use math_constants , only : pi print * , \"sin(pi) = \" , sin ( pi ) end program main With this setup, we can run our tests. $ fpm test # gfortran (for build/debug/library/type_kinds.o build/debug/library/type_kinds.mod) # gfortran (for build/debug/library/math_constants_fundamental.o build/debug/library/math_constants_fundamental.mod) # gfortran (for build/debug/library/math_constants_derived.o build/debug/library/math_constants_derived.mod) # gfortran (for build/debug/library/math_constants.o build/debug/library/math_constants.mod) # ar (for build/debug/library/math_constants.a) ar: creating build/debug/library/math_constants.a # gfortran (for build/debug/app/main.o) # gfortran (for build/debug/app/math_constants) # gfortran (for build/debug/test/main.o) # gfortran (for build/debug/test/runTests) sin ( pi ) = 1 .2246467991473532E-016 Adding dependencies Inevitably, you’ll want to be able to include other libraries in your project.\nfpm makes this incredibly simple, by taking care of fetching and compiling your\ndependencies for you. You just tell it what your dependencies are, and where to\nfind them. Let’s add a dependency to our library. Now our fpm.toml file looks\nlike this: name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" Now you can use any modules from this library anywhere in your code. Just like\nthis: program main use helloff , only : create_greeting use math_constants , only : e , pi , half_pi , two_pi print * , 'math_constants library demo' print * , 'pi = ' , pi print * , '2*pi = ' , two_pi print * , 'pi/2 = ' , half_pi print * , 'e = ' , e print * , create_greeting ( \"fpm\" ) end program main And now, fpm run will output the following: math_constants library demo pi = 3.1415926535897931 2 * pi = 6.2831853071795862 pi / 2 = 1.5707963267948966 e = 2.7182818284590451 Hello , fpm ! Additionally, any users of your library will now automatically depend on your\ndependencies too. So if you don’t need that dependency for the library, like in\nthe above example, then you can specify it for the specific executable like\nbelow. Then fpm will still fetch and compile it when building your executable,\nbut users of your library won’t have to. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [executable.dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" You can also specify dependencies for your tests in a similar way, with [test.dependencies] instead of [executable.dependencies] . There’s also\nanother option for test dependencies. The below example makes the dependencies\navailable for all the tests, but again your users won’t depend on these. name = \"math_constants\" version = \"0.1.0\" license = \"MIT\" author = \"Jane Programmer\" maintainer = \"jane@example.com\" copyright = \"2020 Jane Programmer\" [library] source-dir = \"src\" [dev-dependencies] helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\" } [[ executable ]] name = \"math_constants\" source-dir = \"app\" main = \"main.f90\" [[ test ]] name = \"runTests\" source-dir = \"test\" main = \"main.f90\" You can also be specific about which version of a dependency you’d like. You can\nspecify a branch to use like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" } ,\nor a tag like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", tag = \"v1.2.3\" } ,\nor even a specific commit like helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", rev = \"a1b2c3\" } .\nYou can even specify the path to another folder, if for example you’ve got\nanother fpm package in the same repository. Like this: helloff = { path = \"helloff\" } . Note that you should not specify paths\noutside of your repository, or things won’t work for your users. Custom build scripts If there is something special about your library that makes fpm unable to build\nit, you can provide your own build script. fpm will then simply call your build\nscript to build the library. To specify a build script to be used, put it in the library section of your fpm.toml file, like: [library] source-dir = \"src\" build-script = \"my_build_script\" fpm will set the following environment variables to specify some parameters to\nthe build script: FC – The Fortran compiler to be used. FFLAGS – The flags that should be passed to the Fortran compiler. BUILD_DIR – Where the compiled files should be placed. INCLUDE_DIRS – The folders where any dependencies can be found, space separated.\nIt is then the responsibility of the build script to generate the appropriate\ninclude flags. Additionally, script will be called with the name of the archive ( *.a file)\nthat should be produced as the command line argument. Note: If the name of the build script is Makefile or ends with .mk , then\nthe make program will be used to run it. Not the the archive file is explicitly\nspecified as the target to be built Note: All file and directory names are specified with their full canonical\npath.","tags":"","loc":"page/./Packaging.html"}]}